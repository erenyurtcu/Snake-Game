CCS PCM C Compiler, Version 5.025, 5967               01-Haz-25 18:27

               Filename:   C:\Users\Eren\Documents\CCS C Projects\snake_project\main.lst

               ROM used:   3637 words (44%)
                           Largest free fragment is 2048
               RAM used:   200 (54%) at main() level
                           264 (72%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   316
0003:  NOP
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDLW  0B
0008:  BTFSC  03.0
0009:  INCF   0A,F
000A:  MOVWF  02
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  5F
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  03
0017:  RETLW  00
0018:  RETLW  03
0019:  RETLW  00
001A:  RETLW  14
001B:  RETLW  3E
001C:  RETLW  14
001D:  RETLW  3E
001E:  RETLW  14
001F:  RETLW  24
0020:  RETLW  2A
0021:  RETLW  7F
0022:  RETLW  2A
0023:  RETLW  12
0024:  RETLW  43
0025:  RETLW  33
0026:  RETLW  08
0027:  RETLW  66
0028:  RETLW  61
0029:  RETLW  36
002A:  RETLW  49
002B:  RETLW  55
002C:  RETLW  22
002D:  RETLW  50
002E:  RETLW  00
002F:  RETLW  05
0030:  RETLW  03
0031:  RETLW  00
0032:  RETLW  00
0033:  RETLW  00
0034:  RETLW  1C
0035:  RETLW  22
0036:  RETLW  41
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  41
003A:  RETLW  22
003B:  RETLW  1C
003C:  RETLW  00
003D:  RETLW  14
003E:  RETLW  08
003F:  RETLW  3E
0040:  RETLW  08
0041:  RETLW  14
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  3E
0045:  RETLW  08
0046:  RETLW  08
0047:  RETLW  00
0048:  RETLW  50
0049:  RETLW  30
004A:  RETLW  00
004B:  RETLW  00
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  08
004F:  RETLW  08
0050:  RETLW  08
0051:  RETLW  00
0052:  RETLW  60
0053:  RETLW  60
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  20
0057:  RETLW  10
0058:  RETLW  08
0059:  RETLW  04
005A:  RETLW  02
005B:  RETLW  3E
005C:  RETLW  51
005D:  RETLW  49
005E:  RETLW  45
005F:  RETLW  3E
0060:  RETLW  04
0061:  RETLW  02
0062:  RETLW  7F
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  61
0067:  RETLW  51
0068:  RETLW  49
0069:  RETLW  46
006A:  RETLW  22
006B:  RETLW  41
006C:  RETLW  49
006D:  RETLW  49
006E:  RETLW  36
006F:  RETLW  18
0070:  RETLW  14
0071:  RETLW  12
0072:  RETLW  7F
0073:  RETLW  10
0074:  RETLW  27
0075:  RETLW  45
0076:  RETLW  45
0077:  RETLW  45
0078:  RETLW  39
0079:  RETLW  3E
007A:  RETLW  49
007B:  RETLW  49
007C:  RETLW  49
007D:  RETLW  32
007E:  RETLW  01
007F:  RETLW  01
0080:  RETLW  71
0081:  RETLW  09
0082:  RETLW  07
0083:  RETLW  36
0084:  RETLW  49
0085:  RETLW  49
0086:  RETLW  49
0087:  RETLW  36
0088:  RETLW  26
0089:  RETLW  49
008A:  RETLW  49
008B:  RETLW  49
008C:  RETLW  3E
008D:  RETLW  00
008E:  RETLW  36
008F:  RETLW  36
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  56
0094:  RETLW  36
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  08
0098:  RETLW  14
0099:  RETLW  22
009A:  RETLW  41
009B:  RETLW  00
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  14
009F:  RETLW  14
00A0:  RETLW  14
00A1:  RETLW  00
00A2:  RETLW  41
00A3:  RETLW  22
00A4:  RETLW  14
00A5:  RETLW  08
00A6:  RETLW  02
00A7:  RETLW  01
00A8:  RETLW  51
00A9:  RETLW  09
00AA:  RETLW  06
00AB:  RETLW  3E
00AC:  RETLW  41
00AD:  RETLW  59
00AE:  RETLW  55
00AF:  RETLW  5E
00B0:  RETLW  7E
00B1:  RETLW  09
00B2:  RETLW  09
00B3:  RETLW  09
00B4:  RETLW  7E
00B5:  RETLW  7F
00B6:  RETLW  49
00B7:  RETLW  49
00B8:  RETLW  49
00B9:  RETLW  36
00BA:  RETLW  3E
00BB:  RETLW  41
00BC:  RETLW  41
00BD:  RETLW  41
00BE:  RETLW  22
00BF:  RETLW  7F
00C0:  RETLW  41
00C1:  RETLW  41
00C2:  RETLW  41
00C3:  RETLW  3E
00C4:  RETLW  7F
00C5:  RETLW  49
00C6:  RETLW  49
00C7:  RETLW  49
00C8:  RETLW  41
00C9:  RETLW  7F
00CA:  RETLW  09
00CB:  RETLW  09
00CC:  RETLW  09
00CD:  RETLW  01
00CE:  RETLW  3E
00CF:  RETLW  41
00D0:  RETLW  41
00D1:  RETLW  49
00D2:  RETLW  3A
00D3:  RETLW  7F
00D4:  RETLW  08
00D5:  RETLW  08
00D6:  RETLW  08
00D7:  RETLW  7F
00D8:  RETLW  00
00D9:  RETLW  41
00DA:  RETLW  7F
00DB:  RETLW  41
00DC:  RETLW  00
00DD:  RETLW  30
00DE:  RETLW  40
00DF:  RETLW  40
00E0:  RETLW  40
00E1:  RETLW  3F
00E2:  RETLW  7F
00E3:  RETLW  08
00E4:  RETLW  14
00E5:  RETLW  22
00E6:  RETLW  41
00E7:  RETLW  7F
00E8:  RETLW  40
00E9:  RETLW  40
00EA:  RETLW  40
00EB:  RETLW  40
00EC:  RETLW  7F
00ED:  RETLW  02
00EE:  RETLW  0C
00EF:  RETLW  02
00F0:  RETLW  7F
00F1:  RETLW  7F
00F2:  RETLW  02
00F3:  RETLW  04
00F4:  RETLW  08
00F5:  RETLW  7F
00F6:  RETLW  3E
00F7:  RETLW  41
00F8:  RETLW  41
00F9:  RETLW  41
00FA:  RETLW  3E
00FB:  RETLW  7F
00FC:  RETLW  09
00FD:  RETLW  09
00FE:  RETLW  09
00FF:  RETLW  06
0100:  RETLW  1E
0101:  RETLW  21
0102:  RETLW  21
0103:  RETLW  21
0104:  RETLW  5E
0105:  RETLW  7F
0106:  RETLW  09
0107:  RETLW  09
0108:  RETLW  09
0109:  RETLW  76
010A:  BSF    0A.0
010B:  BCF    0A.1
010C:  BCF    0A.2
010D:  ADDWF  02,F
010E:  RETLW  26
010F:  RETLW  49
0110:  RETLW  49
0111:  RETLW  49
0112:  RETLW  32
0113:  RETLW  01
0114:  RETLW  01
0115:  RETLW  7F
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  3F
0119:  RETLW  40
011A:  RETLW  40
011B:  RETLW  40
011C:  RETLW  3F
011D:  RETLW  1F
011E:  RETLW  20
011F:  RETLW  40
0120:  RETLW  20
0121:  RETLW  1F
0122:  RETLW  7F
0123:  RETLW  20
0124:  RETLW  10
0125:  RETLW  20
0126:  RETLW  7F
0127:  RETLW  41
0128:  RETLW  22
0129:  RETLW  1C
012A:  RETLW  22
012B:  RETLW  41
012C:  RETLW  07
012D:  RETLW  08
012E:  RETLW  70
012F:  RETLW  08
0130:  RETLW  07
0131:  RETLW  61
0132:  RETLW  51
0133:  RETLW  49
0134:  RETLW  45
0135:  RETLW  43
0136:  RETLW  00
0137:  RETLW  7F
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  02
013C:  RETLW  04
013D:  RETLW  08
013E:  RETLW  10
013F:  RETLW  20
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  41
0143:  RETLW  7F
0144:  RETLW  00
0145:  RETLW  04
0146:  RETLW  02
0147:  RETLW  01
0148:  RETLW  02
0149:  RETLW  04
014A:  RETLW  40
014B:  RETLW  40
014C:  RETLW  40
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  00
0150:  RETLW  01
0151:  RETLW  02
0152:  RETLW  04
0153:  RETLW  00
0154:  RETLW  20
0155:  RETLW  54
0156:  RETLW  54
0157:  RETLW  54
0158:  RETLW  78
0159:  RETLW  7F
015A:  RETLW  44
015B:  RETLW  44
015C:  RETLW  44
015D:  RETLW  38
015E:  RETLW  38
015F:  RETLW  44
0160:  RETLW  44
0161:  RETLW  44
0162:  RETLW  44
0163:  RETLW  38
0164:  RETLW  44
0165:  RETLW  44
0166:  RETLW  44
0167:  RETLW  7F
0168:  RETLW  38
0169:  RETLW  54
016A:  RETLW  54
016B:  RETLW  54
016C:  RETLW  18
016D:  RETLW  04
016E:  RETLW  04
016F:  RETLW  7E
0170:  RETLW  05
0171:  RETLW  05
0172:  RETLW  08
0173:  RETLW  54
0174:  RETLW  54
0175:  RETLW  54
0176:  RETLW  3C
0177:  RETLW  7F
0178:  RETLW  08
0179:  RETLW  04
017A:  RETLW  04
017B:  RETLW  78
017C:  RETLW  00
017D:  RETLW  44
017E:  RETLW  7D
017F:  RETLW  40
0180:  RETLW  00
0181:  RETLW  20
0182:  RETLW  40
0183:  RETLW  44
0184:  RETLW  3D
0185:  RETLW  00
0186:  RETLW  7F
0187:  RETLW  10
0188:  RETLW  28
0189:  RETLW  44
018A:  RETLW  00
018B:  RETLW  00
018C:  RETLW  41
018D:  RETLW  7F
018E:  RETLW  40
018F:  RETLW  00
0190:  RETLW  7C
0191:  RETLW  04
0192:  RETLW  78
0193:  RETLW  04
0194:  RETLW  78
0195:  RETLW  7C
0196:  RETLW  08
0197:  RETLW  04
0198:  RETLW  04
0199:  RETLW  78
019A:  RETLW  38
019B:  RETLW  44
019C:  RETLW  44
019D:  RETLW  44
019E:  RETLW  38
019F:  RETLW  7C
01A0:  RETLW  14
01A1:  RETLW  14
01A2:  RETLW  14
01A3:  RETLW  08
01A4:  RETLW  08
01A5:  RETLW  14
01A6:  RETLW  14
01A7:  RETLW  14
01A8:  RETLW  7C
01A9:  RETLW  00
01AA:  RETLW  7C
01AB:  RETLW  08
01AC:  RETLW  04
01AD:  RETLW  04
01AE:  RETLW  48
01AF:  RETLW  54
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  20
01B3:  RETLW  04
01B4:  RETLW  04
01B5:  RETLW  3F
01B6:  RETLW  44
01B7:  RETLW  44
01B8:  RETLW  3C
01B9:  RETLW  40
01BA:  RETLW  40
01BB:  RETLW  20
01BC:  RETLW  7C
01BD:  RETLW  1C
01BE:  RETLW  20
01BF:  RETLW  40
01C0:  RETLW  20
01C1:  RETLW  1C
01C2:  RETLW  3C
01C3:  RETLW  40
01C4:  RETLW  30
01C5:  RETLW  40
01C6:  RETLW  3C
01C7:  RETLW  44
01C8:  RETLW  28
01C9:  RETLW  10
01CA:  RETLW  28
01CB:  RETLW  44
01CC:  RETLW  0C
01CD:  RETLW  50
01CE:  RETLW  50
01CF:  RETLW  50
01D0:  RETLW  3C
01D1:  RETLW  44
01D2:  RETLW  64
01D3:  RETLW  54
01D4:  RETLW  4C
01D5:  RETLW  44
01D6:  RETLW  00
01D7:  RETLW  08
01D8:  RETLW  36
01D9:  RETLW  41
01DA:  RETLW  41
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  7F
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  41
01E1:  RETLW  41
01E2:  RETLW  36
01E3:  RETLW  08
01E4:  RETLW  00
01E5:  RETLW  02
01E6:  RETLW  01
01E7:  RETLW  02
01E8:  RETLW  04
01E9:  RETLW  02
01EA:  BSF    0A.0
01EB:  BCF    0A.1
01EC:  BCF    0A.2
01ED:  ADDWF  02,F
01EE:  RETLW  3C
01EF:  RETLW  20
01F0:  RETLW  45
01F1:  RETLW  41
01F2:  RETLW  53
01F3:  RETLW  59
01F4:  RETLW  20
01F5:  RETLW  3E
01F6:  RETLW  00
01F7:  BSF    0A.0
01F8:  BCF    0A.1
01F9:  BCF    0A.2
01FA:  ADDLW  FE
01FB:  BTFSC  03.0
01FC:  INCF   0A,F
01FD:  MOVWF  02
01FE:  RETLW  3C
01FF:  RETLW  20
0200:  RETLW  4D
0201:  RETLW  45
0202:  RETLW  44
0203:  RETLW  49
0204:  RETLW  55
0205:  RETLW  4D
0206:  RETLW  20
0207:  RETLW  3E
0208:  RETLW  00
0209:  BCF    0A.0
020A:  BSF    0A.1
020B:  BCF    0A.2
020C:  ADDWF  02,F
020D:  RETLW  3C
020E:  RETLW  20
020F:  RETLW  48
0210:  RETLW  41
0211:  RETLW  52
0212:  RETLW  44
0213:  RETLW  20
0214:  RETLW  3E
0215:  RETLW  00
*
0248:  CLRF   77
0249:  CLRF   78
024A:  BSF    03.6
024B:  MOVF   6D,W
024C:  BCF    03.0
024D:  BTFSC  6E.0
024E:  ADDWF  77,F
024F:  RRF    77,F
0250:  RRF    78,F
0251:  BTFSC  6E.1
0252:  ADDWF  77,F
0253:  RRF    77,F
0254:  RRF    78,F
0255:  BTFSC  6E.2
0256:  ADDWF  77,F
0257:  RRF    77,F
0258:  RRF    78,F
0259:  BTFSC  6E.3
025A:  ADDWF  77,F
025B:  RRF    77,F
025C:  RRF    78,F
025D:  BTFSC  6E.4
025E:  ADDWF  77,F
025F:  RRF    77,F
0260:  RRF    78,F
0261:  BTFSC  6E.5
0262:  ADDWF  77,F
0263:  RRF    77,F
0264:  RRF    78,F
0265:  BTFSC  6E.6
0266:  ADDWF  77,F
0267:  RRF    77,F
0268:  RRF    78,F
0269:  BTFSC  6E.7
026A:  ADDWF  77,F
026B:  RRF    77,F
026C:  RRF    78,F
026D:  BCF    03.6
026E:  RETURN
*
036F:  MOVLW  10
0370:  BSF    03.6
0371:  MOVWF  4D
0372:  CLRF   77
0373:  CLRF   7A
0374:  RRF    4A,F
0375:  RRF    49,F
0376:  BTFSS  03.0
0377:  GOTO   37E
0378:  MOVF   4B,W
0379:  ADDWF  77,F
037A:  BTFSC  03.0
037B:  INCF   7A,F
037C:  MOVF   4C,W
037D:  ADDWF  7A,F
037E:  RRF    7A,F
037F:  RRF    77,F
0380:  RRF    79,F
0381:  RRF    78,F
0382:  DECFSZ 4D,F
0383:  GOTO   374
0384:  BCF    03.6
0385:  RETURN
0386:  CLRF   78
0387:  CLRF   79
0388:  CLRF   77
0389:  CLRF   7A
038A:  BSF    03.6
038B:  MOVF   4E,W
038C:  BTFSS  03.2
038D:  GOTO   391
038E:  MOVF   4D,W
038F:  BTFSC  03.2
0390:  GOTO   3AB
0391:  MOVLW  10
0392:  MOVWF  4F
0393:  BCF    03.0
0394:  RLF    4B,F
0395:  RLF    4C,F
0396:  RLF    77,F
0397:  RLF    7A,F
0398:  MOVF   4E,W
0399:  SUBWF  7A,W
039A:  BTFSS  03.2
039B:  GOTO   39E
039C:  MOVF   4D,W
039D:  SUBWF  77,W
039E:  BTFSS  03.0
039F:  GOTO   3A7
03A0:  MOVF   4D,W
03A1:  SUBWF  77,F
03A2:  BTFSS  03.0
03A3:  DECF   7A,F
03A4:  MOVF   4E,W
03A5:  SUBWF  7A,F
03A6:  BSF    03.0
03A7:  RLF    78,F
03A8:  RLF    79,F
03A9:  DECFSZ 4F,F
03AA:  GOTO   393
03AB:  BCF    03.6
03AC:  RETURN
*
07D7:  BSF    03.6
07D8:  MOVF   34,W
07D9:  CLRF   78
07DA:  SUBWF  33,W
07DB:  BTFSC  03.0
07DC:  GOTO   7E0
07DD:  MOVF   33,W
07DE:  MOVWF  77
07DF:  GOTO   7EC
07E0:  CLRF   77
07E1:  MOVLW  08
07E2:  MOVWF  35
07E3:  RLF    33,F
07E4:  RLF    77,F
07E5:  MOVF   34,W
07E6:  SUBWF  77,W
07E7:  BTFSC  03.0
07E8:  MOVWF  77
07E9:  RLF    78,F
07EA:  DECFSZ 35,F
07EB:  GOTO   7E3
07EC:  BCF    03.6
07ED:  RETURN
*
090F:  MOVLW  20
0910:  MOVWF  41
0911:  CLRF   3D
0912:  CLRF   3E
0913:  CLRF   3F
0914:  CLRF   40
0915:  MOVF   38,W
0916:  MOVWF  7A
0917:  MOVF   37,W
0918:  MOVWF  79
0919:  MOVF   36,W
091A:  MOVWF  78
091B:  MOVF   35,W
091C:  MOVWF  77
091D:  BCF    03.0
091E:  BTFSS  77.0
091F:  GOTO   12E
0920:  MOVF   39,W
0921:  ADDWF  3D,F
0922:  MOVF   3A,W
0923:  BTFSC  03.0
0924:  INCFSZ 3A,W
0925:  ADDWF  3E,F
0926:  MOVF   3B,W
0927:  BTFSC  03.0
0928:  INCFSZ 3B,W
0929:  ADDWF  3F,F
092A:  MOVF   3C,W
092B:  BTFSC  03.0
092C:  INCFSZ 3C,W
092D:  ADDWF  40,F
092E:  RRF    40,F
092F:  RRF    3F,F
0930:  RRF    3E,F
0931:  RRF    3D,F
0932:  RRF    7A,F
0933:  RRF    79,F
0934:  RRF    78,F
0935:  RRF    77,F
0936:  DECFSZ 41,F
0937:  GOTO   11D
*
0E3F:  BCF    0A.0
0E40:  BSF    0A.1
0E41:  BSF    0A.2
0E42:  ADDWF  02,F
0E43:  GOTO   466
0E44:  GOTO   472
0E45:  GOTO   47E
0E46:  GOTO   48B
....................  
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=16000000) 
*
035A:  MOVLW  49
035B:  MOVWF  04
035C:  BSF    03.7
035D:  MOVF   00,W
035E:  BTFSC  03.2
035F:  GOTO   36E
0360:  MOVLW  05
0361:  MOVWF  78
0362:  CLRF   77
0363:  DECFSZ 77,F
0364:  GOTO   363
0365:  DECFSZ 78,F
0366:  GOTO   362
0367:  MOVLW  2E
0368:  MOVWF  77
0369:  DECFSZ 77,F
036A:  GOTO   369
036B:  GOTO   36C
036C:  DECFSZ 00,F
036D:  GOTO   360
036E:  RETURN
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0B2E:  BCF    03.5
0B2F:  CLRF   20
0B30:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0663:  MOVF   5C,W
0664:  MOVWF  5E
0665:  MOVF   5B,W
0666:  MOVWF  5D
0667:  MOVF   5E,W
0668:  MOVWF  7A
0669:  MOVF   5D,W
066A:  MOVWF  04
066B:  BCF    03.7
066C:  BTFSC  7A.0
066D:  BSF    03.7
066E:  MOVF   00,F
066F:  BTFSC  03.2
0670:  GOTO   675
0671:  INCF   5D,F
0672:  BTFSC  03.2
0673:  INCF   5E,F
0674:  GOTO   667
....................    return(sc - s); 
0675:  MOVF   5B,W
0676:  SUBWF  5D,W
0677:  MOVWF  77
0678:  MOVF   5E,W
0679:  MOVWF  7A
067A:  MOVF   5C,W
067B:  BTFSS  03.0
067C:  INCFSZ 5C,W
067D:  SUBWF  7A,F
067E:  MOVF   77,W
067F:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
08F8:  MOVF   25,W
08F9:  BSF    03.6
08FA:  MOVWF  38
08FB:  BCF    03.6
08FC:  MOVF   24,W
08FD:  BSF    03.6
08FE:  MOVWF  37
08FF:  BCF    03.6
0900:  MOVF   23,W
0901:  BSF    03.6
0902:  MOVWF  36
0903:  BCF    03.6
0904:  MOVF   22,W
0905:  BSF    03.6
0906:  MOVWF  35
0907:  MOVLW  41
0908:  MOVWF  3C
0909:  MOVLW  C6
090A:  MOVWF  3B
090B:  MOVLW  4E
090C:  MOVWF  3A
090D:  MOVLW  6D
090E:  MOVWF  39
*
0938:  MOVF   7A,W
0939:  MOVWF  38
093A:  MOVF   79,W
093B:  MOVWF  37
093C:  MOVF   78,W
093D:  MOVWF  36
093E:  MOVF   77,W
093F:  MOVWF  35
0940:  MOVLW  39
0941:  ADDWF  35,W
0942:  BCF    03.6
0943:  MOVWF  22
0944:  BSF    03.6
0945:  MOVF   36,W
0946:  BCF    03.6
0947:  MOVWF  23
0948:  MOVLW  30
0949:  BTFSC  03.0
094A:  MOVLW  31
094B:  ADDWF  23,F
094C:  BSF    03.6
094D:  MOVF   37,W
094E:  BCF    03.6
094F:  MOVWF  24
0950:  MOVLW  00
0951:  BTFSC  03.0
0952:  MOVLW  01
0953:  ADDWF  24,F
0954:  BSF    03.6
0955:  MOVF   38,W
0956:  BCF    03.6
0957:  MOVWF  25
0958:  MOVLW  00
0959:  BTFSC  03.0
095A:  MOVLW  01
095B:  ADDWF  25,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
095C:  MOVF   24,W
095D:  MOVWF  77
095E:  MOVF   25,W
095F:  MOVWF  78
0960:  CLRF   79
0961:  CLRF   7A
0962:  MOVF   25,W
0963:  BSF    03.6
0964:  MOVWF  37
0965:  MOVF   77,W
0966:  MOVWF  36
0967:  MOVF   37,W
0968:  MOVWF  4C
0969:  MOVF   36,W
096A:  MOVWF  4B
096B:  MOVLW  7F
096C:  MOVWF  4E
096D:  MOVLW  FF
096E:  MOVWF  4D
096F:  BCF    0A.3
0970:  BCF    03.6
0971:  CALL   386
0972:  BSF    0A.3
0973:  MOVF   77,W
0974:  MOVWF  78
0975:  MOVF   7A,W
0976:  MOVWF  79
0977:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <glcd.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
02E0:  BCF    26.0
02E1:  MOVF   26,W
02E2:  BSF    03.5
02E3:  MOVWF  07
02E4:  BCF    03.5
02E5:  BSF    07.0
....................    output_low(GLCD_E); 
02E6:  BSF    03.5
02E7:  BCF    06.5
02E8:  BCF    03.5
02E9:  BCF    06.5
....................    output_low(GLCD_CS1); 
02EA:  BSF    03.5
02EB:  BCF    06.0
02EC:  BCF    03.5
02ED:  BCF    06.0
....................    output_low(GLCD_CS2); 
02EE:  BSF    03.5
02EF:  BCF    06.1
02F0:  BCF    03.5
02F1:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
02F2:  BSF    03.5
02F3:  BCF    06.2
02F4:  BCF    03.5
02F5:  BCF    06.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
02F6:  MOVLW  30
02F7:  BSF    03.5
02F8:  BSF    03.6
02F9:  MOVWF  13
02FA:  MOVLW  C0
02FB:  MOVWF  14
02FC:  BCF    03.5
02FD:  BCF    03.6
02FE:  CALL   216
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
02FF:  MOVLW  31
0300:  BSF    03.5
0301:  BSF    03.6
0302:  MOVWF  13
0303:  MOVLW  C0
0304:  MOVWF  14
0305:  BCF    03.5
0306:  BCF    03.6
0307:  CALL   216
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
0308:  MOVLW  30
0309:  BSF    03.5
030A:  BSF    03.6
030B:  MOVWF  13
030C:  MOVLW  40
030D:  MOVWF  14
030E:  BCF    03.5
030F:  BCF    03.6
0310:  CALL   216
....................    glcd_writeByte(GLCD_CS2, 0x40); 
0311:  MOVLW  31
0312:  BSF    03.5
0313:  BSF    03.6
0314:  MOVWF  13
0315:  MOVLW  40
0316:  MOVWF  14
0317:  BCF    03.5
0318:  BCF    03.6
0319:  CALL   216
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
031A:  MOVLW  30
031B:  BSF    03.5
031C:  BSF    03.6
031D:  MOVWF  13
031E:  MOVLW  B8
031F:  MOVWF  14
0320:  BCF    03.5
0321:  BCF    03.6
0322:  CALL   216
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
0323:  MOVLW  31
0324:  BSF    03.5
0325:  BSF    03.6
0326:  MOVWF  13
0327:  MOVLW  B8
0328:  MOVWF  14
0329:  BCF    03.5
032A:  BCF    03.6
032B:  CALL   216
....................    if(mode == ON) 
032C:  BSF    03.6
032D:  DECFSZ 33,W
032E:  GOTO   342
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
032F:  MOVLW  30
0330:  BSF    03.5
0331:  MOVWF  13
0332:  MOVLW  3F
0333:  MOVWF  14
0334:  BCF    03.5
0335:  BCF    03.6
0336:  CALL   216
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
0337:  MOVLW  31
0338:  BSF    03.5
0339:  BSF    03.6
033A:  MOVWF  13
033B:  MOVLW  3F
033C:  MOVWF  14
033D:  BCF    03.5
033E:  BCF    03.6
033F:  CALL   216
....................    } 
0340:  GOTO   353
0341:  BSF    03.6
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
0342:  MOVLW  30
0343:  BSF    03.5
0344:  MOVWF  13
0345:  MOVLW  3E
0346:  MOVWF  14
0347:  BCF    03.5
0348:  BCF    03.6
0349:  CALL   216
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
034A:  MOVLW  31
034B:  BSF    03.5
034C:  BSF    03.6
034D:  MOVWF  13
034E:  MOVLW  3E
034F:  MOVWF  14
0350:  BCF    03.5
0351:  BCF    03.6
0352:  CALL   216
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
0353:  BSF    03.6
0354:  CLRF   47
0355:  BCF    03.6
0356:  CALL   26F
0357:  BSF    0A.3
0358:  BCF    0A.4
0359:  GOTO   38B (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
*
03EA:  MOVLW  30
03EB:  BSF    03.5
03EC:  BSF    03.6
03ED:  MOVWF  11
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
03EE:  BCF    03.5
03EF:  MOVF   6D,W
03F0:  SUBLW  3F
03F1:  BTFSC  03.0
03F2:  GOTO   3F9
....................    { 
....................       x -= 64; 
03F3:  MOVLW  40
03F4:  SUBWF  6D,F
....................       chip = GLCD_CS2; 
03F5:  MOVLW  31
03F6:  BSF    03.5
03F7:  MOVWF  11
03F8:  BCF    03.5
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
03F9:  BSF    03.5
03FA:  BCF    03.6
03FB:  BCF    06.2
03FC:  BCF    03.5
03FD:  BCF    06.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
03FE:  BSF    03.6
03FF:  BCF    6D.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
0400:  BSF    6D.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
0401:  BSF    03.5
0402:  MOVF   11,W
0403:  MOVWF  13
0404:  BCF    03.5
0405:  MOVF   6D,W
0406:  BSF    03.5
0407:  MOVWF  14
0408:  BCF    03.5
0409:  BCF    03.6
040A:  CALL   216
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
040B:  BSF    03.6
040C:  RRF    6E,W
040D:  MOVWF  77
040E:  RRF    77,F
040F:  RRF    77,F
0410:  MOVLW  1F
0411:  ANDWF  77,F
0412:  MOVF   77,W
0413:  ANDLW  BF
0414:  IORLW  B8
0415:  BSF    03.5
0416:  MOVWF  12
0417:  MOVF   11,W
0418:  MOVWF  13
0419:  MOVF   12,W
041A:  MOVWF  14
041B:  BCF    03.5
041C:  BCF    03.6
041D:  CALL   216
....................    output_high(GLCD_DI);                                    // Set for data 
041E:  BSF    03.5
041F:  BCF    06.2
0420:  BCF    03.5
0421:  BSF    06.2
....................    data = glcd_readByte(chip); 
0422:  BSF    03.5
0423:  BSF    03.6
0424:  MOVF   11,W
0425:  MOVWF  12
*
046E:  MOVF   78,W
046F:  MOVWF  10
....................  
....................    if(color == ON) 
0470:  BCF    03.5
0471:  DECFSZ 6F,W
0472:  GOTO   485
....................       bit_set(data, y%8);        // Turn the pixel on 
0473:  MOVF   6E,W
0474:  ANDLW  07
0475:  BSF    03.5
0476:  MOVWF  12
0477:  MOVLW  01
0478:  MOVWF  77
0479:  MOVF   12,W
047A:  MOVWF  78
047B:  BTFSC  03.2
047C:  GOTO   481
047D:  BCF    03.0
047E:  RLF    77,F
047F:  DECFSZ 78,F
0480:  GOTO   47D
0481:  MOVF   77,W
0482:  IORWF  10,F
0483:  GOTO   496
0484:  BCF    03.5
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
0485:  MOVF   6E,W
0486:  ANDLW  07
0487:  BSF    03.5
0488:  MOVWF  12
0489:  MOVLW  01
048A:  MOVWF  77
048B:  MOVF   12,W
048C:  MOVWF  78
048D:  BTFSC  03.2
048E:  GOTO   493
048F:  BCF    03.0
0490:  RLF    77,F
0491:  DECFSZ 78,F
0492:  GOTO   48F
0493:  MOVF   77,W
0494:  XORLW  FF
0495:  ANDWF  10,F
....................    output_low(GLCD_DI);          // Set for instruction 
0496:  BCF    03.6
0497:  BCF    06.2
0498:  BCF    03.5
0499:  BCF    06.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
049A:  BSF    03.5
049B:  BSF    03.6
049C:  MOVF   11,W
049D:  MOVWF  13
049E:  BCF    03.5
049F:  MOVF   6D,W
04A0:  BSF    03.5
04A1:  MOVWF  14
04A2:  BCF    03.5
04A3:  BCF    03.6
04A4:  CALL   216
....................    output_high(GLCD_DI);         // Set for data 
04A5:  BSF    03.5
04A6:  BCF    06.2
04A7:  BCF    03.5
04A8:  BSF    06.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
04A9:  BSF    03.5
04AA:  BSF    03.6
04AB:  MOVF   11,W
04AC:  MOVWF  13
04AD:  MOVF   10,W
04AE:  MOVWF  14
04AF:  BCF    03.5
04B0:  BCF    03.6
04B1:  CALL   216
04B2:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
*
0800:  BSF    03.6
0801:  MOVF   37,W
0802:  SUBWF  39,W
0803:  MOVWF  45
0804:  MOVF   45,W
0805:  BTFSS  45.7
0806:  GOTO   009
0807:  MOVF   45,W
0808:  SUBLW  00
0809:  MOVWF  40
....................    dy = abs((signed int)(y2 - y1)); 
080A:  MOVF   38,W
080B:  SUBWF  3A,W
080C:  MOVWF  45
080D:  MOVF   45,W
080E:  BTFSS  45.7
080F:  GOTO   012
0810:  MOVF   45,W
0811:  SUBLW  00
0812:  MOVWF  41
....................    x = x1; 
0813:  MOVF   37,W
0814:  MOVWF  3C
....................    y = y1; 
0815:  MOVF   38,W
0816:  MOVWF  3D
....................  
....................    if(x1 > x2) 
0817:  MOVF   37,W
0818:  SUBWF  39,W
0819:  BTFSC  03.0
081A:  GOTO   01E
....................       addx = -1; 
081B:  MOVLW  FF
081C:  MOVWF  3E
081D:  GOTO   020
....................    else 
....................       addx = 1; 
081E:  MOVLW  01
081F:  MOVWF  3E
....................    if(y1 > y2) 
0820:  MOVF   38,W
0821:  SUBWF  3A,W
0822:  BTFSC  03.0
0823:  GOTO   027
....................       addy = -1; 
0824:  MOVLW  FF
0825:  MOVWF  3F
0826:  GOTO   029
....................    else 
....................       addy = 1; 
0827:  MOVLW  01
0828:  MOVWF  3F
....................  
....................    if(dx >= dy) 
0829:  MOVF   41,W
082A:  XORLW  80
082B:  MOVWF  77
082C:  MOVF   40,W
082D:  XORLW  80
082E:  SUBWF  77,W
082F:  BTFSC  03.2
0830:  GOTO   033
0831:  BTFSC  03.0
0832:  GOTO   095
....................    { 
....................       P = 2*dy - dx; 
0833:  MOVLW  02
0834:  MOVWF  6D
0835:  MOVF   41,W
0836:  MOVWF  6E
0837:  BCF    0A.3
0838:  BCF    03.6
0839:  CALL   248
083A:  BSF    0A.3
083B:  BSF    03.6
083C:  MOVF   40,W
083D:  SUBWF  78,W
083E:  CLRF   7A
083F:  MOVWF  77
0840:  BTFSC  77.7
0841:  DECF   7A,F
0842:  MOVWF  42
0843:  MOVF   7A,W
0844:  MOVWF  43
....................  
....................       for(i=0; i<=dx; ++i) 
0845:  CLRF   44
0846:  BTFSC  40.7
0847:  GOTO   094
0848:  MOVF   44,W
0849:  SUBWF  40,W
084A:  BTFSS  03.0
084B:  GOTO   094
....................       { 
....................          glcd_pixel(x, y, color); 
084C:  MOVF   3C,W
084D:  MOVWF  6D
084E:  MOVF   3D,W
084F:  MOVWF  6E
0850:  MOVF   3B,W
0851:  MOVWF  6F
0852:  BCF    0A.3
0853:  BCF    03.6
0854:  CALL   3EA
0855:  BSF    0A.3
....................  
....................          if(P < 0) 
0856:  BSF    03.6
0857:  BTFSS  43.7
0858:  GOTO   06F
....................          { 
....................             P += 2*dy; 
0859:  MOVLW  02
085A:  MOVWF  6D
085B:  MOVF   41,W
085C:  MOVWF  6E
085D:  BCF    0A.3
085E:  BCF    03.6
085F:  CALL   248
0860:  BSF    0A.3
0861:  MOVF   78,W
0862:  CLRF   7A
0863:  MOVWF  77
0864:  BTFSC  77.7
0865:  DECF   7A,F
0866:  BSF    03.6
0867:  ADDWF  42,F
0868:  MOVF   7A,W
0869:  BTFSC  03.0
086A:  INCFSZ 7A,W
086B:  ADDWF  43,F
....................             x += addx; 
086C:  MOVF   3E,W
086D:  ADDWF  3C,F
....................          } 
086E:  GOTO   092
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
086F:  MOVLW  02
0870:  MOVWF  6D
0871:  MOVF   41,W
0872:  MOVWF  6E
0873:  BCF    0A.3
0874:  BCF    03.6
0875:  CALL   248
0876:  BSF    0A.3
0877:  MOVF   78,W
0878:  BSF    03.6
0879:  MOVWF  45
087A:  MOVLW  02
087B:  MOVWF  6D
087C:  MOVF   40,W
087D:  MOVWF  6E
087E:  BCF    0A.3
087F:  BCF    03.6
0880:  CALL   248
0881:  BSF    0A.3
0882:  MOVF   78,W
0883:  BSF    03.6
0884:  SUBWF  45,W
0885:  CLRF   7A
0886:  MOVWF  77
0887:  BTFSC  77.7
0888:  DECF   7A,F
0889:  ADDWF  42,F
088A:  MOVF   7A,W
088B:  BTFSC  03.0
088C:  INCFSZ 7A,W
088D:  ADDWF  43,F
....................             x += addx; 
088E:  MOVF   3E,W
088F:  ADDWF  3C,F
....................             y += addy; 
0890:  MOVF   3F,W
0891:  ADDWF  3D,F
....................          } 
0892:  INCF   44,F
0893:  GOTO   046
....................       } 
....................    } 
0894:  GOTO   0F6
....................    else 
....................    { 
....................       P = 2*dx - dy; 
0895:  MOVLW  02
0896:  MOVWF  6D
0897:  MOVF   40,W
0898:  MOVWF  6E
0899:  BCF    0A.3
089A:  BCF    03.6
089B:  CALL   248
089C:  BSF    0A.3
089D:  BSF    03.6
089E:  MOVF   41,W
089F:  SUBWF  78,W
08A0:  CLRF   7A
08A1:  MOVWF  77
08A2:  BTFSC  77.7
08A3:  DECF   7A,F
08A4:  MOVWF  42
08A5:  MOVF   7A,W
08A6:  MOVWF  43
....................  
....................       for(i=0; i<=dy; ++i) 
08A7:  CLRF   44
08A8:  BTFSC  41.7
08A9:  GOTO   0F6
08AA:  MOVF   44,W
08AB:  SUBWF  41,W
08AC:  BTFSS  03.0
08AD:  GOTO   0F6
....................       { 
....................          glcd_pixel(x, y, color); 
08AE:  MOVF   3C,W
08AF:  MOVWF  6D
08B0:  MOVF   3D,W
08B1:  MOVWF  6E
08B2:  MOVF   3B,W
08B3:  MOVWF  6F
08B4:  BCF    0A.3
08B5:  BCF    03.6
08B6:  CALL   3EA
08B7:  BSF    0A.3
....................  
....................          if(P < 0) 
08B8:  BSF    03.6
08B9:  BTFSS  43.7
08BA:  GOTO   0D1
....................          { 
....................             P += 2*dx; 
08BB:  MOVLW  02
08BC:  MOVWF  6D
08BD:  MOVF   40,W
08BE:  MOVWF  6E
08BF:  BCF    0A.3
08C0:  BCF    03.6
08C1:  CALL   248
08C2:  BSF    0A.3
08C3:  MOVF   78,W
08C4:  CLRF   7A
08C5:  MOVWF  77
08C6:  BTFSC  77.7
08C7:  DECF   7A,F
08C8:  BSF    03.6
08C9:  ADDWF  42,F
08CA:  MOVF   7A,W
08CB:  BTFSC  03.0
08CC:  INCFSZ 7A,W
08CD:  ADDWF  43,F
....................             y += addy; 
08CE:  MOVF   3F,W
08CF:  ADDWF  3D,F
....................          } 
08D0:  GOTO   0F4
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
08D1:  MOVLW  02
08D2:  MOVWF  6D
08D3:  MOVF   40,W
08D4:  MOVWF  6E
08D5:  BCF    0A.3
08D6:  BCF    03.6
08D7:  CALL   248
08D8:  BSF    0A.3
08D9:  MOVF   78,W
08DA:  BSF    03.6
08DB:  MOVWF  45
08DC:  MOVLW  02
08DD:  MOVWF  6D
08DE:  MOVF   41,W
08DF:  MOVWF  6E
08E0:  BCF    0A.3
08E1:  BCF    03.6
08E2:  CALL   248
08E3:  BSF    0A.3
08E4:  MOVF   78,W
08E5:  BSF    03.6
08E6:  SUBWF  45,W
08E7:  CLRF   7A
08E8:  MOVWF  77
08E9:  BTFSC  77.7
08EA:  DECF   7A,F
08EB:  ADDWF  42,F
08EC:  MOVF   7A,W
08ED:  BTFSC  03.0
08EE:  INCFSZ 7A,W
08EF:  ADDWF  43,F
....................             x += addx; 
08F0:  MOVF   3E,W
08F1:  ADDWF  3C,F
....................             y += addy; 
08F2:  MOVF   3F,W
08F3:  ADDWF  3D,F
....................          } 
08F4:  INCF   44,F
08F5:  GOTO   0A8
....................       } 
....................    } 
08F6:  BCF    03.6
08F7:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
*
04B3:  BSF    03.6
04B4:  CLRF   61
04B5:  MOVF   61,W
04B6:  ADDWF  5D,W
04B7:  MOVWF  04
04B8:  BCF    03.7
04B9:  BTFSC  5E.0
04BA:  BSF    03.7
04BB:  MOVF   00,F
04BC:  BTFSC  03.2
04BD:  GOTO   588
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
04BE:  MOVF   61,W
04BF:  ADDWF  5D,W
04C0:  MOVWF  04
04C1:  BCF    03.7
04C2:  BTFSC  5E.0
04C3:  BSF    03.7
04C4:  MOVF   00,W
04C5:  SUBLW  52
04C6:  BTFSS  03.0
04C7:  GOTO   4EC
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
04C8:  MOVF   61,W
04C9:  ADDWF  5D,W
04CA:  MOVWF  04
04CB:  BCF    03.7
04CC:  BTFSC  5E.0
04CD:  BSF    03.7
04CE:  MOVLW  20
04CF:  SUBWF  00,W
04D0:  MOVWF  6C
04D1:  MOVWF  6D
04D2:  MOVLW  05
04D3:  MOVWF  6E
04D4:  BCF    03.6
04D5:  CALL   248
04D6:  MOVF   78,W
04D7:  BSF    03.6
04D8:  MOVWF  6B
04D9:  MOVWF  78
04DA:  MOVLW  05
04DB:  MOVWF  77
04DC:  MOVLW  66
04DD:  MOVWF  04
04DE:  BSF    03.7
04DF:  MOVF   78,W
04E0:  BCF    03.6
04E1:  CALL   004
04E2:  MOVWF  00
04E3:  INCF   78,F
04E4:  INCF   04,F
04E5:  DECFSZ 77,F
04E6:  GOTO   4E8
04E7:  GOTO   4EA
04E8:  BSF    03.6
04E9:  GOTO   4DF
04EA:  GOTO   520
04EB:  BSF    03.6
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
04EC:  MOVF   61,W
04ED:  ADDWF  5D,W
04EE:  MOVWF  04
04EF:  BCF    03.7
04F0:  BTFSC  5E.0
04F1:  BSF    03.7
04F2:  MOVF   00,W
04F3:  SUBLW  7E
04F4:  BTFSS  03.0
04F5:  GOTO   51A
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
04F6:  MOVF   61,W
04F7:  ADDWF  5D,W
04F8:  MOVWF  04
04F9:  BCF    03.7
04FA:  BTFSC  5E.0
04FB:  BSF    03.7
04FC:  MOVLW  53
04FD:  SUBWF  00,W
04FE:  MOVWF  6C
04FF:  MOVWF  6D
0500:  MOVLW  05
0501:  MOVWF  6E
0502:  BCF    03.6
0503:  CALL   248
0504:  MOVF   78,W
0505:  BSF    03.6
0506:  MOVWF  6B
0507:  MOVWF  78
0508:  MOVLW  05
0509:  MOVWF  77
050A:  MOVLW  66
050B:  MOVWF  04
050C:  BSF    03.7
050D:  MOVF   78,W
050E:  BCF    03.6
050F:  CALL   10A
0510:  MOVWF  00
0511:  INCF   78,F
0512:  INCF   04,F
0513:  DECFSZ 77,F
0514:  GOTO   516
0515:  GOTO   518
0516:  BSF    03.6
0517:  GOTO   50D
0518:  GOTO   520
0519:  BSF    03.6
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
051A:  CLRF   66
051B:  CLRF   67
051C:  CLRF   68
051D:  CLRF   69
051E:  CLRF   6A
051F:  BCF    03.6
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
0520:  MOVLW  05
0521:  BSF    03.6
0522:  MOVWF  6D
0523:  MOVF   5F,W
0524:  MOVWF  6E
0525:  BCF    03.6
0526:  CALL   248
0527:  MOVF   78,W
0528:  BSF    03.6
0529:  ADDWF  5B,W
052A:  SUBLW  7F
052B:  BTFSC  03.0
052C:  GOTO   538
....................       { 
....................          x = 0;                           // Set x at far left position 
052D:  CLRF   5B
....................          y += 7*size + 1;                 // Set y at next position down 
052E:  MOVLW  07
052F:  MOVWF  6D
0530:  MOVF   5F,W
0531:  MOVWF  6E
0532:  BCF    03.6
0533:  CALL   248
0534:  MOVLW  01
0535:  ADDWF  78,W
0536:  BSF    03.6
0537:  ADDWF  5C,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0538:  CLRF   62
0539:  MOVF   62,W
053A:  SUBLW  04
053B:  BTFSS  03.0
053C:  GOTO   585
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
053D:  CLRF   63
053E:  MOVLW  07
053F:  MOVWF  6D
0540:  MOVF   5F,W
0541:  MOVWF  6E
0542:  BCF    03.6
0543:  CALL   248
0544:  MOVF   78,W
0545:  BSF    03.6
0546:  SUBWF  63,W
0547:  BTFSC  03.0
0548:  GOTO   581
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
0549:  MOVLW  66
054A:  ADDWF  62,W
054B:  MOVWF  04
054C:  BSF    03.7
054D:  MOVF   00,W
054E:  MOVWF  6B
054F:  MOVWF  77
0550:  MOVF   63,W
0551:  MOVWF  78
0552:  BTFSC  03.2
0553:  GOTO   558
0554:  BCF    03.0
0555:  RRF    77,F
0556:  DECFSZ 78,F
0557:  GOTO   554
0558:  BTFSS  77.0
0559:  GOTO   57F
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
055A:  CLRF   64
055B:  MOVF   5F,W
055C:  SUBWF  64,W
055D:  BTFSC  03.0
055E:  GOTO   57F
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
055F:  CLRF   65
0560:  MOVF   5F,W
0561:  SUBWF  65,W
0562:  BTFSC  03.0
0563:  GOTO   57D
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
0564:  MOVF   65,W
0565:  ADDWF  5B,W
0566:  MOVWF  6B
0567:  MOVF   63,W
0568:  MOVWF  6D
0569:  MOVF   5F,W
056A:  MOVWF  6E
056B:  BCF    03.6
056C:  CALL   248
056D:  MOVF   78,W
056E:  BSF    03.6
056F:  ADDWF  5C,W
0570:  ADDWF  64,W
0571:  MOVWF  6C
0572:  MOVF   6B,W
0573:  MOVWF  6D
0574:  MOVF   6C,W
0575:  MOVWF  6E
0576:  MOVF   60,W
0577:  MOVWF  6F
0578:  BCF    03.6
0579:  CALL   3EA
057A:  BSF    03.6
057B:  INCF   65,F
057C:  GOTO   560
....................                   } 
057D:  INCF   64,F
057E:  GOTO   55B
....................                } 
....................             } 
057F:  INCF   63,F
0580:  GOTO   53E
....................          } 
0581:  INCF   62,F
0582:  MOVF   5F,W
0583:  ADDWF  5B,F
0584:  GOTO   539
....................       } 
0585:  INCF   61,F
0586:  INCF   5B,F
0587:  GOTO   4B5
....................    } 
0588:  BCF    03.6
0589:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
026F:  BSF    03.6
0270:  CLRF   48
0271:  MOVF   48,W
0272:  SUBLW  07
0273:  BTFSS  03.0
0274:  GOTO   2DE
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
0275:  BSF    03.5
0276:  BCF    03.6
0277:  BCF    06.2
0278:  BCF    03.5
0279:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
027A:  MOVLW  30
027B:  BSF    03.5
027C:  BSF    03.6
027D:  MOVWF  13
027E:  MOVLW  40
027F:  MOVWF  14
0280:  BCF    03.5
0281:  BCF    03.6
0282:  CALL   216
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
0283:  MOVLW  31
0284:  BSF    03.5
0285:  BSF    03.6
0286:  MOVWF  13
0287:  MOVLW  40
0288:  MOVWF  14
0289:  BCF    03.5
028A:  BCF    03.6
028B:  CALL   216
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
028C:  BSF    03.6
028D:  MOVF   48,W
028E:  IORLW  B8
028F:  MOVWF  4A
0290:  MOVLW  30
0291:  BSF    03.5
0292:  MOVWF  13
0293:  BCF    03.5
0294:  MOVF   4A,W
0295:  BSF    03.5
0296:  MOVWF  14
0297:  BCF    03.5
0298:  BCF    03.6
0299:  CALL   216
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
029A:  BSF    03.6
029B:  MOVF   48,W
029C:  IORLW  B8
029D:  MOVWF  4A
029E:  MOVLW  31
029F:  BSF    03.5
02A0:  MOVWF  13
02A1:  BCF    03.5
02A2:  MOVF   4A,W
02A3:  BSF    03.5
02A4:  MOVWF  14
02A5:  BCF    03.5
02A6:  BCF    03.6
02A7:  CALL   216
....................       output_high(GLCD_DI);                     // Set for data 
02A8:  BSF    03.5
02A9:  BCF    06.2
02AA:  BCF    03.5
02AB:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
02AC:  BSF    03.6
02AD:  CLRF   49
02AE:  MOVF   49,W
02AF:  SUBLW  3F
02B0:  BTFSS  03.0
02B1:  GOTO   2DC
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
02B2:  MOVLW  FF
02B3:  MOVWF  6D
02B4:  MOVF   47,W
02B5:  MOVWF  6E
02B6:  BCF    03.6
02B7:  CALL   248
02B8:  MOVF   78,W
02B9:  BSF    03.6
02BA:  MOVWF  4A
02BB:  MOVLW  30
02BC:  BSF    03.5
02BD:  MOVWF  13
02BE:  BCF    03.5
02BF:  MOVF   4A,W
02C0:  BSF    03.5
02C1:  MOVWF  14
02C2:  BCF    03.5
02C3:  BCF    03.6
02C4:  CALL   216
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
02C5:  MOVLW  FF
02C6:  BSF    03.6
02C7:  MOVWF  6D
02C8:  MOVF   47,W
02C9:  MOVWF  6E
02CA:  BCF    03.6
02CB:  CALL   248
02CC:  MOVF   78,W
02CD:  BSF    03.6
02CE:  MOVWF  4A
02CF:  MOVLW  31
02D0:  BSF    03.5
02D1:  MOVWF  13
02D2:  BCF    03.5
02D3:  MOVF   4A,W
02D4:  BSF    03.5
02D5:  MOVWF  14
02D6:  BCF    03.5
02D7:  BCF    03.6
02D8:  CALL   216
02D9:  BSF    03.6
02DA:  INCF   49,F
02DB:  GOTO   2AE
....................       } 
02DC:  INCF   48,F
02DD:  GOTO   271
....................    } 
02DE:  BCF    03.6
02DF:  RETURN
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
0216:  BSF    03.5
0217:  BSF    03.6
0218:  MOVF   13,W
0219:  SUBLW  30
021A:  BTFSS  03.2
021B:  GOTO   223
....................       output_high(GLCD_CS1); 
021C:  BCF    03.6
021D:  BCF    06.0
021E:  BCF    03.5
021F:  BSF    06.0
0220:  GOTO   227
0221:  BSF    03.5
0222:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS2); 
0223:  BCF    03.6
0224:  BCF    06.1
0225:  BCF    03.5
0226:  BSF    06.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
0227:  BSF    03.5
0228:  BCF    06.4
0229:  BCF    03.5
022A:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
022B:  BSF    03.5
022C:  CLRF   08
022D:  BSF    03.6
022E:  MOVF   14,W
022F:  BCF    03.5
0230:  BCF    03.6
0231:  MOVWF  08
....................    output_high(GLCD_E);       // Pulse the enable pin 
0232:  BSF    03.5
0233:  BCF    06.5
0234:  BCF    03.5
0235:  BSF    06.5
....................    delay_us(2); 
0236:  MOVLW  02
0237:  MOVWF  77
0238:  DECFSZ 77,F
0239:  GOTO   238
023A:  NOP
....................    output_low(GLCD_E); 
023B:  BSF    03.5
023C:  BCF    06.5
023D:  BCF    03.5
023E:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
023F:  BSF    03.5
0240:  BCF    06.0
0241:  BCF    03.5
0242:  BCF    06.0
....................    output_low(GLCD_CS2); 
0243:  BSF    03.5
0244:  BCF    06.1
0245:  BCF    03.5
0246:  BCF    06.1
0247:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
0426:  MOVF   12,W
0427:  SUBLW  30
0428:  BTFSS  03.2
0429:  GOTO   431
....................       output_high(GLCD_CS1); 
042A:  BCF    03.6
042B:  BCF    06.0
042C:  BCF    03.5
042D:  BSF    06.0
042E:  GOTO   435
042F:  BSF    03.5
0430:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS2); 
0431:  BCF    03.6
0432:  BCF    06.1
0433:  BCF    03.5
0434:  BSF    06.1
....................  
....................    input_d();                 // Set port d to input 
0435:  MOVLW  FF
0436:  BSF    03.5
0437:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
0438:  BCF    06.4
0439:  BCF    03.5
043A:  BSF    06.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
043B:  BSF    03.5
043C:  BCF    06.5
043D:  BCF    03.5
043E:  BSF    06.5
....................    delay_us(2); 
043F:  MOVLW  02
0440:  MOVWF  77
0441:  DECFSZ 77,F
0442:  GOTO   441
0443:  NOP
....................    output_low(GLCD_E); 
0444:  BSF    03.5
0445:  BCF    06.5
0446:  BCF    03.5
0447:  BCF    06.5
....................    delay_us(2); 
0448:  MOVLW  02
0449:  MOVWF  77
044A:  DECFSZ 77,F
044B:  GOTO   44A
044C:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
044D:  BSF    03.5
044E:  BCF    06.5
044F:  BCF    03.5
0450:  BSF    06.5
....................    delay_us(2); 
0451:  MOVLW  02
0452:  MOVWF  77
0453:  DECFSZ 77,F
0454:  GOTO   453
0455:  NOP
....................    data = input_d();          // Get the data from the display's output register 
0456:  MOVLW  FF
0457:  BSF    03.5
0458:  MOVWF  08
0459:  BCF    03.5
045A:  MOVF   08,W
045B:  BSF    03.5
045C:  BSF    03.6
045D:  MOVWF  13
....................    output_low(GLCD_E); 
045E:  BCF    03.6
045F:  BCF    06.5
0460:  BCF    03.5
0461:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0462:  BSF    03.5
0463:  BCF    06.0
0464:  BCF    03.5
0465:  BCF    06.0
....................    output_low(GLCD_CS2); 
0466:  BSF    03.5
0467:  BCF    06.1
0468:  BCF    03.5
0469:  BCF    06.1
....................    return data;               // Return the read data 
046A:  BSF    03.5
046B:  BSF    03.6
046C:  MOVF   13,W
046D:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define uchar unsigned char 
....................  
.................... #define GRID_SIZE     6 
.................... #define GRID_COLS     10 
.................... #define GRID_ROWS     10 
.................... #define GRID_ORIGIN_X 0 
.................... #define GRID_ORIGIN_Y 0 
.................... #define BUZZER_PIN PIN_B3 
....................  
.................... // buzzer part 
.................... void buzzer_beep(int duration_ms) { 
*
03AD:  BSF    03.6
03AE:  CLRF   4A
03AF:  MOVF   46,W
03B0:  MOVWF  49
03B1:  MOVLW  03
03B2:  MOVWF  4C
03B3:  MOVLW  E8
03B4:  MOVWF  4B
03B5:  BCF    03.6
03B6:  CALL   36F
03B7:  MOVF   79,W
03B8:  BSF    03.6
03B9:  MOVWF  4A
03BA:  MOVF   78,W
03BB:  MOVWF  49
03BC:  MOVF   4A,W
03BD:  MOVWF  4C
03BE:  MOVF   49,W
03BF:  MOVWF  4B
03C0:  MOVLW  07
03C1:  MOVWF  4E
03C2:  MOVLW  D0
03C3:  MOVWF  4D
03C4:  BCF    03.6
03C5:  CALL   386
03C6:  MOVF   78,W
03C7:  BSF    03.6
03C8:  MOVWF  47
....................    int cycles = duration_ms * 1000L / 2000; 
....................    for (int i = 0; i < cycles; i++) { 
03C9:  CLRF   48
03CA:  MOVF   47,W
03CB:  SUBWF  48,W
03CC:  BTFSC  03.0
03CD:  GOTO   3E4
....................       output_low(BUZZER_PIN);    // 0 --> sound on 
03CE:  BSF    03.5
03CF:  BCF    03.6
03D0:  BCF    06.3
03D1:  BCF    03.5
03D2:  BCF    06.3
....................       delay_us(1000); 
03D3:  MOVLW  01
03D4:  BSF    03.6
03D5:  MOVWF  49
03D6:  BCF    03.6
03D7:  CALL   35A
....................       output_high(BUZZER_PIN);   // 1 --> sound off 
03D8:  BSF    03.5
03D9:  BCF    06.3
03DA:  BCF    03.5
03DB:  BSF    06.3
....................       delay_us(1000); 
03DC:  MOVLW  01
03DD:  BSF    03.6
03DE:  MOVWF  49
03DF:  BCF    03.6
03E0:  CALL   35A
03E1:  BSF    03.6
03E2:  INCF   48,F
03E3:  GOTO   3CA
....................    } 
....................    output_high(BUZZER_PIN); 
03E4:  BSF    03.5
03E5:  BCF    03.6
03E6:  BCF    06.3
03E7:  BCF    03.5
03E8:  BSF    06.3
03E9:  RETURN
.................... } 
....................  
.................... void short_beep() { 
....................    buzzer_beep(100); 
*
069C:  MOVLW  64
069D:  BSF    03.6
069E:  MOVWF  46
069F:  BCF    03.6
06A0:  CALL   3AD
06A1:  RETURN
.................... } 
....................  
.................... void error_beep() { 
....................    buzzer_beep(1000); 
*
0A36:  MOVLW  E8
0A37:  BSF    03.6
0A38:  MOVWF  46
0A39:  BCF    0A.3
0A3A:  BCF    03.6
0A3B:  CALL   3AD
0A3C:  BSF    0A.3
....................    delay_ms(200);  
0A3D:  MOVLW  C8
0A3E:  BSF    03.6
0A3F:  MOVWF  49
0A40:  BCF    0A.3
0A41:  BCF    03.6
0A42:  CALL   35A
0A43:  BSF    0A.3
....................    buzzer_beep(1000); 
0A44:  MOVLW  E8
0A45:  BSF    03.6
0A46:  MOVWF  46
0A47:  BCF    0A.3
0A48:  BCF    03.6
0A49:  CALL   3AD
0A4A:  BSF    0A.3
....................    delay_ms(200);  
0A4B:  MOVLW  C8
0A4C:  BSF    03.6
0A4D:  MOVWF  49
0A4E:  BCF    0A.3
0A4F:  BCF    03.6
0A50:  CALL   35A
0A51:  BSF    0A.3
....................    buzzer_beep(700); 
0A52:  MOVLW  BC
0A53:  BSF    03.6
0A54:  MOVWF  46
0A55:  BCF    0A.3
0A56:  BCF    03.6
0A57:  CALL   3AD
0A58:  BSF    0A.3
....................    delay_ms(200);       
0A59:  MOVLW  C8
0A5A:  BSF    03.6
0A5B:  MOVWF  49
0A5C:  BCF    0A.3
0A5D:  BCF    03.6
0A5E:  CALL   35A
0A5F:  BSF    0A.3
.................... } 
....................  
.................... void win_melody() { 
....................    int notes[] = {200, 100, 100, 400, 200, 150, 600, 300}; 
*
0A9D:  MOVLW  C8
0A9E:  BSF    03.6
0A9F:  MOVWF  33
0AA0:  MOVLW  64
0AA1:  MOVWF  34
0AA2:  MOVWF  35
0AA3:  MOVLW  90
0AA4:  MOVWF  36
0AA5:  MOVLW  C8
0AA6:  MOVWF  37
0AA7:  MOVLW  96
0AA8:  MOVWF  38
0AA9:  MOVLW  58
0AAA:  MOVWF  39
0AAB:  MOVLW  2C
0AAC:  MOVWF  3A
....................    int gaps[]  = {50, 50, 100, 150, 100, 100, 150, 0}; 
0AAD:  MOVLW  32
0AAE:  MOVWF  3B
0AAF:  MOVWF  3C
0AB0:  MOVLW  64
0AB1:  MOVWF  3D
0AB2:  MOVLW  96
0AB3:  MOVWF  3E
0AB4:  MOVLW  64
0AB5:  MOVWF  3F
0AB6:  MOVWF  40
0AB7:  MOVLW  96
0AB8:  MOVWF  41
0AB9:  CLRF   42
....................  
....................    for (int i = 0; i < 8; i++) { 
0ABA:  CLRF   43
0ABB:  MOVF   43,W
0ABC:  SUBLW  07
0ABD:  BTFSS  03.0
0ABE:  GOTO   2D9
....................       buzzer_beep(notes[i]); 
0ABF:  MOVLW  33
0AC0:  ADDWF  43,W
0AC1:  MOVWF  04
0AC2:  BSF    03.7
0AC3:  MOVF   00,W
0AC4:  MOVWF  44
0AC5:  MOVWF  46
0AC6:  BCF    0A.3
0AC7:  BCF    03.6
0AC8:  CALL   3AD
0AC9:  BSF    0A.3
....................       delay_ms(gaps[i]); 
0ACA:  MOVLW  3B
0ACB:  BSF    03.6
0ACC:  ADDWF  43,W
0ACD:  MOVWF  04
0ACE:  BSF    03.7
0ACF:  MOVF   00,W
0AD0:  MOVWF  44
0AD1:  MOVWF  49
0AD2:  BCF    0A.3
0AD3:  BCF    03.6
0AD4:  CALL   35A
0AD5:  BSF    0A.3
0AD6:  BSF    03.6
0AD7:  INCF   43,F
0AD8:  GOTO   2BB
....................    } 
.................... } 
....................  
.................... uchar snakeX[32]; 
.................... uchar snakeY[32]; 
.................... uchar snakeX2[32]; 
.................... uchar snakeY2[32]; 
....................  
.................... #define getX(i) ((i < 32) ? snakeX[i] : snakeX2[(i)-32]) 
.................... #define getY(i) ((i < 32) ? snakeY[i] : snakeY2[(i)-32]) 
.................... #define setX(i,val) ((i < 32) ? (snakeX[i]=(val)) : (snakeX2[(i)-32]=(val))) 
.................... #define setY(i,val) ((i < 32) ? (snakeY[i]=(val)) : (snakeY2[(i)-32]=(val))) 
....................  
.................... uchar dir = 2; 
.................... uchar food[2], LENGTH_SNAKE = 5; 
.................... uchar posX = 0, posY = 2; 
.................... uchar score = 0; 
.................... uchar best_score = 0; 
.................... char score_txt[11] = "Score: 00"; 
*
0B31:  MOVLW  53
0B32:  BSF    03.5
0B33:  MOVWF  60
0B34:  MOVLW  63
0B35:  MOVWF  61
0B36:  MOVLW  6F
0B37:  MOVWF  62
0B38:  MOVLW  72
0B39:  MOVWF  63
0B3A:  MOVLW  65
0B3B:  MOVWF  64
0B3C:  MOVLW  3A
0B3D:  MOVWF  65
0B3E:  MOVLW  20
0B3F:  MOVWF  66
0B40:  MOVLW  30
0B41:  MOVWF  67
0B42:  MOVWF  68
0B43:  CLRF   69
.................... char best_score_txt[10] = "Best: 00"; 
0B44:  MOVLW  42
0B45:  BCF    03.5
0B46:  BSF    03.6
0B47:  MOVWF  10
0B48:  MOVLW  65
0B49:  MOVWF  11
0B4A:  MOVLW  73
0B4B:  MOVWF  12
0B4C:  MOVLW  74
0B4D:  MOVWF  13
0B4E:  MOVLW  3A
0B4F:  MOVWF  14
0B50:  MOVLW  20
0B51:  MOVWF  15
0B52:  MOVLW  30
0B53:  MOVWF  16
0B54:  MOVWF  17
0B55:  CLRF   18
.................... char gameover_msg[14] = "GAMEOVER !!!"; 
0B56:  MOVLW  47
0B57:  MOVWF  1A
0B58:  MOVLW  41
0B59:  MOVWF  1B
0B5A:  MOVLW  4D
0B5B:  MOVWF  1C
0B5C:  MOVLW  45
0B5D:  MOVWF  1D
0B5E:  MOVLW  4F
0B5F:  MOVWF  1E
0B60:  MOVLW  56
0B61:  MOVWF  1F
0B62:  MOVLW  45
0B63:  MOVWF  20
0B64:  MOVLW  52
0B65:  MOVWF  21
0B66:  MOVLW  20
0B67:  MOVWF  22
0B68:  MOVLW  21
0B69:  MOVWF  23
0B6A:  MOVWF  24
0B6B:  MOVWF  25
0B6C:  CLRF   26
.................... char win_msg[] = "YOU WON!"; 
0B6D:  MOVLW  59
0B6E:  MOVWF  28
0B6F:  MOVLW  4F
0B70:  MOVWF  29
0B71:  MOVLW  55
0B72:  MOVWF  2A
0B73:  MOVLW  20
0B74:  MOVWF  2B
0B75:  MOVLW  57
0B76:  MOVWF  2C
0B77:  MOVLW  4F
0B78:  MOVWF  2D
0B79:  MOVLW  4E
0B7A:  MOVWF  2E
0B7B:  MOVLW  21
0B7C:  MOVWF  2F
0B7D:  CLRF   30
.................... uchar i; 
....................  
.................... int1 isFirstStart = 1; 
.................... uchar difficulty_index = 0; 
....................  
.................... struct { 
....................    unsigned delay_time : 2; 
.................... } gameSettings; 
....................  
.................... // glcd part 
.................... void fillCell(signed int gx, signed int gy, int1 color) { 
....................    if (gx < 0 || gx >= GRID_COLS || gy < 0 || gy >= GRID_ROWS) return; 
*
0978:  BSF    03.6
0979:  BTFSC  35.7
097A:  GOTO   188
097B:  BTFSC  35.7
097C:  GOTO   181
097D:  MOVF   35,W
097E:  SUBLW  09
097F:  BTFSS  03.0
0980:  GOTO   188
0981:  BTFSC  36.7
0982:  GOTO   188
0983:  BTFSC  36.7
0984:  GOTO   189
0985:  MOVF   36,W
0986:  SUBLW  09
0987:  BTFSS  03.0
0988:  GOTO   1C0
....................    uchar px = GRID_ORIGIN_X + gx * GRID_SIZE + 1; 
....................    uchar py = GRID_ORIGIN_Y + gy * GRID_SIZE + 1; 
0989:  MOVF   35,W
098A:  MOVWF  6D
098B:  MOVLW  06
098C:  MOVWF  6E
098D:  BCF    0A.3
098E:  BCF    03.6
098F:  CALL   248
0990:  BSF    0A.3
0991:  MOVLW  01
0992:  ADDWF  78,W
0993:  BSF    03.6
0994:  MOVWF  38
0995:  MOVF   36,W
0996:  MOVWF  6D
0997:  MOVLW  06
0998:  MOVWF  6E
0999:  BCF    0A.3
099A:  BCF    03.6
099B:  CALL   248
099C:  BSF    0A.3
099D:  MOVLW  01
099E:  ADDWF  78,W
099F:  BSF    03.6
09A0:  MOVWF  39
....................    for (uchar dx = 0; dx < GRID_SIZE - 1; dx++) 
09A1:  CLRF   3A
09A2:  MOVF   3A,W
09A3:  SUBLW  04
09A4:  BTFSS  03.0
09A5:  GOTO   1C0
....................       for (uchar dy = 0; dy < GRID_SIZE - 1; dy++) 
09A6:  CLRF   3B
09A7:  MOVF   3B,W
09A8:  SUBLW  04
09A9:  BTFSS  03.0
09AA:  GOTO   1BE
....................          glcd_pixel(px + dx, py + dy, color); 
09AB:  MOVF   3A,W
09AC:  ADDWF  38,W
09AD:  MOVWF  3C
09AE:  MOVF   3B,W
09AF:  ADDWF  39,W
09B0:  MOVWF  3D
09B1:  MOVF   3C,W
09B2:  MOVWF  6D
09B3:  MOVF   3D,W
09B4:  MOVWF  6E
09B5:  MOVF   37,W
09B6:  MOVWF  6F
09B7:  BCF    0A.3
09B8:  BCF    03.6
09B9:  CALL   3EA
09BA:  BSF    0A.3
09BB:  BSF    03.6
09BC:  INCF   3B,F
09BD:  GOTO   1A7
09BE:  INCF   3A,F
09BF:  GOTO   1A2
09C0:  BCF    03.6
09C1:  RETURN
.................... } 
....................  
.................... void screenWipeDown() { 
....................    for (uchar y = 0; y < 64; y++) { 
*
05DD:  BSF    03.6
05DE:  CLRF   33
05DF:  MOVF   33,W
05E0:  SUBLW  3F
05E1:  BTFSS  03.0
05E2:  GOTO   5FA
....................       for (uchar x = 0; x < 128; x++) { 
05E3:  CLRF   34
05E4:  MOVF   34,W
05E5:  SUBLW  7F
05E6:  BTFSS  03.0
05E7:  GOTO   5F3
....................          glcd_pixel(x, y, 1); 
05E8:  MOVF   34,W
05E9:  MOVWF  6D
05EA:  MOVF   33,W
05EB:  MOVWF  6E
05EC:  MOVLW  01
05ED:  MOVWF  6F
05EE:  BCF    03.6
05EF:  CALL   3EA
05F0:  BSF    03.6
05F1:  INCF   34,F
05F2:  GOTO   5E4
....................       } 
....................       delay_ms(5); 
05F3:  MOVLW  05
05F4:  MOVWF  49
05F5:  BCF    03.6
05F6:  CALL   35A
05F7:  BSF    03.6
05F8:  INCF   33,F
05F9:  GOTO   5DF
....................    } 
05FA:  BCF    03.6
05FB:  RETURN
.................... } 
....................  
.................... void drawGrid() { 
....................    for (uchar c = 0; c <= GRID_COLS; c++) { 
*
0766:  BSF    03.6
0767:  CLRF   33
0768:  MOVF   33,W
0769:  SUBLW  0A
076A:  BTFSS  03.0
076B:  GOTO   785
....................       uchar x = GRID_ORIGIN_X + c * GRID_SIZE; 
076C:  MOVF   33,W
076D:  MOVWF  6D
076E:  MOVLW  06
076F:  MOVWF  6E
0770:  BCF    03.6
0771:  CALL   248
0772:  MOVF   78,W
0773:  BSF    03.6
0774:  MOVWF  34
....................       glcd_line(x, GRID_ORIGIN_Y, x, GRID_ORIGIN_Y + GRID_ROWS * GRID_SIZE, 1); 
0775:  MOVF   34,W
0776:  MOVWF  37
0777:  CLRF   38
0778:  MOVF   34,W
0779:  MOVWF  39
077A:  MOVLW  3C
077B:  MOVWF  3A
077C:  MOVLW  01
077D:  MOVWF  3B
077E:  BSF    0A.3
077F:  BCF    03.6
0780:  CALL   000
0781:  BCF    0A.3
0782:  BSF    03.6
0783:  INCF   33,F
0784:  GOTO   768
....................    } 
....................    for (uchar r = 0; r <= GRID_ROWS; r++) { 
0785:  CLRF   35
0786:  MOVF   35,W
0787:  SUBLW  0A
0788:  BTFSS  03.0
0789:  GOTO   7A3
....................       uchar y = GRID_ORIGIN_Y + r * GRID_SIZE; 
078A:  MOVF   35,W
078B:  MOVWF  6D
078C:  MOVLW  06
078D:  MOVWF  6E
078E:  BCF    03.6
078F:  CALL   248
0790:  MOVF   78,W
0791:  BSF    03.6
0792:  MOVWF  36
....................       glcd_line(GRID_ORIGIN_X, y, GRID_ORIGIN_X + GRID_COLS * GRID_SIZE, y, 1); 
0793:  CLRF   37
0794:  MOVF   36,W
0795:  MOVWF  38
0796:  MOVLW  3C
0797:  MOVWF  39
0798:  MOVF   36,W
0799:  MOVWF  3A
079A:  MOVLW  01
079B:  MOVWF  3B
079C:  BSF    0A.3
079D:  BCF    03.6
079E:  CALL   000
079F:  BCF    0A.3
07A0:  BSF    03.6
07A1:  INCF   35,F
07A2:  GOTO   786
....................    } 
07A3:  BCF    03.6
07A4:  RETURN
.................... } 
....................  
.................... void clearScoreArea() { 
....................    for (uchar x = 65; x < 125; x++) { 
07A5:  MOVLW  41
07A6:  BSF    03.6
07A7:  MOVWF  33
07A8:  MOVF   33,W
07A9:  SUBLW  7C
07AA:  BTFSS  03.0
07AB:  GOTO   7BD
....................       for (uchar y = 0; y < 20; y++) { 
07AC:  CLRF   34
07AD:  MOVF   34,W
07AE:  SUBLW  13
07AF:  BTFSS  03.0
07B0:  GOTO   7BB
....................          glcd_pixel(x, y, 0); 
07B1:  MOVF   33,W
07B2:  MOVWF  6D
07B3:  MOVF   34,W
07B4:  MOVWF  6E
07B5:  CLRF   6F
07B6:  BCF    03.6
07B7:  CALL   3EA
07B8:  BSF    03.6
07B9:  INCF   34,F
07BA:  GOTO   7AD
....................       } 
07BB:  INCF   33,F
07BC:  GOTO   7A8
....................    } 
.................... } 
....................  
.................... void writeScore() { 
....................    clearScoreArea(); 
....................    glcd_text57(65, 0, score_txt, 1, 1); 
07BD:  MOVLW  41
07BE:  MOVWF  5B
07BF:  CLRF   5C
07C0:  CLRF   5E
07C1:  MOVLW  E0
07C2:  MOVWF  5D
07C3:  MOVLW  01
07C4:  MOVWF  5F
07C5:  MOVWF  60
07C6:  BCF    03.6
07C7:  CALL   4B3
....................    glcd_text57(65, 10, best_score_txt, 1, 1); 
07C8:  MOVLW  41
07C9:  BSF    03.6
07CA:  MOVWF  5B
07CB:  MOVLW  0A
07CC:  MOVWF  5C
07CD:  MOVLW  01
07CE:  MOVWF  5E
07CF:  MOVLW  10
07D0:  MOVWF  5D
07D1:  MOVLW  01
07D2:  MOVWF  5F
07D3:  MOVWF  60
07D4:  BCF    03.6
07D5:  CALL   4B3
07D6:  RETURN
.................... } 
....................  
.................... void criar_comida() { 
*
09C2:  BSF    03.6
09C3:  CLRF   33
....................    uchar valid = 0; 
....................    while (!valid) { 
09C4:  MOVF   33,F
09C5:  BTFSS  03.2
09C6:  GOTO   229
....................       food[0] = rand() % GRID_COLS; 
09C7:  BCF    03.6
09C8:  CALL   0F8
09C9:  MOVF   79,W
09CA:  BSF    03.6
09CB:  MOVWF  36
09CC:  MOVF   78,W
09CD:  MOVWF  35
09CE:  MOVF   36,W
09CF:  MOVWF  4C
09D0:  MOVF   35,W
09D1:  MOVWF  4B
09D2:  CLRF   4E
09D3:  MOVLW  0A
09D4:  MOVWF  4D
09D5:  BCF    0A.3
09D6:  BCF    03.6
09D7:  CALL   386
09D8:  BSF    0A.3
09D9:  MOVF   77,W
09DA:  MOVWF  68
....................       food[1] = rand() % GRID_ROWS; 
09DB:  CALL   0F8
09DC:  MOVF   79,W
09DD:  BSF    03.6
09DE:  MOVWF  36
09DF:  MOVF   78,W
09E0:  MOVWF  35
09E1:  MOVF   36,W
09E2:  MOVWF  4C
09E3:  MOVF   35,W
09E4:  MOVWF  4B
09E5:  CLRF   4E
09E6:  MOVLW  0A
09E7:  MOVWF  4D
09E8:  BCF    0A.3
09E9:  BCF    03.6
09EA:  CALL   386
09EB:  BSF    0A.3
09EC:  MOVF   77,W
09ED:  MOVWF  69
....................       valid = 1; 
09EE:  MOVLW  01
09EF:  BSF    03.6
09F0:  MOVWF  33
....................       for (uchar j = 0; j < LENGTH_SNAKE; j++) { 
09F1:  CLRF   34
09F2:  BCF    03.6
09F3:  MOVF   6A,W
09F4:  BSF    03.6
09F5:  SUBWF  34,W
09F6:  BTFSC  03.0
09F7:  GOTO   228
....................          if (getX(j) == food[0] && getY(j) == food[1]) { 
09F8:  MOVF   34,W
09F9:  SUBLW  1F
09FA:  BTFSS  03.0
09FB:  GOTO   202
09FC:  MOVLW  27
09FD:  ADDWF  34,W
09FE:  MOVWF  04
09FF:  BCF    03.7
0A00:  MOVF   00,W
0A01:  GOTO   208
0A02:  MOVLW  20
0A03:  SUBWF  34,W
0A04:  ADDLW  A0
0A05:  MOVWF  04
0A06:  BCF    03.7
0A07:  MOVF   00,W
0A08:  BCF    03.6
0A09:  SUBWF  68,W
0A0A:  BTFSS  03.2
0A0B:  GOTO   225
0A0C:  BSF    03.6
0A0D:  MOVF   34,W
0A0E:  SUBLW  1F
0A0F:  BTFSS  03.0
0A10:  GOTO   217
0A11:  MOVLW  47
0A12:  ADDWF  34,W
0A13:  MOVWF  04
0A14:  BCF    03.7
0A15:  MOVF   00,W
0A16:  GOTO   21D
0A17:  MOVLW  20
0A18:  SUBWF  34,W
0A19:  ADDLW  C0
0A1A:  MOVWF  04
0A1B:  BCF    03.7
0A1C:  MOVF   00,W
0A1D:  BCF    03.6
0A1E:  SUBWF  69,W
0A1F:  BTFSS  03.2
0A20:  GOTO   225
....................             valid = 0; 
0A21:  BSF    03.6
0A22:  CLRF   33
....................             break; 
0A23:  GOTO   228
0A24:  BCF    03.6
....................          } 
0A25:  BSF    03.6
0A26:  INCF   34,F
0A27:  GOTO   1F2
....................       } 
0A28:  GOTO   1C4
....................    } 
....................    fillCell(food[0], food[1], 1); 
0A29:  BCF    03.6
0A2A:  MOVF   68,W
0A2B:  BSF    03.6
0A2C:  MOVWF  35
0A2D:  BCF    03.6
0A2E:  MOVF   69,W
0A2F:  BSF    03.6
0A30:  MOVWF  36
0A31:  MOVLW  01
0A32:  MOVWF  37
0A33:  BCF    03.6
0A34:  CALL   178
0A35:  RETURN
.................... } 
....................  
.................... void gameover() { 
....................    error_beep(); 
....................    LENGTH_SNAKE = 5; 
*
0A60:  MOVLW  05
0A61:  MOVWF  6A
....................    posX = 0; 
0A62:  CLRF   6B
....................    posY = 2; 
0A63:  MOVLW  02
0A64:  MOVWF  6C
....................    score = 0; 
0A65:  CLRF   6D
....................    score_txt[7] = '0'; 
0A66:  MOVLW  30
0A67:  BSF    03.5
0A68:  MOVWF  67
....................    score_txt[8] = '0'; 
0A69:  MOVWF  68
....................    dir = 2; 
0A6A:  MOVLW  02
0A6B:  BCF    03.5
0A6C:  MOVWF  67
....................  
....................    glcd_fillScreen(0); 
0A6D:  BSF    03.6
0A6E:  CLRF   47
0A6F:  BCF    0A.3
0A70:  BCF    03.6
0A71:  CALL   26F
0A72:  BSF    0A.3
....................    glcd_text57(25, 30, gameover_msg, 1, 1); 
0A73:  MOVLW  19
0A74:  BSF    03.6
0A75:  MOVWF  5B
0A76:  MOVLW  1E
0A77:  MOVWF  5C
0A78:  MOVLW  01
0A79:  MOVWF  5E
0A7A:  MOVLW  1A
0A7B:  MOVWF  5D
0A7C:  MOVLW  01
0A7D:  MOVWF  5F
0A7E:  MOVWF  60
0A7F:  BCF    0A.3
0A80:  BCF    03.6
0A81:  CALL   4B3
0A82:  BSF    0A.3
....................    delay_ms(1500); 
0A83:  MOVLW  06
0A84:  BSF    03.6
0A85:  MOVWF  33
0A86:  MOVLW  FA
0A87:  MOVWF  49
0A88:  BCF    0A.3
0A89:  BCF    03.6
0A8A:  CALL   35A
0A8B:  BSF    0A.3
0A8C:  BSF    03.6
0A8D:  DECFSZ 33,F
0A8E:  GOTO   286
....................    screenWipeDown(); 
0A8F:  BCF    0A.3
0A90:  BCF    03.6
0A91:  CALL   5DD
0A92:  BSF    0A.3
....................    glcd_fillScreen(0); 
0A93:  BSF    03.6
0A94:  CLRF   47
0A95:  BCF    0A.3
0A96:  BCF    03.6
0A97:  CALL   26F
0A98:  BSF    0A.3
....................    drawGrid(); 
0A99:  BCF    0A.3
0A9A:  CALL   766
0A9B:  BSF    0A.3
0A9C:  RETURN
.................... } 
....................  
.................... void winScreen() { 
....................    win_melody(); 
....................    glcd_fillScreen(0); 
*
0AD9:  CLRF   47
0ADA:  BCF    0A.3
0ADB:  BCF    03.6
0ADC:  CALL   26F
0ADD:  BSF    0A.3
....................    glcd_text57(35, 35, win_msg, 1, 1); 
0ADE:  MOVLW  23
0ADF:  BSF    03.6
0AE0:  MOVWF  5B
0AE1:  MOVWF  5C
0AE2:  MOVLW  01
0AE3:  MOVWF  5E
0AE4:  MOVLW  28
0AE5:  MOVWF  5D
0AE6:  MOVLW  01
0AE7:  MOVWF  5F
0AE8:  MOVWF  60
0AE9:  BCF    0A.3
0AEA:  BCF    03.6
0AEB:  CALL   4B3
0AEC:  BSF    0A.3
....................    delay_ms(2500); 
0AED:  MOVLW  0A
0AEE:  BSF    03.6
0AEF:  MOVWF  33
0AF0:  MOVLW  FA
0AF1:  MOVWF  49
0AF2:  BCF    0A.3
0AF3:  BCF    03.6
0AF4:  CALL   35A
0AF5:  BSF    0A.3
0AF6:  BSF    03.6
0AF7:  DECFSZ 33,F
0AF8:  GOTO   2F0
....................    screenWipeDown(); 
0AF9:  BCF    0A.3
0AFA:  BCF    03.6
0AFB:  CALL   5DD
0AFC:  BSF    0A.3
....................    glcd_fillScreen(0); 
0AFD:  BSF    03.6
0AFE:  CLRF   47
0AFF:  BCF    0A.3
0B00:  BCF    03.6
0B01:  CALL   26F
0B02:  BSF    0A.3
....................    drawGrid(); 
0B03:  BCF    0A.3
0B04:  CALL   766
0B05:  BSF    0A.3
....................    LENGTH_SNAKE = 5; 
0B06:  MOVLW  05
0B07:  MOVWF  6A
....................    posX = 0; 
0B08:  CLRF   6B
....................    posY = 2; 
0B09:  MOVLW  02
0B0A:  MOVWF  6C
....................    score = 0; 
0B0B:  CLRF   6D
....................    score_txt[7] = '0'; 
0B0C:  MOVLW  30
0B0D:  BSF    03.5
0B0E:  MOVWF  67
....................    score_txt[8] = '0'; 
0B0F:  MOVWF  68
....................    dir = 2; 
0B10:  MOVLW  02
0B11:  BCF    03.5
0B12:  MOVWF  67
0B13:  BSF    0A.3
0B14:  BCF    0A.4
0B15:  GOTO   5CF (RETURN)
.................... } 
....................  
.................... void showSplashScreen() { 
....................    char serpenti_txt[] = "SERPENTI"; 
*
058A:  MOVLW  53
058B:  BSF    03.6
058C:  MOVWF  33
058D:  MOVLW  45
058E:  MOVWF  34
058F:  MOVLW  52
0590:  MOVWF  35
0591:  MOVLW  50
0592:  MOVWF  36
0593:  MOVLW  45
0594:  MOVWF  37
0595:  MOVLW  4E
0596:  MOVWF  38
0597:  MOVLW  54
0598:  MOVWF  39
0599:  MOVLW  49
059A:  MOVWF  3A
059B:  CLRF   3B
....................    char snakegame_txt[] = "SNAKE GAME"; 
059C:  MOVLW  53
059D:  MOVWF  3C
059E:  MOVLW  4E
059F:  MOVWF  3D
05A0:  MOVLW  41
05A1:  MOVWF  3E
05A2:  MOVLW  4B
05A3:  MOVWF  3F
05A4:  MOVLW  45
05A5:  MOVWF  40
05A6:  MOVLW  20
05A7:  MOVWF  41
05A8:  MOVLW  47
05A9:  MOVWF  42
05AA:  MOVLW  41
05AB:  MOVWF  43
05AC:  MOVLW  4D
05AD:  MOVWF  44
05AE:  MOVLW  45
05AF:  MOVWF  45
05B0:  CLRF   46
....................  
....................    glcd_fillScreen(0); 
05B1:  CLRF   47
05B2:  BCF    03.6
05B3:  CALL   26F
....................    glcd_text57(40, 22, serpenti_txt, 1, 1); 
05B4:  MOVLW  28
05B5:  BSF    03.6
05B6:  MOVWF  5B
05B7:  MOVLW  16
05B8:  MOVWF  5C
05B9:  MOVLW  01
05BA:  MOVWF  5E
05BB:  MOVLW  33
05BC:  MOVWF  5D
05BD:  MOVLW  01
05BE:  MOVWF  5F
05BF:  MOVWF  60
05C0:  BCF    03.6
05C1:  CALL   4B3
....................    glcd_text57(34, 34, snakegame_txt, 1, 1); 
05C2:  MOVLW  22
05C3:  BSF    03.6
05C4:  MOVWF  5B
05C5:  MOVWF  5C
05C6:  MOVLW  01
05C7:  MOVWF  5E
05C8:  MOVLW  3C
05C9:  MOVWF  5D
05CA:  MOVLW  01
05CB:  MOVWF  5F
05CC:  MOVWF  60
05CD:  BCF    03.6
05CE:  CALL   4B3
....................    delay_ms(2000); 
05CF:  MOVLW  08
05D0:  BSF    03.6
05D1:  MOVWF  47
05D2:  MOVLW  FA
05D3:  MOVWF  49
05D4:  BCF    03.6
05D5:  CALL   35A
05D6:  BSF    03.6
05D7:  DECFSZ 47,F
05D8:  GOTO   5D2
05D9:  BCF    03.6
05DA:  BSF    0A.3
05DB:  BCF    0A.4
05DC:  GOTO   3A8 (RETURN)
.................... } 
....................  
....................  
.................... void displayDifficulty(uchar index) { 
....................    char difficultyText[16]; 
....................    for (uchar x = 0; x < 128; x++) { 
*
05FC:  BSF    03.6
05FD:  CLRF   57
05FE:  MOVF   57,W
05FF:  SUBLW  7F
0600:  BTFSS  03.0
0601:  GOTO   614
....................       for (uchar y = 30; y < 43; y++) { 
0602:  MOVLW  1E
0603:  MOVWF  58
0604:  MOVF   58,W
0605:  SUBLW  2A
0606:  BTFSS  03.0
0607:  GOTO   612
....................          glcd_pixel(x, y, 0); 
0608:  MOVF   57,W
0609:  MOVWF  6D
060A:  MOVF   58,W
060B:  MOVWF  6E
060C:  CLRF   6F
060D:  BCF    03.6
060E:  CALL   3EA
060F:  BSF    03.6
0610:  INCF   58,F
0611:  GOTO   604
....................       } 
0612:  INCF   57,F
0613:  GOTO   5FE
....................    } 
....................    switch(index) { 
0614:  MOVF   46,W
0615:  XORLW  00
0616:  BCF    03.6
0617:  BTFSC  03.2
0618:  GOTO   620
0619:  XORLW  01
061A:  BTFSC  03.2
061B:  GOTO   635
061C:  XORLW  03
061D:  BTFSC  03.2
061E:  GOTO   64A
061F:  GOTO   65E
....................       case 0: strcpy(difficultyText, "< EASY >"); break; 
0620:  BSF    03.6
0621:  CLRF   5B
0622:  CLRF   5C
0623:  MOVLW  47
0624:  MOVWF  04
0625:  BSF    03.7
0626:  MOVF   5B,W
0627:  ADDWF  04,F
0628:  MOVF   5C,W
0629:  BCF    03.6
062A:  CALL   1EA
062B:  MOVWF  00
062C:  IORLW  00
062D:  BTFSC  03.2
062E:  GOTO   634
062F:  BSF    03.6
0630:  INCF   5C,F
0631:  INCF   5B,F
0632:  GOTO   623
0633:  BCF    03.6
0634:  GOTO   65E
....................       case 1: strcpy(difficultyText, "< MEDIUM >"); break; 
0635:  BSF    03.6
0636:  CLRF   5B
0637:  CLRF   5C
0638:  MOVLW  47
0639:  MOVWF  04
063A:  BSF    03.7
063B:  MOVF   5B,W
063C:  ADDWF  04,F
063D:  MOVF   5C,W
063E:  BCF    03.6
063F:  CALL   1F7
0640:  MOVWF  00
0641:  IORLW  00
0642:  BTFSC  03.2
0643:  GOTO   649
0644:  BSF    03.6
0645:  INCF   5C,F
0646:  INCF   5B,F
0647:  GOTO   638
0648:  BCF    03.6
0649:  GOTO   65E
....................       case 2: strcpy(difficultyText, "< HARD >"); break; 
064A:  BSF    03.6
064B:  CLRF   5B
064C:  CLRF   5C
064D:  MOVLW  47
064E:  MOVWF  04
064F:  BSF    03.7
0650:  MOVF   5B,W
0651:  ADDWF  04,F
0652:  MOVF   5C,W
0653:  BCF    03.6
0654:  CALL   209
0655:  MOVWF  00
0656:  IORLW  00
0657:  BTFSC  03.2
0658:  GOTO   65E
0659:  BSF    03.6
065A:  INCF   5C,F
065B:  INCF   5B,F
065C:  GOTO   64D
065D:  BCF    03.6
....................    } 
....................  
....................    int text_length = strlen(difficultyText); 
....................    int pos_x = (128 - (text_length * 6)) / 2; 
065E:  MOVLW  01
065F:  BSF    03.6
0660:  MOVWF  5C
0661:  MOVLW  47
0662:  MOVWF  5B
*
0680:  MOVF   78,W
0681:  MOVWF  59
0682:  MOVWF  6D
0683:  MOVLW  06
0684:  MOVWF  6E
0685:  BCF    03.6
0686:  CALL   248
0687:  MOVF   78,W
0688:  SUBLW  80
0689:  MOVWF  77
068A:  BCF    03.0
068B:  RRF    77,W
068C:  BSF    03.6
068D:  MOVWF  5A
....................     
....................    glcd_text57(pos_x, 32, difficultyText, 1, 1); 
068E:  MOVF   5A,W
068F:  MOVWF  5B
0690:  MOVLW  20
0691:  MOVWF  5C
0692:  MOVLW  01
0693:  MOVWF  5E
0694:  MOVLW  47
0695:  MOVWF  5D
0696:  MOVLW  01
0697:  MOVWF  5F
0698:  MOVWF  60
0699:  BCF    03.6
069A:  CALL   4B3
069B:  RETURN
.................... } 
....................  
....................  
....................  
.................... void selectDifficulty() { 
....................    char title[] = "SELECT DIFFICULTY"; 
*
06A2:  MOVLW  53
06A3:  BSF    03.6
06A4:  MOVWF  33
06A5:  MOVLW  45
06A6:  MOVWF  34
06A7:  MOVLW  4C
06A8:  MOVWF  35
06A9:  MOVLW  45
06AA:  MOVWF  36
06AB:  MOVLW  43
06AC:  MOVWF  37
06AD:  MOVLW  54
06AE:  MOVWF  38
06AF:  MOVLW  20
06B0:  MOVWF  39
06B1:  MOVLW  44
06B2:  MOVWF  3A
06B3:  MOVLW  49
06B4:  MOVWF  3B
06B5:  MOVLW  46
06B6:  MOVWF  3C
06B7:  MOVWF  3D
06B8:  MOVLW  49
06B9:  MOVWF  3E
06BA:  MOVLW  43
06BB:  MOVWF  3F
06BC:  MOVLW  55
06BD:  MOVWF  40
06BE:  MOVLW  4C
06BF:  MOVWF  41
06C0:  MOVLW  54
06C1:  MOVWF  42
06C2:  MOVLW  59
06C3:  MOVWF  43
06C4:  CLRF   44
....................    glcd_fillScreen(0); 
06C5:  CLRF   47
06C6:  BCF    03.6
06C7:  CALL   26F
....................    glcd_text57(13, 18, title, 1, 1); 
06C8:  MOVLW  0D
06C9:  BSF    03.6
06CA:  MOVWF  5B
06CB:  MOVLW  12
06CC:  MOVWF  5C
06CD:  MOVLW  01
06CE:  MOVWF  5E
06CF:  MOVLW  33
06D0:  MOVWF  5D
06D1:  MOVLW  01
06D2:  MOVWF  5F
06D3:  MOVWF  60
06D4:  BCF    03.6
06D5:  CALL   4B3
....................    displayDifficulty(difficulty_index); 
06D6:  MOVF   71,W
06D7:  BSF    03.6
06D8:  MOVWF  46
06D9:  BCF    03.6
06DA:  CALL   5FC
....................  
....................    int1 prev_left = 0, prev_right = 0, prev_select = 0; 
06DB:  BSF    03.6
06DC:  BCF    45.0
06DD:  BCF    45.1
06DE:  BCF    45.2
....................  
....................    while(TRUE) { 
....................       int1 curr_left = input(PIN_C4); 
....................       int1 curr_right = input(PIN_C3); 
....................       int1 curr_select = input(PIN_C5); 
06DF:  BCF    03.6
06E0:  BSF    26.4
06E1:  MOVF   26,W
06E2:  BSF    03.5
06E3:  MOVWF  07
06E4:  BCF    03.5
06E5:  BSF    03.6
06E6:  BCF    45.3
06E7:  BCF    03.6
06E8:  BTFSS  07.4
06E9:  GOTO   6ED
06EA:  BSF    03.6
06EB:  BSF    45.3
06EC:  BCF    03.6
06ED:  BSF    26.3
06EE:  MOVF   26,W
06EF:  BSF    03.5
06F0:  MOVWF  07
06F1:  BCF    03.5
06F2:  BSF    03.6
06F3:  BCF    45.4
06F4:  BCF    03.6
06F5:  BTFSS  07.3
06F6:  GOTO   6FA
06F7:  BSF    03.6
06F8:  BSF    45.4
06F9:  BCF    03.6
06FA:  BSF    26.5
06FB:  MOVF   26,W
06FC:  BSF    03.5
06FD:  MOVWF  07
06FE:  BCF    03.5
06FF:  BSF    03.6
0700:  BCF    45.5
0701:  BCF    03.6
0702:  BTFSS  07.5
0703:  GOTO   707
0704:  BSF    03.6
0705:  BSF    45.5
0706:  BCF    03.6
....................  
....................       if (curr_right && !prev_right) { 
0707:  BSF    03.6
0708:  BTFSS  45.4
0709:  GOTO   717
070A:  BTFSC  45.1
070B:  GOTO   717
....................          if (difficulty_index < 2) { 
070C:  MOVF   71,W
070D:  SUBLW  01
070E:  BTFSS  03.0
070F:  GOTO   717
....................             difficulty_index++; 
0710:  INCF   71,F
....................             displayDifficulty(difficulty_index); 
0711:  MOVF   71,W
0712:  MOVWF  46
0713:  BCF    03.6
0714:  CALL   5FC
....................             short_beep(); 
0715:  CALL   69C
0716:  BSF    03.6
....................          } 
....................       } 
....................  
....................       if (curr_left && !prev_left) { 
0717:  BTFSS  45.3
0718:  GOTO   725
0719:  BTFSC  45.0
071A:  GOTO   725
....................          if (difficulty_index > 0) { 
071B:  MOVF   71,F
071C:  BTFSC  03.2
071D:  GOTO   725
....................             difficulty_index--; 
071E:  DECF   71,F
....................             displayDifficulty(difficulty_index); 
071F:  MOVF   71,W
0720:  MOVWF  46
0721:  BCF    03.6
0722:  CALL   5FC
....................             short_beep(); 
0723:  CALL   69C
0724:  BSF    03.6
....................          } 
....................       } 
....................  
....................       if (curr_select && !prev_select) { 
0725:  BTFSS  45.5
0726:  GOTO   753
0727:  BTFSC  45.2
0728:  GOTO   753
....................          switch (difficulty_index) { 
0729:  MOVF   71,W
072A:  XORLW  00
072B:  BCF    03.6
072C:  BTFSC  03.2
072D:  GOTO   735
072E:  XORLW  01
072F:  BTFSC  03.2
0730:  GOTO   73A
0731:  XORLW  03
0732:  BTFSC  03.2
0733:  GOTO   73F
0734:  GOTO   743
....................             case 0: gameSettings.delay_time = 3; break; 
0735:  MOVLW  FC
0736:  ANDWF  72,W
0737:  IORLW  03
0738:  MOVWF  72
0739:  GOTO   743
....................             case 1: gameSettings.delay_time = 2; break; 
073A:  MOVLW  FC
073B:  ANDWF  72,W
073C:  IORLW  02
073D:  MOVWF  72
073E:  GOTO   743
....................             case 2: gameSettings.delay_time = 1; break; 
073F:  MOVLW  FC
0740:  ANDWF  72,W
0741:  IORLW  01
0742:  MOVWF  72
....................          } 
....................          buzzer_beep(100);  // Confirmation beep 
0743:  MOVLW  64
0744:  BSF    03.6
0745:  MOVWF  46
0746:  BCF    03.6
0747:  CALL   3AD
....................          delay_ms(300); 
0748:  MOVLW  02
0749:  BSF    03.6
074A:  MOVWF  46
074B:  MOVLW  96
074C:  MOVWF  49
074D:  BCF    03.6
074E:  CALL   35A
074F:  BSF    03.6
0750:  DECFSZ 46,F
0751:  GOTO   74B
....................          return; 
0752:  GOTO   762
....................       } 
....................  
....................       prev_left = curr_left; 
0753:  BCF    45.0
0754:  BTFSC  45.3
0755:  BSF    45.0
....................       prev_right = curr_right; 
0756:  BCF    45.1
0757:  BTFSC  45.4
0758:  BSF    45.1
....................       prev_select = curr_select; 
0759:  BCF    45.2
075A:  BTFSC  45.5
075B:  BSF    45.2
....................  
....................       delay_ms(50); // buton kontrol frekans 
075C:  MOVLW  32
075D:  MOVWF  49
075E:  BCF    03.6
075F:  CALL   35A
0760:  GOTO   6E0
0761:  BSF    03.6
....................    } 
0762:  BCF    03.6
0763:  BSF    0A.3
0764:  BCF    0A.4
0765:  GOTO   3AE (RETURN)
.................... } 
....................  
....................  
.................... void main() { 
*
0B16:  MOVF   03,W
0B17:  ANDLW  1F
0B18:  MOVWF  03
0B19:  MOVLW  FF
0B1A:  MOVWF  26
0B1B:  MOVLW  02
0B1C:  MOVWF  67
0B1D:  MOVLW  05
0B1E:  MOVWF  6A
0B1F:  CLRF   6B
0B20:  MOVLW  02
0B21:  MOVWF  6C
0B22:  CLRF   6D
0B23:  CLRF   6E
0B24:  BSF    70.0
0B25:  CLRF   71
0B26:  BSF    03.5
0B27:  BSF    1F.0
0B28:  BSF    1F.1
0B29:  BSF    1F.2
0B2A:  BCF    1F.3
0B2B:  MOVLW  07
0B2C:  MOVWF  1C
0B2D:  BCF    03.7
....................    set_tris_b(0b00000111); 
*
0B7E:  MOVLW  07
0B7F:  BSF    03.5
0B80:  BCF    03.6
0B81:  MOVWF  06
....................    output_high(BUZZER_PIN); 
0B82:  BCF    06.3
0B83:  BCF    03.5
0B84:  BSF    06.3
....................  
....................    glcd_init(ON); 
0B85:  MOVLW  01
0B86:  BSF    03.6
0B87:  MOVWF  33
0B88:  BCF    0A.3
0B89:  BCF    03.6
0B8A:  GOTO   2E0
0B8B:  BSF    0A.3
....................    glcd_fillScreen(0); 
0B8C:  BSF    03.6
0B8D:  CLRF   47
0B8E:  BCF    0A.3
0B8F:  BCF    03.6
0B90:  CALL   26F
0B91:  BSF    0A.3
....................    delay_ms(500); 
0B92:  MOVLW  02
0B93:  BSF    03.6
0B94:  MOVWF  33
0B95:  MOVLW  FA
0B96:  MOVWF  49
0B97:  BCF    0A.3
0B98:  BCF    03.6
0B99:  CALL   35A
0B9A:  BSF    0A.3
0B9B:  BSF    03.6
0B9C:  DECFSZ 33,F
0B9D:  GOTO   395
....................  
.................... Start: 
....................    if (isFirstStart) { 
0B9E:  BTFSS  70.0
0B9F:  GOTO   3B1
....................       buzzer_beep(100); 
0BA0:  MOVLW  64
0BA1:  MOVWF  46
0BA2:  BCF    0A.3
0BA3:  BCF    03.6
0BA4:  CALL   3AD
0BA5:  BSF    0A.3
....................       showSplashScreen(); 
0BA6:  BCF    0A.3
0BA7:  GOTO   58A
0BA8:  BSF    0A.3
....................       screenWipeDown(); 
0BA9:  BCF    0A.3
0BAA:  CALL   5DD
0BAB:  BSF    0A.3
....................       selectDifficulty(); 
0BAC:  BCF    0A.3
0BAD:  GOTO   6A2
0BAE:  BSF    0A.3
....................       isFirstStart = 0; 
0BAF:  BCF    70.0
0BB0:  BSF    03.6
....................    } 
....................  
....................    glcd_fillScreen(0); 
0BB1:  CLRF   47
0BB2:  BCF    0A.3
0BB3:  BCF    03.6
0BB4:  CALL   26F
0BB5:  BSF    0A.3
....................    drawGrid(); 
0BB6:  BCF    0A.3
0BB7:  CALL   766
0BB8:  BSF    0A.3
....................    writeScore(); 
0BB9:  BCF    0A.3
0BBA:  CALL   7A5
0BBB:  BSF    0A.3
....................    criar_comida(); 
0BBC:  CALL   1C2
....................  
....................    for (i = 0; i < LENGTH_SNAKE; i++) { 
0BBD:  CLRF   6F
0BBE:  MOVF   6A,W
0BBF:  SUBWF  6F,W
0BC0:  BTFSC  03.0
0BC1:  GOTO   418
....................       setX(i, posX - i); 
0BC2:  MOVF   6F,W
0BC3:  SUBLW  1F
0BC4:  BTFSS  03.0
0BC5:  GOTO   3CE
0BC6:  MOVLW  27
0BC7:  ADDWF  6F,W
0BC8:  MOVWF  04
0BC9:  BCF    03.7
0BCA:  MOVF   6F,W
0BCB:  SUBWF  6B,W
0BCC:  MOVWF  00
0BCD:  GOTO   3D6
0BCE:  MOVLW  20
0BCF:  SUBWF  6F,W
0BD0:  ADDLW  A0
0BD1:  MOVWF  04
0BD2:  BCF    03.7
0BD3:  MOVF   6F,W
0BD4:  SUBWF  6B,W
0BD5:  MOVWF  00
....................       setY(i, posY); 
0BD6:  MOVF   6F,W
0BD7:  SUBLW  1F
0BD8:  BTFSS  03.0
0BD9:  GOTO   3E2
0BDA:  MOVLW  47
0BDB:  ADDWF  6F,W
0BDC:  MOVWF  04
0BDD:  BCF    03.7
0BDE:  MOVF   6C,W
0BDF:  MOVWF  00
0BE0:  MOVF   6C,W
0BE1:  GOTO   3E9
0BE2:  MOVLW  20
0BE3:  SUBWF  6F,W
0BE4:  ADDLW  C0
0BE5:  MOVWF  04
0BE6:  BCF    03.7
0BE7:  MOVF   6C,W
0BE8:  MOVWF  00
....................       fillCell(getX(i), getY(i), 1); 
0BE9:  MOVF   6F,W
0BEA:  SUBLW  1F
0BEB:  BTFSS  03.0
0BEC:  GOTO   3F3
0BED:  MOVLW  27
0BEE:  ADDWF  6F,W
0BEF:  MOVWF  04
0BF0:  BCF    03.7
0BF1:  MOVF   00,W
0BF2:  GOTO   3F9
0BF3:  MOVLW  20
0BF4:  SUBWF  6F,W
0BF5:  ADDLW  A0
0BF6:  MOVWF  04
0BF7:  BCF    03.7
0BF8:  MOVF   00,W
0BF9:  BSF    03.6
0BFA:  MOVWF  33
0BFB:  BCF    03.6
0BFC:  MOVF   6F,W
0BFD:  SUBLW  1F
0BFE:  BTFSS  03.0
0BFF:  GOTO   406
0C00:  MOVLW  47
0C01:  ADDWF  6F,W
0C02:  MOVWF  04
0C03:  BCF    03.7
0C04:  MOVF   00,W
0C05:  GOTO   40C
0C06:  MOVLW  20
0C07:  SUBWF  6F,W
0C08:  ADDLW  C0
0C09:  MOVWF  04
0C0A:  BCF    03.7
0C0B:  MOVF   00,W
0C0C:  BSF    03.6
0C0D:  MOVWF  34
0C0E:  MOVF   33,W
0C0F:  MOVWF  35
0C10:  MOVF   34,W
0C11:  MOVWF  36
0C12:  MOVLW  01
0C13:  MOVWF  37
0C14:  BCF    03.6
0C15:  CALL   178
0C16:  INCF   6F,F
0C17:  GOTO   3BE
....................    } 
....................  
....................    while (TRUE) { 
....................       if (input(PIN_C3) && dir != 0) { dir = 3; short_beep(); } 
0C18:  BSF    26.3
0C19:  MOVF   26,W
0C1A:  BSF    03.5
0C1B:  MOVWF  07
0C1C:  BCF    03.5
0C1D:  BTFSS  07.3
0C1E:  GOTO   427
0C1F:  MOVF   67,F
0C20:  BTFSC  03.2
0C21:  GOTO   427
0C22:  MOVLW  03
0C23:  MOVWF  67
0C24:  BCF    0A.3
0C25:  CALL   69C
0C26:  BSF    0A.3
....................       if (input(PIN_C2) && dir != 1) { dir = 2; short_beep(); } 
0C27:  BSF    26.2
0C28:  MOVF   26,W
0C29:  BSF    03.5
0C2A:  MOVWF  07
0C2B:  BCF    03.5
0C2C:  BTFSS  07.2
0C2D:  GOTO   436
0C2E:  DECFSZ 67,W
0C2F:  GOTO   431
0C30:  GOTO   436
0C31:  MOVLW  02
0C32:  MOVWF  67
0C33:  BCF    0A.3
0C34:  CALL   69C
0C35:  BSF    0A.3
....................       if (input(PIN_C1) && dir != 2) { dir = 1; short_beep(); } 
0C36:  BSF    26.1
0C37:  MOVF   26,W
0C38:  BSF    03.5
0C39:  MOVWF  07
0C3A:  BCF    03.5
0C3B:  BTFSS  07.1
0C3C:  GOTO   446
0C3D:  MOVF   67,W
0C3E:  SUBLW  02
0C3F:  BTFSC  03.2
0C40:  GOTO   446
0C41:  MOVLW  01
0C42:  MOVWF  67
0C43:  BCF    0A.3
0C44:  CALL   69C
0C45:  BSF    0A.3
....................       if (input(PIN_C4) && dir != 3) { dir = 0; short_beep(); } 
0C46:  BSF    26.4
0C47:  MOVF   26,W
0C48:  BSF    03.5
0C49:  MOVWF  07
0C4A:  BCF    03.5
0C4B:  BTFSS  07.4
0C4C:  GOTO   455
0C4D:  MOVF   67,W
0C4E:  SUBLW  03
0C4F:  BTFSC  03.2
0C50:  GOTO   455
0C51:  CLRF   67
0C52:  BCF    0A.3
0C53:  CALL   69C
0C54:  BSF    0A.3
....................       if (input(PIN_C5)) { gameover(); goto Start; } 
0C55:  BSF    26.5
0C56:  MOVF   26,W
0C57:  BSF    03.5
0C58:  MOVWF  07
0C59:  BCF    03.5
0C5A:  BTFSS  07.5
0C5B:  GOTO   460
0C5C:  CALL   236
0C5D:  BSF    03.6
0C5E:  GOTO   39E
0C5F:  BCF    03.6
....................  
....................       switch(dir) { 
0C60:  MOVF   67,W
0C61:  ADDLW  FC
0C62:  BTFSC  03.0
0C63:  GOTO   497
0C64:  ADDLW  04
0C65:  GOTO   63F
....................          case 0: if (posX == 0) { gameover(); goto Start; } else posX--; break; 
0C66:  MOVF   6B,F
0C67:  BTFSS  03.2
0C68:  GOTO   46E
0C69:  CALL   236
0C6A:  BSF    03.6
0C6B:  GOTO   39E
0C6C:  GOTO   470
0C6D:  BCF    03.6
0C6E:  DECF   6B,F
0C6F:  BSF    03.6
0C70:  BCF    03.6
0C71:  GOTO   497
....................          case 1: if (posY == 0) { gameover(); goto Start; } else posY--; break; 
0C72:  MOVF   6C,F
0C73:  BTFSS  03.2
0C74:  GOTO   47A
0C75:  CALL   236
0C76:  BSF    03.6
0C77:  GOTO   39E
0C78:  GOTO   47C
0C79:  BCF    03.6
0C7A:  DECF   6C,F
0C7B:  BSF    03.6
0C7C:  BCF    03.6
0C7D:  GOTO   497
....................          case 2: if (posY == GRID_ROWS - 1) { gameover(); goto Start; } else posY++; break; 
0C7E:  MOVF   6C,W
0C7F:  SUBLW  09
0C80:  BTFSS  03.2
0C81:  GOTO   487
0C82:  CALL   236
0C83:  BSF    03.6
0C84:  GOTO   39E
0C85:  GOTO   489
0C86:  BCF    03.6
0C87:  INCF   6C,F
0C88:  BSF    03.6
0C89:  BCF    03.6
0C8A:  GOTO   497
....................          case 3: if (posX == GRID_COLS - 1) { gameover(); goto Start; } else posX++; break; 
0C8B:  MOVF   6B,W
0C8C:  SUBLW  09
0C8D:  BTFSS  03.2
0C8E:  GOTO   494
0C8F:  CALL   236
0C90:  BSF    03.6
0C91:  GOTO   39E
0C92:  GOTO   496
0C93:  BCF    03.6
0C94:  INCF   6B,F
0C95:  BSF    03.6
0C96:  BCF    03.6
....................       } 
....................  
....................       uchar tailX = getX(0), tailY = getY(0); 
0C97:  MOVF   27,W
0C98:  BSF    03.6
0C99:  MOVWF  31
0C9A:  BCF    03.6
0C9B:  MOVF   47,W
0C9C:  BSF    03.6
0C9D:  MOVWF  32
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
0C9E:  BCF    03.6
0C9F:  CLRF   6F
0CA0:  MOVLW  01
0CA1:  SUBWF  6A,W
0CA2:  SUBWF  6F,W
0CA3:  BTFSC  03.0
0CA4:  GOTO   549
....................          setX(i, getX(i + 1)); 
0CA5:  MOVF   6F,W
0CA6:  SUBLW  1F
0CA7:  BTFSS  03.0
0CA8:  GOTO   4D0
0CA9:  MOVLW  27
0CAA:  ADDWF  6F,W
0CAB:  BSF    03.6
0CAC:  MOVWF  33
0CAD:  CLRF   34
0CAE:  BTFSC  03.0
0CAF:  INCF   34,F
0CB0:  MOVLW  01
0CB1:  BCF    03.6
0CB2:  ADDWF  6F,W
0CB3:  SUBLW  1F
0CB4:  BTFSS  03.0
0CB5:  GOTO   4BD
0CB6:  MOVLW  01
0CB7:  ADDWF  6F,W
0CB8:  ADDLW  27
0CB9:  MOVWF  04
0CBA:  BCF    03.7
0CBB:  MOVF   00,W
0CBC:  GOTO   4C4
0CBD:  MOVLW  01
0CBE:  ADDWF  6F,W
0CBF:  ADDLW  E0
0CC0:  ADDLW  A0
0CC1:  MOVWF  04
0CC2:  BCF    03.7
0CC3:  MOVF   00,W
0CC4:  BSF    03.6
0CC5:  MOVWF  35
0CC6:  MOVF   33,W
0CC7:  MOVWF  04
0CC8:  BCF    03.7
0CC9:  BTFSC  34.0
0CCA:  BSF    03.7
0CCB:  MOVF   35,W
0CCC:  MOVWF  00
0CCD:  MOVF   35,W
0CCE:  GOTO   4F5
0CCF:  BCF    03.6
0CD0:  MOVLW  20
0CD1:  SUBWF  6F,W
0CD2:  ADDLW  A0
0CD3:  BSF    03.6
0CD4:  MOVWF  35
0CD5:  CLRF   36
0CD6:  BTFSC  03.0
0CD7:  INCF   36,F
0CD8:  MOVLW  01
0CD9:  BCF    03.6
0CDA:  ADDWF  6F,W
0CDB:  SUBLW  1F
0CDC:  BTFSS  03.0
0CDD:  GOTO   4E5
0CDE:  MOVLW  01
0CDF:  ADDWF  6F,W
0CE0:  ADDLW  27
0CE1:  MOVWF  04
0CE2:  BCF    03.7
0CE3:  MOVF   00,W
0CE4:  GOTO   4EC
0CE5:  MOVLW  01
0CE6:  ADDWF  6F,W
0CE7:  ADDLW  E0
0CE8:  ADDLW  A0
0CE9:  MOVWF  04
0CEA:  BCF    03.7
0CEB:  MOVF   00,W
0CEC:  BSF    03.6
0CED:  MOVWF  33
0CEE:  MOVF   35,W
0CEF:  MOVWF  04
0CF0:  BCF    03.7
0CF1:  BTFSC  36.0
0CF2:  BSF    03.7
0CF3:  MOVF   33,W
0CF4:  MOVWF  00
....................          setY(i, getY(i + 1)); 
0CF5:  BCF    03.6
0CF6:  MOVF   6F,W
0CF7:  SUBLW  1F
0CF8:  BTFSS  03.0
0CF9:  GOTO   521
0CFA:  MOVLW  47
0CFB:  ADDWF  6F,W
0CFC:  BSF    03.6
0CFD:  MOVWF  33
0CFE:  CLRF   34
0CFF:  BTFSC  03.0
0D00:  INCF   34,F
0D01:  MOVLW  01
0D02:  BCF    03.6
0D03:  ADDWF  6F,W
0D04:  SUBLW  1F
0D05:  BTFSS  03.0
0D06:  GOTO   50E
0D07:  MOVLW  01
0D08:  ADDWF  6F,W
0D09:  ADDLW  47
0D0A:  MOVWF  04
0D0B:  BCF    03.7
0D0C:  MOVF   00,W
0D0D:  GOTO   515
0D0E:  MOVLW  01
0D0F:  ADDWF  6F,W
0D10:  ADDLW  E0
0D11:  ADDLW  C0
0D12:  MOVWF  04
0D13:  BCF    03.7
0D14:  MOVF   00,W
0D15:  BSF    03.6
0D16:  MOVWF  35
0D17:  MOVF   33,W
0D18:  MOVWF  04
0D19:  BCF    03.7
0D1A:  BTFSC  34.0
0D1B:  BSF    03.7
0D1C:  MOVF   35,W
0D1D:  MOVWF  00
0D1E:  MOVF   35,W
0D1F:  GOTO   546
0D20:  BCF    03.6
0D21:  MOVLW  20
0D22:  SUBWF  6F,W
0D23:  ADDLW  C0
0D24:  BSF    03.6
0D25:  MOVWF  35
0D26:  CLRF   36
0D27:  BTFSC  03.0
0D28:  INCF   36,F
0D29:  MOVLW  01
0D2A:  BCF    03.6
0D2B:  ADDWF  6F,W
0D2C:  SUBLW  1F
0D2D:  BTFSS  03.0
0D2E:  GOTO   536
0D2F:  MOVLW  01
0D30:  ADDWF  6F,W
0D31:  ADDLW  47
0D32:  MOVWF  04
0D33:  BCF    03.7
0D34:  MOVF   00,W
0D35:  GOTO   53D
0D36:  MOVLW  01
0D37:  ADDWF  6F,W
0D38:  ADDLW  E0
0D39:  ADDLW  C0
0D3A:  MOVWF  04
0D3B:  BCF    03.7
0D3C:  MOVF   00,W
0D3D:  BSF    03.6
0D3E:  MOVWF  33
0D3F:  MOVF   35,W
0D40:  MOVWF  04
0D41:  BCF    03.7
0D42:  BTFSC  36.0
0D43:  BSF    03.7
0D44:  MOVF   33,W
0D45:  MOVWF  00
0D46:  BCF    03.6
0D47:  INCF   6F,F
0D48:  GOTO   4A0
....................       } 
....................       setX(LENGTH_SNAKE - 1, posX); 
0D49:  MOVLW  01
0D4A:  SUBWF  6A,W
0D4B:  SUBLW  1F
0D4C:  BTFSS  03.0
0D4D:  GOTO   557
0D4E:  MOVLW  01
0D4F:  SUBWF  6A,W
0D50:  ADDLW  27
0D51:  MOVWF  04
0D52:  BCF    03.7
0D53:  MOVF   6B,W
0D54:  MOVWF  00
0D55:  MOVF   6B,W
0D56:  GOTO   55F
0D57:  MOVLW  01
0D58:  SUBWF  6A,W
0D59:  ADDLW  E0
0D5A:  ADDLW  A0
0D5B:  MOVWF  04
0D5C:  BCF    03.7
0D5D:  MOVF   6B,W
0D5E:  MOVWF  00
....................       setY(LENGTH_SNAKE - 1, posY); 
0D5F:  MOVLW  01
0D60:  SUBWF  6A,W
0D61:  SUBLW  1F
0D62:  BTFSS  03.0
0D63:  GOTO   56D
0D64:  MOVLW  01
0D65:  SUBWF  6A,W
0D66:  ADDLW  47
0D67:  MOVWF  04
0D68:  BCF    03.7
0D69:  MOVF   6C,W
0D6A:  MOVWF  00
0D6B:  MOVF   6C,W
0D6C:  GOTO   575
0D6D:  MOVLW  01
0D6E:  SUBWF  6A,W
0D6F:  ADDLW  E0
0D70:  ADDLW  C0
0D71:  MOVWF  04
0D72:  BCF    03.7
0D73:  MOVF   6C,W
0D74:  MOVWF  00
....................  
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
0D75:  CLRF   6F
0D76:  MOVLW  01
0D77:  SUBWF  6A,W
0D78:  SUBWF  6F,W
0D79:  BTFSC  03.0
0D7A:  GOTO   5A7
....................          if (getX(i) == posX && getY(i) == posY) { 
0D7B:  MOVF   6F,W
0D7C:  SUBLW  1F
0D7D:  BTFSS  03.0
0D7E:  GOTO   585
0D7F:  MOVLW  27
0D80:  ADDWF  6F,W
0D81:  MOVWF  04
0D82:  BCF    03.7
0D83:  MOVF   00,W
0D84:  GOTO   58B
0D85:  MOVLW  20
0D86:  SUBWF  6F,W
0D87:  ADDLW  A0
0D88:  MOVWF  04
0D89:  BCF    03.7
0D8A:  MOVF   00,W
0D8B:  SUBWF  6B,W
0D8C:  BTFSS  03.2
0D8D:  GOTO   5A5
0D8E:  MOVF   6F,W
0D8F:  SUBLW  1F
0D90:  BTFSS  03.0
0D91:  GOTO   598
0D92:  MOVLW  47
0D93:  ADDWF  6F,W
0D94:  MOVWF  04
0D95:  BCF    03.7
0D96:  MOVF   00,W
0D97:  GOTO   59E
0D98:  MOVLW  20
0D99:  SUBWF  6F,W
0D9A:  ADDLW  C0
0D9B:  MOVWF  04
0D9C:  BCF    03.7
0D9D:  MOVF   00,W
0D9E:  SUBWF  6C,W
0D9F:  BTFSS  03.2
0DA0:  GOTO   5A5
....................             gameover(); goto Start; 
0DA1:  CALL   236
0DA2:  BSF    03.6
0DA3:  GOTO   39E
0DA4:  BCF    03.6
....................          } 
0DA5:  INCF   6F,F
0DA6:  GOTO   576
....................       } 
....................  
....................       fillCell(posX, posY, 1); 
0DA7:  MOVF   6B,W
0DA8:  BSF    03.6
0DA9:  MOVWF  35
0DAA:  BCF    03.6
0DAB:  MOVF   6C,W
0DAC:  BSF    03.6
0DAD:  MOVWF  36
0DAE:  MOVLW  01
0DAF:  MOVWF  37
0DB0:  BCF    03.6
0DB1:  CALL   178
....................       fillCell(tailX, tailY, 0); 
0DB2:  BSF    03.6
0DB3:  MOVF   31,W
0DB4:  MOVWF  35
0DB5:  MOVF   32,W
0DB6:  MOVWF  36
0DB7:  CLRF   37
0DB8:  BCF    03.6
0DB9:  CALL   178
....................  
....................       if (posX == food[0] && posY == food[1]) { 
0DBA:  MOVF   68,W
0DBB:  SUBWF  6B,W
0DBC:  BTFSS  03.2
0DBD:  GOTO   615
0DBE:  MOVF   69,W
0DBF:  SUBWF  6C,W
0DC0:  BTFSS  03.2
0DC1:  GOTO   615
....................          buzzer_beep(50); 
0DC2:  MOVLW  32
0DC3:  BSF    03.6
0DC4:  MOVWF  46
0DC5:  BCF    0A.3
0DC6:  BCF    03.6
0DC7:  CALL   3AD
0DC8:  BSF    0A.3
....................          LENGTH_SNAKE++; 
0DC9:  INCF   6A,F
....................          if (LENGTH_SNAKE >= 64) { 
0DCA:  MOVF   6A,W
0DCB:  SUBLW  3F
0DCC:  BTFSC  03.0
0DCD:  GOTO   5D2
....................             winScreen(); goto Start; 
0DCE:  GOTO   29D
0DCF:  BSF    03.6
0DD0:  GOTO   39E
0DD1:  BCF    03.6
....................          } 
....................          criar_comida(); 
0DD2:  CALL   1C2
....................          score++; 
0DD3:  INCF   6D,F
....................          score_txt[7] = '0' + (score / 10); 
0DD4:  MOVF   6D,W
0DD5:  BSF    03.6
0DD6:  MOVWF  33
0DD7:  MOVLW  0A
0DD8:  MOVWF  34
0DD9:  BCF    0A.3
0DDA:  BCF    03.6
0DDB:  CALL   7D7
0DDC:  BSF    0A.3
0DDD:  MOVF   78,W
0DDE:  ADDLW  30
0DDF:  BSF    03.5
0DE0:  MOVWF  67
....................          score_txt[8] = '0' + (score % 10); 
0DE1:  BCF    03.5
0DE2:  MOVF   6D,W
0DE3:  BSF    03.6
0DE4:  MOVWF  33
0DE5:  MOVLW  0A
0DE6:  MOVWF  34
0DE7:  BCF    0A.3
0DE8:  BCF    03.6
0DE9:  CALL   7D7
0DEA:  BSF    0A.3
0DEB:  MOVF   77,W
0DEC:  ADDLW  30
0DED:  BSF    03.5
0DEE:  MOVWF  68
....................  
....................          if (score > best_score) { 
0DEF:  BCF    03.5
0DF0:  MOVF   6D,W
0DF1:  SUBWF  6E,W
0DF2:  BTFSC  03.0
0DF3:  GOTO   612
....................             best_score = score; 
0DF4:  MOVF   6D,W
0DF5:  MOVWF  6E
....................             best_score_txt[7] = '0' + (best_score / 10); 
0DF6:  MOVF   6E,W
0DF7:  BSF    03.6
0DF8:  MOVWF  33
0DF9:  MOVLW  0A
0DFA:  MOVWF  34
0DFB:  BCF    0A.3
0DFC:  BCF    03.6
0DFD:  CALL   7D7
0DFE:  BSF    0A.3
0DFF:  MOVF   78,W
0E00:  ADDLW  30
0E01:  BSF    03.6
0E02:  MOVWF  17
....................             best_score_txt[8] = '0' + (best_score % 10); 
0E03:  BCF    03.6
0E04:  MOVF   6E,W
0E05:  BSF    03.6
0E06:  MOVWF  33
0E07:  MOVLW  0A
0E08:  MOVWF  34
0E09:  BCF    0A.3
0E0A:  BCF    03.6
0E0B:  CALL   7D7
0E0C:  BSF    0A.3
0E0D:  MOVF   77,W
0E0E:  ADDLW  30
0E0F:  BSF    03.6
0E10:  MOVWF  18
0E11:  BCF    03.6
....................          } 
....................  
....................          writeScore(); 
0E12:  BCF    0A.3
0E13:  CALL   7A5
0E14:  BSF    0A.3
....................       } 
....................  
....................       delay_ms(gameSettings.delay_time * 300); // game difficulty inverse proportion 
0E15:  MOVF   72,W
0E16:  ANDLW  03
0E17:  BSF    03.6
0E18:  MOVWF  34
0E19:  CLRF   4A
0E1A:  MOVF   34,W
0E1B:  MOVWF  49
0E1C:  MOVLW  01
0E1D:  MOVWF  4C
0E1E:  MOVLW  2C
0E1F:  MOVWF  4B
0E20:  BCF    0A.3
0E21:  BCF    03.6
0E22:  CALL   36F
0E23:  BSF    0A.3
0E24:  MOVF   79,W
0E25:  BSF    03.6
0E26:  MOVWF  34
0E27:  MOVF   78,W
0E28:  MOVWF  33
0E29:  MOVF   34,W
0E2A:  MOVWF  35
0E2B:  INCF   35,F
0E2C:  DECF   35,F
0E2D:  BTFSC  03.2
0E2E:  GOTO   637
0E2F:  MOVLW  FF
0E30:  MOVWF  49
0E31:  BCF    0A.3
0E32:  BCF    03.6
0E33:  CALL   35A
0E34:  BSF    0A.3
0E35:  BSF    03.6
0E36:  GOTO   62C
0E37:  MOVF   33,W
0E38:  MOVWF  49
0E39:  BCF    0A.3
0E3A:  BCF    03.6
0E3B:  CALL   35A
0E3C:  BSF    0A.3
0E3D:  GOTO   418
....................    } 
.................... } 
....................  
0E3E:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
