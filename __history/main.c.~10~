#include <16F877A.h>
#fuses HS,NOWDT,NOPROTECT,NOLVP
#use delay(clock=16000000)
#include <stdlib.h>
#include <glcd.c>
#include <stdio.h>

#define uchar unsigned char

// Izgara parametreleri
#define GRID_SIZE     6
#define GRID_COLS     10
#define GRID_ROWS     10
#define GRID_ORIGIN_X 0
#define GRID_ORIGIN_Y 0

uchar SNAKE[40][2];
uchar dir = 2;
uchar food[2], LENGTH_SNAKE = 10;
uchar posX = 1, posY = 2;
uchar score = 0;
char score_txt[11] = "Score: 00";
char gayover[14]= "GAME OVER !!!";
uchar i;

// Izgarayý tek seferlik çiz
void drawGrid() {
   for (uchar c = 0; c <= GRID_COLS; c++) {
      uchar x = GRID_ORIGIN_X + c * GRID_SIZE;
      glcd_line(x, GRID_ORIGIN_Y, x, GRID_ORIGIN_Y + GRID_ROWS*GRID_SIZE, 1);
   }
   for (uchar r = 0; r <= GRID_ROWS; r++) {
      uchar y = GRID_ORIGIN_Y + r * GRID_SIZE;
      glcd_line(GRID_ORIGIN_X, y, GRID_ORIGIN_X + GRID_COLS*GRID_SIZE, y, 1);
   }
}

// Hücre içini doldur/boþalt
void fillCell(uchar gx, uchar gy, int1 color) {
   uchar px = GRID_ORIGIN_X + gx * GRID_SIZE + 1;
   uchar py = GRID_ORIGIN_Y + gy * GRID_SIZE + 1;
   for (uchar dx = 0; dx < GRID_SIZE-1; dx++)
      for (uchar dy = 0; dy < GRID_SIZE-1; dy++)
         glcd_pixel(px + dx, py + dy, color);
}

// Kafa segmentini yönüne göre farklý çizer (ok baþý ve göz efekti)
void drawHead(uchar x, uchar y, uchar dir) {
    uchar px = GRID_ORIGIN_X + x * GRID_SIZE + 1;
    uchar py = GRID_ORIGIN_Y + y * GRID_SIZE + 1;

    // Önce kafayý tamamen doldur
    uchar dx, dy;
    for (dx = 0; dx < GRID_SIZE-1; dx++)
        for (dy = 0; dy < GRID_SIZE-1; dy++)
            glcd_pixel(px + dx, py + dy, 1);

    // Sonra yönüne göre "ok baþý" efekti ve göz detayý çiz
    switch(dir) {
        case 0: { // Sol
            uchar i0;
            for (i0 = 0; i0 < GRID_SIZE-1; i0++)
                glcd_pixel(px, py + i0, 0); // Sol kenarý açýk
            glcd_pixel(px+1, py+1, 0); // Sol göz
            glcd_pixel(px+1, py+3, 0); // Sol göz 2
            break;
        }
        case 1: { // Yukarý
            uchar i1;
            for (i1 = 0; i1 < GRID_SIZE-1; i1++)
                glcd_pixel(px + i1, py, 0); // Üst kenarý açýk
            glcd_pixel(px+1, py+1, 0); // Göz sol
            glcd_pixel(px+3, py+1, 0); // Göz sað
            break;
        }
        case 2: { // Aþaðý
            uchar i2;
            for (i2 = 0; i2 < GRID_SIZE-1; i2++)
                glcd_pixel(px + i2, py + GRID_SIZE-2, 0); // Alt kenarý açýk
            glcd_pixel(px+1, py+GRID_SIZE-3, 0); // Göz sol
            glcd_pixel(px+3, py+GRID_SIZE-3, 0); // Göz sað
            break;
        }
        case 3: { // Sað
            uchar i3;
            for (i3 = 0; i3 < GRID_SIZE-1; i3++)
                glcd_pixel(px + GRID_SIZE-2, py + i3, 0); // Sað kenarý açýk
            glcd_pixel(px+GRID_SIZE-3, py+1, 0); // Sað göz
            glcd_pixel(px+GRID_SIZE-3, py+3, 0); // Sað göz 2
            break;
        }
    }
}


// Skor alanýný temizleyen fonksiyon
void clearScoreArea() {
   uchar startX = 65;
   uchar startY = 0;
   uchar width = 60;
   uchar height = 10;
   uchar x, y;
   for (x = startX; x < startX + width; x++) {
      for (y = startY; y < startY + height; y++) {
         glcd_pixel(x, y, 0);
      }
   }
}

// Yemi yalnýzca yýlan olmayan boþ bir gridde üretir ve çizer
void criar_comida() {
   uchar valid = 0;
   while (!valid) {
      food[0] = rand() % GRID_COLS;
      food[1] = rand() % GRID_ROWS;
      valid = 1;
      for (uchar j = 0; j < LENGTH_SNAKE; j++) {
         if (SNAKE[j][0] == food[0] && SNAKE[j][1] == food[1]) {
            valid = 0;
            break;
         }
      }
   }
   fillCell(food[0], food[1], 1);
}

void gameover() {
   LENGTH_SNAKE = 10;
   posX = 1;
   posY = 2;  // Yýlan biraz aþaðýda baþlýyor
   score = 0;
   score_txt[7] = score_txt[8] = '0';
   dir = 2;
   glcd_fillScreen(0);
   drawGrid();
   glcd_text57(25, 60, gayover, 1, 1);
   delay_ms(1000);
}

void writeScore() {
   clearScoreArea();
   glcd_text57(65, 0, score_txt, 1, 1);
}

void main() {
   glcd_init(ON);
   glcd_fillScreen(0);
   drawGrid();
   delay_ms(500);

Start:
   glcd_fillScreen(0);
   drawGrid();
   writeScore();
   criar_comida();

   // Yýlaný baþlangýçta çiz
   for (i = 0; i < LENGTH_SNAKE - 1; i++) {
      SNAKE[i][0] = posX - (LENGTH_SNAKE - 1 - i);
      SNAKE[i][1] = posY;
      fillCell(SNAKE[i][0], SNAKE[i][1], 1);
   }
   // Kafayý çiz
   SNAKE[LENGTH_SNAKE-1][0] = posX;
   SNAKE[LENGTH_SNAKE-1][1] = posY;
   drawHead(posX, posY, dir);

   while (TRUE) {
      if (input(PIN_C3) && dir != 0) dir = 3;
      if (input(PIN_C2) && dir != 1) dir = 2;
      if (input(PIN_C1) && dir != 2) dir = 1;
      if (input(PIN_C4) && dir != 3) dir = 0;
      if (input(PIN_C5)) { gameover(); goto Start; }

      // Hareket
      switch(dir) {
         case 0: if (posX == 0) { gameover(); goto Start; } else posX--; break;
         case 1: if (posY == 0) { gameover(); goto Start; } else posY--; break;
         case 2: if (posY == GRID_ROWS - 1) { gameover(); goto Start; } else posY++; break;
         case 3: if (posX == GRID_COLS - 1) { gameover(); goto Start; } else posX++; break;
      }

      uchar tailX = SNAKE[0][0], tailY = SNAKE[0][1];
      for (i = 0; i < LENGTH_SNAKE - 1; i++) {
         SNAKE[i][0] = SNAKE[i + 1][0];
         SNAKE[i][1] = SNAKE[i + 1][1];
      }
      SNAKE[LENGTH_SNAKE - 1][0] = posX;
      SNAKE[LENGTH_SNAKE - 1][1] = posY;

      // Kendine çarpma kontrolü
      for (i = 0; i < LENGTH_SNAKE - 1; i++) {
         if (SNAKE[i][0] == posX && SNAKE[i][1] == posY) {
            gameover(); goto Start;
         }
      }

      // Gövdeyi çiz
      for (i = 0; i < LENGTH_SNAKE - 1; i++) {
         fillCell(SNAKE[i][0], SNAKE[i][1], 1);
      }
      // Kafayý yönlü çiz
      drawHead(posX, posY, dir);

      // Kuyruðu sil
      fillCell(tailX, tailY, 0);

      // Yem yediyse
      if (posX == food[0] && posY == food[1]) {
         LENGTH_SNAKE++;
         if (LENGTH_SNAKE >= GRID_COLS * GRID_ROWS - 2) {
            gameover(); goto Start;
         }
         criar_comida();
         score++;
         score_txt[7] = '0' + (score / 10);
         score_txt[8] = '0' + (score % 10);
         writeScore();
      }

      delay_ms(5000 / LENGTH_SNAKE);
   }
}

