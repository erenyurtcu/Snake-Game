CCS PCM C Compiler, Version 5.025, 5967               30-May-25 16:58

               Filename:   C:\Users\Eren\Documents\CCS C Projects\snake_project\main.lst

               ROM used:   3375 words (41%)
                           Largest free fragment is 2048
               RAM used:   228 (62%) at main() level
                           274 (74%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  09
0001:  MOVWF  0A
0002:  GOTO   1DC
0003:  NOP
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDLW  0B
0008:  BTFSC  03.0
0009:  INCF   0A,F
000A:  MOVWF  02
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  5F
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  03
0017:  RETLW  00
0018:  RETLW  03
0019:  RETLW  00
001A:  RETLW  14
001B:  RETLW  3E
001C:  RETLW  14
001D:  RETLW  3E
001E:  RETLW  14
001F:  RETLW  24
0020:  RETLW  2A
0021:  RETLW  7F
0022:  RETLW  2A
0023:  RETLW  12
0024:  RETLW  43
0025:  RETLW  33
0026:  RETLW  08
0027:  RETLW  66
0028:  RETLW  61
0029:  RETLW  36
002A:  RETLW  49
002B:  RETLW  55
002C:  RETLW  22
002D:  RETLW  50
002E:  RETLW  00
002F:  RETLW  05
0030:  RETLW  03
0031:  RETLW  00
0032:  RETLW  00
0033:  RETLW  00
0034:  RETLW  1C
0035:  RETLW  22
0036:  RETLW  41
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  41
003A:  RETLW  22
003B:  RETLW  1C
003C:  RETLW  00
003D:  RETLW  14
003E:  RETLW  08
003F:  RETLW  3E
0040:  RETLW  08
0041:  RETLW  14
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  3E
0045:  RETLW  08
0046:  RETLW  08
0047:  RETLW  00
0048:  RETLW  50
0049:  RETLW  30
004A:  RETLW  00
004B:  RETLW  00
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  08
004F:  RETLW  08
0050:  RETLW  08
0051:  RETLW  00
0052:  RETLW  60
0053:  RETLW  60
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  20
0057:  RETLW  10
0058:  RETLW  08
0059:  RETLW  04
005A:  RETLW  02
005B:  RETLW  3E
005C:  RETLW  51
005D:  RETLW  49
005E:  RETLW  45
005F:  RETLW  3E
0060:  RETLW  04
0061:  RETLW  02
0062:  RETLW  7F
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  61
0067:  RETLW  51
0068:  RETLW  49
0069:  RETLW  46
006A:  RETLW  22
006B:  RETLW  41
006C:  RETLW  49
006D:  RETLW  49
006E:  RETLW  36
006F:  RETLW  18
0070:  RETLW  14
0071:  RETLW  12
0072:  RETLW  7F
0073:  RETLW  10
0074:  RETLW  27
0075:  RETLW  45
0076:  RETLW  45
0077:  RETLW  45
0078:  RETLW  39
0079:  RETLW  3E
007A:  RETLW  49
007B:  RETLW  49
007C:  RETLW  49
007D:  RETLW  32
007E:  RETLW  01
007F:  RETLW  01
0080:  RETLW  71
0081:  RETLW  09
0082:  RETLW  07
0083:  RETLW  36
0084:  RETLW  49
0085:  RETLW  49
0086:  RETLW  49
0087:  RETLW  36
0088:  RETLW  26
0089:  RETLW  49
008A:  RETLW  49
008B:  RETLW  49
008C:  RETLW  3E
008D:  RETLW  00
008E:  RETLW  36
008F:  RETLW  36
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  56
0094:  RETLW  36
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  08
0098:  RETLW  14
0099:  RETLW  22
009A:  RETLW  41
009B:  RETLW  00
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  14
009F:  RETLW  14
00A0:  RETLW  14
00A1:  RETLW  00
00A2:  RETLW  41
00A3:  RETLW  22
00A4:  RETLW  14
00A5:  RETLW  08
00A6:  RETLW  02
00A7:  RETLW  01
00A8:  RETLW  51
00A9:  RETLW  09
00AA:  RETLW  06
00AB:  RETLW  3E
00AC:  RETLW  41
00AD:  RETLW  59
00AE:  RETLW  55
00AF:  RETLW  5E
00B0:  RETLW  7E
00B1:  RETLW  09
00B2:  RETLW  09
00B3:  RETLW  09
00B4:  RETLW  7E
00B5:  RETLW  7F
00B6:  RETLW  49
00B7:  RETLW  49
00B8:  RETLW  49
00B9:  RETLW  36
00BA:  RETLW  3E
00BB:  RETLW  41
00BC:  RETLW  41
00BD:  RETLW  41
00BE:  RETLW  22
00BF:  RETLW  7F
00C0:  RETLW  41
00C1:  RETLW  41
00C2:  RETLW  41
00C3:  RETLW  3E
00C4:  RETLW  7F
00C5:  RETLW  49
00C6:  RETLW  49
00C7:  RETLW  49
00C8:  RETLW  41
00C9:  RETLW  7F
00CA:  RETLW  09
00CB:  RETLW  09
00CC:  RETLW  09
00CD:  RETLW  01
00CE:  RETLW  3E
00CF:  RETLW  41
00D0:  RETLW  41
00D1:  RETLW  49
00D2:  RETLW  3A
00D3:  RETLW  7F
00D4:  RETLW  08
00D5:  RETLW  08
00D6:  RETLW  08
00D7:  RETLW  7F
00D8:  RETLW  00
00D9:  RETLW  41
00DA:  RETLW  7F
00DB:  RETLW  41
00DC:  RETLW  00
00DD:  RETLW  30
00DE:  RETLW  40
00DF:  RETLW  40
00E0:  RETLW  40
00E1:  RETLW  3F
00E2:  RETLW  7F
00E3:  RETLW  08
00E4:  RETLW  14
00E5:  RETLW  22
00E6:  RETLW  41
00E7:  RETLW  7F
00E8:  RETLW  40
00E9:  RETLW  40
00EA:  RETLW  40
00EB:  RETLW  40
00EC:  RETLW  7F
00ED:  RETLW  02
00EE:  RETLW  0C
00EF:  RETLW  02
00F0:  RETLW  7F
00F1:  RETLW  7F
00F2:  RETLW  02
00F3:  RETLW  04
00F4:  RETLW  08
00F5:  RETLW  7F
00F6:  RETLW  3E
00F7:  RETLW  41
00F8:  RETLW  41
00F9:  RETLW  41
00FA:  RETLW  3E
00FB:  RETLW  7F
00FC:  RETLW  09
00FD:  RETLW  09
00FE:  RETLW  09
00FF:  RETLW  06
0100:  RETLW  1E
0101:  RETLW  21
0102:  RETLW  21
0103:  RETLW  21
0104:  RETLW  5E
0105:  RETLW  7F
0106:  RETLW  09
0107:  RETLW  09
0108:  RETLW  09
0109:  RETLW  76
010A:  BSF    0A.0
010B:  BCF    0A.1
010C:  BCF    0A.2
010D:  ADDWF  02,F
010E:  RETLW  26
010F:  RETLW  49
0110:  RETLW  49
0111:  RETLW  49
0112:  RETLW  32
0113:  RETLW  01
0114:  RETLW  01
0115:  RETLW  7F
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  3F
0119:  RETLW  40
011A:  RETLW  40
011B:  RETLW  40
011C:  RETLW  3F
011D:  RETLW  1F
011E:  RETLW  20
011F:  RETLW  40
0120:  RETLW  20
0121:  RETLW  1F
0122:  RETLW  7F
0123:  RETLW  20
0124:  RETLW  10
0125:  RETLW  20
0126:  RETLW  7F
0127:  RETLW  41
0128:  RETLW  22
0129:  RETLW  1C
012A:  RETLW  22
012B:  RETLW  41
012C:  RETLW  07
012D:  RETLW  08
012E:  RETLW  70
012F:  RETLW  08
0130:  RETLW  07
0131:  RETLW  61
0132:  RETLW  51
0133:  RETLW  49
0134:  RETLW  45
0135:  RETLW  43
0136:  RETLW  00
0137:  RETLW  7F
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  02
013C:  RETLW  04
013D:  RETLW  08
013E:  RETLW  10
013F:  RETLW  20
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  41
0143:  RETLW  7F
0144:  RETLW  00
0145:  RETLW  04
0146:  RETLW  02
0147:  RETLW  01
0148:  RETLW  02
0149:  RETLW  04
014A:  RETLW  40
014B:  RETLW  40
014C:  RETLW  40
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  00
0150:  RETLW  01
0151:  RETLW  02
0152:  RETLW  04
0153:  RETLW  00
0154:  RETLW  20
0155:  RETLW  54
0156:  RETLW  54
0157:  RETLW  54
0158:  RETLW  78
0159:  RETLW  7F
015A:  RETLW  44
015B:  RETLW  44
015C:  RETLW  44
015D:  RETLW  38
015E:  RETLW  38
015F:  RETLW  44
0160:  RETLW  44
0161:  RETLW  44
0162:  RETLW  44
0163:  RETLW  38
0164:  RETLW  44
0165:  RETLW  44
0166:  RETLW  44
0167:  RETLW  7F
0168:  RETLW  38
0169:  RETLW  54
016A:  RETLW  54
016B:  RETLW  54
016C:  RETLW  18
016D:  RETLW  04
016E:  RETLW  04
016F:  RETLW  7E
0170:  RETLW  05
0171:  RETLW  05
0172:  RETLW  08
0173:  RETLW  54
0174:  RETLW  54
0175:  RETLW  54
0176:  RETLW  3C
0177:  RETLW  7F
0178:  RETLW  08
0179:  RETLW  04
017A:  RETLW  04
017B:  RETLW  78
017C:  RETLW  00
017D:  RETLW  44
017E:  RETLW  7D
017F:  RETLW  40
0180:  RETLW  00
0181:  RETLW  20
0182:  RETLW  40
0183:  RETLW  44
0184:  RETLW  3D
0185:  RETLW  00
0186:  RETLW  7F
0187:  RETLW  10
0188:  RETLW  28
0189:  RETLW  44
018A:  RETLW  00
018B:  RETLW  00
018C:  RETLW  41
018D:  RETLW  7F
018E:  RETLW  40
018F:  RETLW  00
0190:  RETLW  7C
0191:  RETLW  04
0192:  RETLW  78
0193:  RETLW  04
0194:  RETLW  78
0195:  RETLW  7C
0196:  RETLW  08
0197:  RETLW  04
0198:  RETLW  04
0199:  RETLW  78
019A:  RETLW  38
019B:  RETLW  44
019C:  RETLW  44
019D:  RETLW  44
019E:  RETLW  38
019F:  RETLW  7C
01A0:  RETLW  14
01A1:  RETLW  14
01A2:  RETLW  14
01A3:  RETLW  08
01A4:  RETLW  08
01A5:  RETLW  14
01A6:  RETLW  14
01A7:  RETLW  14
01A8:  RETLW  7C
01A9:  RETLW  00
01AA:  RETLW  7C
01AB:  RETLW  08
01AC:  RETLW  04
01AD:  RETLW  04
01AE:  RETLW  48
01AF:  RETLW  54
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  20
01B3:  RETLW  04
01B4:  RETLW  04
01B5:  RETLW  3F
01B6:  RETLW  44
01B7:  RETLW  44
01B8:  RETLW  3C
01B9:  RETLW  40
01BA:  RETLW  40
01BB:  RETLW  20
01BC:  RETLW  7C
01BD:  RETLW  1C
01BE:  RETLW  20
01BF:  RETLW  40
01C0:  RETLW  20
01C1:  RETLW  1C
01C2:  RETLW  3C
01C3:  RETLW  40
01C4:  RETLW  30
01C5:  RETLW  40
01C6:  RETLW  3C
01C7:  RETLW  44
01C8:  RETLW  28
01C9:  RETLW  10
01CA:  RETLW  28
01CB:  RETLW  44
01CC:  RETLW  0C
01CD:  RETLW  50
01CE:  RETLW  50
01CF:  RETLW  50
01D0:  RETLW  3C
01D1:  RETLW  44
01D2:  RETLW  64
01D3:  RETLW  54
01D4:  RETLW  4C
01D5:  RETLW  44
01D6:  RETLW  00
01D7:  RETLW  08
01D8:  RETLW  36
01D9:  RETLW  41
01DA:  RETLW  41
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  7F
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  41
01E1:  RETLW  41
01E2:  RETLW  36
01E3:  RETLW  08
01E4:  RETLW  00
01E5:  RETLW  02
01E6:  RETLW  01
01E7:  RETLW  02
01E8:  RETLW  04
01E9:  RETLW  02
*
021C:  CLRF   77
021D:  CLRF   78
021E:  BSF    03.5
021F:  BSF    03.6
0220:  MOVF   12,W
0221:  BCF    03.0
0222:  BTFSC  13.0
0223:  ADDWF  77,F
0224:  RRF    77,F
0225:  RRF    78,F
0226:  BTFSC  13.1
0227:  ADDWF  77,F
0228:  RRF    77,F
0229:  RRF    78,F
022A:  BTFSC  13.2
022B:  ADDWF  77,F
022C:  RRF    77,F
022D:  RRF    78,F
022E:  BTFSC  13.3
022F:  ADDWF  77,F
0230:  RRF    77,F
0231:  RRF    78,F
0232:  BTFSC  13.4
0233:  ADDWF  77,F
0234:  RRF    77,F
0235:  RRF    78,F
0236:  BTFSC  13.5
0237:  ADDWF  77,F
0238:  RRF    77,F
0239:  RRF    78,F
023A:  BTFSC  13.6
023B:  ADDWF  77,F
023C:  RRF    77,F
023D:  RRF    78,F
023E:  BTFSC  13.7
023F:  ADDWF  77,F
0240:  RRF    77,F
0241:  RRF    78,F
0242:  BCF    03.5
0243:  BCF    03.6
0244:  RETURN
*
07C0:  CLRF   78
07C1:  CLRF   79
07C2:  CLRF   77
07C3:  CLRF   7A
07C4:  BSF    03.6
07C5:  MOVF   52,W
07C6:  BTFSS  03.2
07C7:  GOTO   7CB
07C8:  MOVF   51,W
07C9:  BTFSC  03.2
07CA:  GOTO   7E5
07CB:  MOVLW  10
07CC:  MOVWF  53
07CD:  BCF    03.0
07CE:  RLF    4F,F
07CF:  RLF    50,F
07D0:  RLF    77,F
07D1:  RLF    7A,F
07D2:  MOVF   52,W
07D3:  SUBWF  7A,W
07D4:  BTFSS  03.2
07D5:  GOTO   7D8
07D6:  MOVF   51,W
07D7:  SUBWF  77,W
07D8:  BTFSS  03.0
07D9:  GOTO   7E1
07DA:  MOVF   51,W
07DB:  SUBWF  77,F
07DC:  BTFSS  03.0
07DD:  DECF   7A,F
07DE:  MOVF   52,W
07DF:  SUBWF  7A,F
07E0:  BSF    03.0
07E1:  RLF    78,F
07E2:  RLF    79,F
07E3:  DECFSZ 53,F
07E4:  GOTO   7CD
07E5:  BCF    03.6
07E6:  RETURN
07E7:  BSF    03.6
07E8:  MOVF   4B,W
07E9:  CLRF   78
07EA:  SUBWF  4A,W
07EB:  BTFSC  03.0
07EC:  GOTO   7F0
07ED:  MOVF   4A,W
07EE:  MOVWF  77
07EF:  GOTO   7FC
07F0:  CLRF   77
07F1:  MOVLW  08
07F2:  MOVWF  4C
07F3:  RLF    4A,F
07F4:  RLF    77,F
07F5:  MOVF   4B,W
07F6:  SUBWF  77,W
07F7:  BTFSC  03.0
07F8:  MOVWF  77
07F9:  RLF    78,F
07FA:  DECFSZ 4C,F
07FB:  GOTO   7F3
07FC:  BCF    03.6
07FD:  RETURN
*
0817:  MOVLW  20
0818:  MOVWF  58
0819:  CLRF   54
081A:  CLRF   55
081B:  CLRF   56
081C:  CLRF   57
081D:  MOVF   4F,W
081E:  MOVWF  7A
081F:  MOVF   4E,W
0820:  MOVWF  79
0821:  MOVF   4D,W
0822:  MOVWF  78
0823:  MOVF   4C,W
0824:  MOVWF  77
0825:  BCF    03.0
0826:  BTFSS  77.0
0827:  GOTO   036
0828:  MOVF   50,W
0829:  ADDWF  54,F
082A:  MOVF   51,W
082B:  BTFSC  03.0
082C:  INCFSZ 51,W
082D:  ADDWF  55,F
082E:  MOVF   52,W
082F:  BTFSC  03.0
0830:  INCFSZ 52,W
0831:  ADDWF  56,F
0832:  MOVF   53,W
0833:  BTFSC  03.0
0834:  INCFSZ 53,W
0835:  ADDWF  57,F
0836:  RRF    57,F
0837:  RRF    56,F
0838:  RRF    55,F
0839:  RRF    54,F
083A:  RRF    7A,F
083B:  RRF    79,F
083C:  RRF    78,F
083D:  RRF    77,F
083E:  DECFSZ 58,F
083F:  GOTO   025
*
09C3:  MOVLW  10
09C4:  BSF    03.6
09C5:  MOVWF  50
09C6:  CLRF   77
09C7:  CLRF   7A
09C8:  RRF    4D,F
09C9:  RRF    4C,F
09CA:  BTFSS  03.0
09CB:  GOTO   1D2
09CC:  MOVF   4E,W
09CD:  ADDWF  77,F
09CE:  BTFSC  03.0
09CF:  INCF   7A,F
09D0:  MOVF   4F,W
09D1:  ADDWF  7A,F
09D2:  RRF    7A,F
09D3:  RRF    77,F
09D4:  RRF    79,F
09D5:  RRF    78,F
09D6:  DECFSZ 50,F
09D7:  GOTO   1C8
09D8:  BCF    03.6
09D9:  BSF    0A.3
09DA:  BCF    0A.4
09DB:  GOTO   50E (RETURN)
*
0D29:  BSF    0A.0
0D2A:  BCF    0A.1
0D2B:  BSF    0A.2
0D2C:  ADDWF  02,F
0D2D:  GOTO   349
0D2E:  GOTO   355
0D2F:  GOTO   361
0D30:  GOTO   36E
....................  
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=16000000) 
*
0338:  MOVLW  5D
0339:  MOVWF  04
033A:  BSF    03.7
033B:  MOVF   00,W
033C:  BTFSC  03.2
033D:  GOTO   34C
033E:  MOVLW  05
033F:  MOVWF  78
0340:  CLRF   77
0341:  DECFSZ 77,F
0342:  GOTO   341
0343:  DECFSZ 78,F
0344:  GOTO   340
0345:  MOVLW  2E
0346:  MOVWF  77
0347:  DECFSZ 77,F
0348:  GOTO   347
0349:  GOTO   34A
034A:  DECFSZ 00,F
034B:  GOTO   33E
034C:  RETURN
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
09F4:  BCF    03.5
09F5:  CLRF   20
09F6:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
0800:  MOVF   25,W
0801:  BSF    03.6
0802:  MOVWF  4F
0803:  BCF    03.6
0804:  MOVF   24,W
0805:  BSF    03.6
0806:  MOVWF  4E
0807:  BCF    03.6
0808:  MOVF   23,W
0809:  BSF    03.6
080A:  MOVWF  4D
080B:  BCF    03.6
080C:  MOVF   22,W
080D:  BSF    03.6
080E:  MOVWF  4C
080F:  MOVLW  41
0810:  MOVWF  53
0811:  MOVLW  C6
0812:  MOVWF  52
0813:  MOVLW  4E
0814:  MOVWF  51
0815:  MOVLW  6D
0816:  MOVWF  50
*
0840:  MOVF   7A,W
0841:  MOVWF  4F
0842:  MOVF   79,W
0843:  MOVWF  4E
0844:  MOVF   78,W
0845:  MOVWF  4D
0846:  MOVF   77,W
0847:  MOVWF  4C
0848:  MOVLW  39
0849:  ADDWF  4C,W
084A:  BCF    03.6
084B:  MOVWF  22
084C:  BSF    03.6
084D:  MOVF   4D,W
084E:  BCF    03.6
084F:  MOVWF  23
0850:  MOVLW  30
0851:  BTFSC  03.0
0852:  MOVLW  31
0853:  ADDWF  23,F
0854:  BSF    03.6
0855:  MOVF   4E,W
0856:  BCF    03.6
0857:  MOVWF  24
0858:  MOVLW  00
0859:  BTFSC  03.0
085A:  MOVLW  01
085B:  ADDWF  24,F
085C:  BSF    03.6
085D:  MOVF   4F,W
085E:  BCF    03.6
085F:  MOVWF  25
0860:  MOVLW  00
0861:  BTFSC  03.0
0862:  MOVLW  01
0863:  ADDWF  25,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0864:  MOVF   24,W
0865:  MOVWF  77
0866:  MOVF   25,W
0867:  MOVWF  78
0868:  CLRF   79
0869:  CLRF   7A
086A:  MOVF   25,W
086B:  BSF    03.6
086C:  MOVWF  4E
086D:  MOVF   77,W
086E:  MOVWF  4D
086F:  MOVF   4E,W
0870:  MOVWF  50
0871:  MOVF   4D,W
0872:  MOVWF  4F
0873:  MOVLW  7F
0874:  MOVWF  52
0875:  MOVLW  FF
0876:  MOVWF  51
0877:  BCF    0A.3
0878:  BCF    03.6
0879:  CALL   7C0
087A:  BSF    0A.3
087B:  MOVF   77,W
087C:  MOVWF  78
087D:  MOVF   7A,W
087E:  MOVWF  79
087F:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <glcd.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
02BE:  BCF    26.0
02BF:  MOVF   26,W
02C0:  BSF    03.5
02C1:  MOVWF  07
02C2:  BCF    03.5
02C3:  BSF    07.0
....................    output_low(GLCD_E); 
02C4:  BSF    03.5
02C5:  BCF    06.5
02C6:  BCF    03.5
02C7:  BCF    06.5
....................    output_low(GLCD_CS1); 
02C8:  BSF    03.5
02C9:  BCF    06.0
02CA:  BCF    03.5
02CB:  BCF    06.0
....................    output_low(GLCD_CS2); 
02CC:  BSF    03.5
02CD:  BCF    06.1
02CE:  BCF    03.5
02CF:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
02D0:  BSF    03.5
02D1:  BCF    06.2
02D2:  BCF    03.5
02D3:  BCF    06.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
02D4:  MOVLW  30
02D5:  BSF    03.5
02D6:  BSF    03.6
02D7:  MOVWF  18
02D8:  MOVLW  C0
02D9:  MOVWF  19
02DA:  BCF    03.5
02DB:  BCF    03.6
02DC:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
02DD:  MOVLW  31
02DE:  BSF    03.5
02DF:  BSF    03.6
02E0:  MOVWF  18
02E1:  MOVLW  C0
02E2:  MOVWF  19
02E3:  BCF    03.5
02E4:  BCF    03.6
02E5:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
02E6:  MOVLW  30
02E7:  BSF    03.5
02E8:  BSF    03.6
02E9:  MOVWF  18
02EA:  MOVLW  40
02EB:  MOVWF  19
02EC:  BCF    03.5
02ED:  BCF    03.6
02EE:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0x40); 
02EF:  MOVLW  31
02F0:  BSF    03.5
02F1:  BSF    03.6
02F2:  MOVWF  18
02F3:  MOVLW  40
02F4:  MOVWF  19
02F5:  BCF    03.5
02F6:  BCF    03.6
02F7:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
02F8:  MOVLW  30
02F9:  BSF    03.5
02FA:  BSF    03.6
02FB:  MOVWF  18
02FC:  MOVLW  B8
02FD:  MOVWF  19
02FE:  BCF    03.5
02FF:  BCF    03.6
0300:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
0301:  MOVLW  31
0302:  BSF    03.5
0303:  BSF    03.6
0304:  MOVWF  18
0305:  MOVLW  B8
0306:  MOVWF  19
0307:  BCF    03.5
0308:  BCF    03.6
0309:  CALL   1EA
....................    if(mode == ON) 
030A:  BSF    03.6
030B:  DECFSZ 4A,W
030C:  GOTO   320
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
030D:  MOVLW  30
030E:  BSF    03.5
030F:  MOVWF  18
0310:  MOVLW  3F
0311:  MOVWF  19
0312:  BCF    03.5
0313:  BCF    03.6
0314:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
0315:  MOVLW  31
0316:  BSF    03.5
0317:  BSF    03.6
0318:  MOVWF  18
0319:  MOVLW  3F
031A:  MOVWF  19
031B:  BCF    03.5
031C:  BCF    03.6
031D:  CALL   1EA
....................    } 
031E:  GOTO   331
031F:  BSF    03.6
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
0320:  MOVLW  30
0321:  BSF    03.5
0322:  MOVWF  18
0323:  MOVLW  3E
0324:  MOVWF  19
0325:  BCF    03.5
0326:  BCF    03.6
0327:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
0328:  MOVLW  31
0329:  BSF    03.5
032A:  BSF    03.6
032B:  MOVWF  18
032C:  MOVLW  3E
032D:  MOVWF  19
032E:  BCF    03.5
032F:  BCF    03.6
0330:  CALL   1EA
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
0331:  BSF    03.6
0332:  CLRF   5C
0333:  BCF    03.6
0334:  CALL   245
0335:  BSF    0A.3
0336:  BCF    0A.4
0337:  GOTO   280 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
*
034D:  MOVLW  30
034E:  BSF    03.5
034F:  BSF    03.6
0350:  MOVWF  16
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
0351:  MOVF   12,W
0352:  SUBLW  3F
0353:  BTFSC  03.0
0354:  GOTO   359
....................    { 
....................       x -= 64; 
0355:  MOVLW  40
0356:  SUBWF  12,F
....................       chip = GLCD_CS2; 
0357:  MOVLW  31
0358:  MOVWF  16
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
0359:  BCF    03.6
035A:  BCF    06.2
035B:  BCF    03.5
035C:  BCF    06.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
035D:  BSF    03.5
035E:  BSF    03.6
035F:  BCF    12.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
0360:  BSF    12.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
0361:  MOVF   16,W
0362:  MOVWF  18
0363:  MOVF   12,W
0364:  MOVWF  19
0365:  BCF    03.5
0366:  BCF    03.6
0367:  CALL   1EA
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
0368:  BSF    03.5
0369:  BSF    03.6
036A:  RRF    13,W
036B:  MOVWF  77
036C:  RRF    77,F
036D:  RRF    77,F
036E:  MOVLW  1F
036F:  ANDWF  77,F
0370:  MOVF   77,W
0371:  ANDLW  BF
0372:  IORLW  B8
0373:  MOVWF  17
0374:  MOVF   16,W
0375:  MOVWF  18
0376:  MOVF   17,W
0377:  MOVWF  19
0378:  BCF    03.5
0379:  BCF    03.6
037A:  CALL   1EA
....................    output_high(GLCD_DI);                                    // Set for data 
037B:  BSF    03.5
037C:  BCF    06.2
037D:  BCF    03.5
037E:  BSF    06.2
....................    data = glcd_readByte(chip); 
037F:  BSF    03.5
0380:  BSF    03.6
0381:  MOVF   16,W
0382:  MOVWF  17
*
03CB:  MOVF   78,W
03CC:  MOVWF  15
....................  
....................    if(color == ON) 
03CD:  DECFSZ 14,W
03CE:  GOTO   3DF
....................       bit_set(data, y%8);        // Turn the pixel on 
03CF:  MOVF   13,W
03D0:  ANDLW  07
03D1:  MOVWF  17
03D2:  MOVLW  01
03D3:  MOVWF  77
03D4:  MOVF   17,W
03D5:  MOVWF  78
03D6:  BTFSC  03.2
03D7:  GOTO   3DC
03D8:  BCF    03.0
03D9:  RLF    77,F
03DA:  DECFSZ 78,F
03DB:  GOTO   3D8
03DC:  MOVF   77,W
03DD:  IORWF  15,F
03DE:  GOTO   3EF
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
03DF:  MOVF   13,W
03E0:  ANDLW  07
03E1:  MOVWF  17
03E2:  MOVLW  01
03E3:  MOVWF  77
03E4:  MOVF   17,W
03E5:  MOVWF  78
03E6:  BTFSC  03.2
03E7:  GOTO   3EC
03E8:  BCF    03.0
03E9:  RLF    77,F
03EA:  DECFSZ 78,F
03EB:  GOTO   3E8
03EC:  MOVF   77,W
03ED:  XORLW  FF
03EE:  ANDWF  15,F
....................    output_low(GLCD_DI);          // Set for instruction 
03EF:  BCF    03.6
03F0:  BCF    06.2
03F1:  BCF    03.5
03F2:  BCF    06.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
03F3:  BSF    03.5
03F4:  BSF    03.6
03F5:  MOVF   16,W
03F6:  MOVWF  18
03F7:  MOVF   12,W
03F8:  MOVWF  19
03F9:  BCF    03.5
03FA:  BCF    03.6
03FB:  CALL   1EA
....................    output_high(GLCD_DI);         // Set for data 
03FC:  BSF    03.5
03FD:  BCF    06.2
03FE:  BCF    03.5
03FF:  BSF    06.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
0400:  BSF    03.5
0401:  BSF    03.6
0402:  MOVF   16,W
0403:  MOVWF  18
0404:  MOVF   15,W
0405:  MOVWF  19
0406:  BCF    03.5
0407:  BCF    03.6
0408:  CALL   1EA
0409:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
*
063B:  BSF    03.6
063C:  MOVF   4E,W
063D:  SUBWF  50,W
063E:  MOVWF  5C
063F:  MOVF   5C,W
0640:  BTFSS  5C.7
0641:  GOTO   644
0642:  MOVF   5C,W
0643:  SUBLW  00
0644:  MOVWF  57
....................    dy = abs((signed int)(y2 - y1)); 
0645:  MOVF   4F,W
0646:  SUBWF  51,W
0647:  MOVWF  5C
0648:  MOVF   5C,W
0649:  BTFSS  5C.7
064A:  GOTO   64D
064B:  MOVF   5C,W
064C:  SUBLW  00
064D:  MOVWF  58
....................    x = x1; 
064E:  MOVF   4E,W
064F:  MOVWF  53
....................    y = y1; 
0650:  MOVF   4F,W
0651:  MOVWF  54
....................  
....................    if(x1 > x2) 
0652:  MOVF   4E,W
0653:  SUBWF  50,W
0654:  BTFSC  03.0
0655:  GOTO   659
....................       addx = -1; 
0656:  MOVLW  FF
0657:  MOVWF  55
0658:  GOTO   65B
....................    else 
....................       addx = 1; 
0659:  MOVLW  01
065A:  MOVWF  55
....................    if(y1 > y2) 
065B:  MOVF   4F,W
065C:  SUBWF  51,W
065D:  BTFSC  03.0
065E:  GOTO   662
....................       addy = -1; 
065F:  MOVLW  FF
0660:  MOVWF  56
0661:  GOTO   664
....................    else 
....................       addy = 1; 
0662:  MOVLW  01
0663:  MOVWF  56
....................  
....................    if(dx >= dy) 
0664:  MOVF   58,W
0665:  XORLW  80
0666:  MOVWF  77
0667:  MOVF   57,W
0668:  XORLW  80
0669:  SUBWF  77,W
066A:  BTFSC  03.2
066B:  GOTO   66E
066C:  BTFSC  03.0
066D:  GOTO   6DC
....................    { 
....................       P = 2*dy - dx; 
066E:  MOVLW  02
066F:  BSF    03.5
0670:  MOVWF  12
0671:  BCF    03.5
0672:  MOVF   58,W
0673:  BSF    03.5
0674:  MOVWF  13
0675:  BCF    03.5
0676:  BCF    03.6
0677:  CALL   21C
0678:  BSF    03.6
0679:  MOVF   57,W
067A:  SUBWF  78,W
067B:  CLRF   7A
067C:  MOVWF  77
067D:  BTFSC  77.7
067E:  DECF   7A,F
067F:  MOVWF  59
0680:  MOVF   7A,W
0681:  MOVWF  5A
....................  
....................       for(i=0; i<=dx; ++i) 
0682:  CLRF   5B
0683:  BTFSC  57.7
0684:  GOTO   6DB
0685:  MOVF   5B,W
0686:  SUBWF  57,W
0687:  BTFSS  03.0
0688:  GOTO   6DB
....................       { 
....................          glcd_pixel(x, y, color); 
0689:  MOVF   53,W
068A:  BSF    03.5
068B:  MOVWF  12
068C:  BCF    03.5
068D:  MOVF   54,W
068E:  BSF    03.5
068F:  MOVWF  13
0690:  BCF    03.5
0691:  MOVF   52,W
0692:  BSF    03.5
0693:  MOVWF  14
0694:  BCF    03.5
0695:  BCF    03.6
0696:  CALL   34D
....................  
....................          if(P < 0) 
0697:  BSF    03.6
0698:  BTFSS  5A.7
0699:  GOTO   6B2
....................          { 
....................             P += 2*dy; 
069A:  MOVLW  02
069B:  BSF    03.5
069C:  MOVWF  12
069D:  BCF    03.5
069E:  MOVF   58,W
069F:  BSF    03.5
06A0:  MOVWF  13
06A1:  BCF    03.5
06A2:  BCF    03.6
06A3:  CALL   21C
06A4:  MOVF   78,W
06A5:  CLRF   7A
06A6:  MOVWF  77
06A7:  BTFSC  77.7
06A8:  DECF   7A,F
06A9:  BSF    03.6
06AA:  ADDWF  59,F
06AB:  MOVF   7A,W
06AC:  BTFSC  03.0
06AD:  INCFSZ 7A,W
06AE:  ADDWF  5A,F
....................             x += addx; 
06AF:  MOVF   55,W
06B0:  ADDWF  53,F
....................          } 
06B1:  GOTO   6D9
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
06B2:  MOVLW  02
06B3:  BSF    03.5
06B4:  MOVWF  12
06B5:  BCF    03.5
06B6:  MOVF   58,W
06B7:  BSF    03.5
06B8:  MOVWF  13
06B9:  BCF    03.5
06BA:  BCF    03.6
06BB:  CALL   21C
06BC:  MOVF   78,W
06BD:  BSF    03.6
06BE:  MOVWF  5C
06BF:  MOVLW  02
06C0:  BSF    03.5
06C1:  MOVWF  12
06C2:  BCF    03.5
06C3:  MOVF   57,W
06C4:  BSF    03.5
06C5:  MOVWF  13
06C6:  BCF    03.5
06C7:  BCF    03.6
06C8:  CALL   21C
06C9:  MOVF   78,W
06CA:  BSF    03.6
06CB:  SUBWF  5C,W
06CC:  CLRF   7A
06CD:  MOVWF  77
06CE:  BTFSC  77.7
06CF:  DECF   7A,F
06D0:  ADDWF  59,F
06D1:  MOVF   7A,W
06D2:  BTFSC  03.0
06D3:  INCFSZ 7A,W
06D4:  ADDWF  5A,F
....................             x += addx; 
06D5:  MOVF   55,W
06D6:  ADDWF  53,F
....................             y += addy; 
06D7:  MOVF   56,W
06D8:  ADDWF  54,F
....................          } 
06D9:  INCF   5B,F
06DA:  GOTO   683
....................       } 
....................    } 
06DB:  GOTO   749
....................    else 
....................    { 
....................       P = 2*dx - dy; 
06DC:  MOVLW  02
06DD:  BSF    03.5
06DE:  MOVWF  12
06DF:  BCF    03.5
06E0:  MOVF   57,W
06E1:  BSF    03.5
06E2:  MOVWF  13
06E3:  BCF    03.5
06E4:  BCF    03.6
06E5:  CALL   21C
06E6:  BSF    03.6
06E7:  MOVF   58,W
06E8:  SUBWF  78,W
06E9:  CLRF   7A
06EA:  MOVWF  77
06EB:  BTFSC  77.7
06EC:  DECF   7A,F
06ED:  MOVWF  59
06EE:  MOVF   7A,W
06EF:  MOVWF  5A
....................  
....................       for(i=0; i<=dy; ++i) 
06F0:  CLRF   5B
06F1:  BTFSC  58.7
06F2:  GOTO   749
06F3:  MOVF   5B,W
06F4:  SUBWF  58,W
06F5:  BTFSS  03.0
06F6:  GOTO   749
....................       { 
....................          glcd_pixel(x, y, color); 
06F7:  MOVF   53,W
06F8:  BSF    03.5
06F9:  MOVWF  12
06FA:  BCF    03.5
06FB:  MOVF   54,W
06FC:  BSF    03.5
06FD:  MOVWF  13
06FE:  BCF    03.5
06FF:  MOVF   52,W
0700:  BSF    03.5
0701:  MOVWF  14
0702:  BCF    03.5
0703:  BCF    03.6
0704:  CALL   34D
....................  
....................          if(P < 0) 
0705:  BSF    03.6
0706:  BTFSS  5A.7
0707:  GOTO   720
....................          { 
....................             P += 2*dx; 
0708:  MOVLW  02
0709:  BSF    03.5
070A:  MOVWF  12
070B:  BCF    03.5
070C:  MOVF   57,W
070D:  BSF    03.5
070E:  MOVWF  13
070F:  BCF    03.5
0710:  BCF    03.6
0711:  CALL   21C
0712:  MOVF   78,W
0713:  CLRF   7A
0714:  MOVWF  77
0715:  BTFSC  77.7
0716:  DECF   7A,F
0717:  BSF    03.6
0718:  ADDWF  59,F
0719:  MOVF   7A,W
071A:  BTFSC  03.0
071B:  INCFSZ 7A,W
071C:  ADDWF  5A,F
....................             y += addy; 
071D:  MOVF   56,W
071E:  ADDWF  54,F
....................          } 
071F:  GOTO   747
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
0720:  MOVLW  02
0721:  BSF    03.5
0722:  MOVWF  12
0723:  BCF    03.5
0724:  MOVF   57,W
0725:  BSF    03.5
0726:  MOVWF  13
0727:  BCF    03.5
0728:  BCF    03.6
0729:  CALL   21C
072A:  MOVF   78,W
072B:  BSF    03.6
072C:  MOVWF  5C
072D:  MOVLW  02
072E:  BSF    03.5
072F:  MOVWF  12
0730:  BCF    03.5
0731:  MOVF   58,W
0732:  BSF    03.5
0733:  MOVWF  13
0734:  BCF    03.5
0735:  BCF    03.6
0736:  CALL   21C
0737:  MOVF   78,W
0738:  BSF    03.6
0739:  SUBWF  5C,W
073A:  CLRF   7A
073B:  MOVWF  77
073C:  BTFSC  77.7
073D:  DECF   7A,F
073E:  ADDWF  59,F
073F:  MOVF   7A,W
0740:  BTFSC  03.0
0741:  INCFSZ 7A,W
0742:  ADDWF  5A,F
....................             x += addx; 
0743:  MOVF   55,W
0744:  ADDWF  53,F
....................             y += addy; 
0745:  MOVF   56,W
0746:  ADDWF  54,F
....................          } 
0747:  INCF   5B,F
0748:  GOTO   6F1
....................       } 
....................    } 
0749:  BCF    03.6
074A:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
*
040A:  BSF    03.6
040B:  CLRF   65
040C:  MOVF   65,W
040D:  ADDWF  61,W
040E:  MOVWF  04
040F:  BCF    03.7
0410:  BTFSC  62.0
0411:  BSF    03.7
0412:  MOVF   00,F
0413:  BTFSC  03.2
0414:  GOTO   501
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
0415:  MOVF   65,W
0416:  ADDWF  61,W
0417:  MOVWF  04
0418:  BCF    03.7
0419:  BTFSC  62.0
041A:  BSF    03.7
041B:  MOVF   00,W
041C:  SUBLW  52
041D:  BTFSS  03.0
041E:  GOTO   448
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
041F:  MOVF   65,W
0420:  ADDWF  61,W
0421:  MOVWF  04
0422:  BCF    03.7
0423:  BTFSC  62.0
0424:  BSF    03.7
0425:  MOVLW  20
0426:  SUBWF  00,W
0427:  BSF    03.5
0428:  MOVWF  11
0429:  MOVWF  12
042A:  MOVLW  05
042B:  MOVWF  13
042C:  BCF    03.5
042D:  BCF    03.6
042E:  CALL   21C
042F:  MOVF   78,W
0430:  BSF    03.5
0431:  BSF    03.6
0432:  MOVWF  10
0433:  MOVWF  78
0434:  MOVLW  05
0435:  MOVWF  77
0436:  MOVLW  6A
0437:  MOVWF  04
0438:  BSF    03.7
0439:  MOVF   78,W
043A:  BCF    03.5
043B:  BCF    03.6
043C:  CALL   004
043D:  MOVWF  00
043E:  INCF   78,F
043F:  INCF   04,F
0440:  DECFSZ 77,F
0441:  GOTO   443
0442:  GOTO   446
0443:  BSF    03.5
0444:  BSF    03.6
0445:  GOTO   439
0446:  GOTO   481
0447:  BSF    03.6
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
0448:  MOVF   65,W
0449:  ADDWF  61,W
044A:  MOVWF  04
044B:  BCF    03.7
044C:  BTFSC  62.0
044D:  BSF    03.7
044E:  MOVF   00,W
044F:  SUBLW  7E
0450:  BTFSS  03.0
0451:  GOTO   47B
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
0452:  MOVF   65,W
0453:  ADDWF  61,W
0454:  MOVWF  04
0455:  BCF    03.7
0456:  BTFSC  62.0
0457:  BSF    03.7
0458:  MOVLW  53
0459:  SUBWF  00,W
045A:  BSF    03.5
045B:  MOVWF  11
045C:  MOVWF  12
045D:  MOVLW  05
045E:  MOVWF  13
045F:  BCF    03.5
0460:  BCF    03.6
0461:  CALL   21C
0462:  MOVF   78,W
0463:  BSF    03.5
0464:  BSF    03.6
0465:  MOVWF  10
0466:  MOVWF  78
0467:  MOVLW  05
0468:  MOVWF  77
0469:  MOVLW  6A
046A:  MOVWF  04
046B:  BSF    03.7
046C:  MOVF   78,W
046D:  BCF    03.5
046E:  BCF    03.6
046F:  CALL   10A
0470:  MOVWF  00
0471:  INCF   78,F
0472:  INCF   04,F
0473:  DECFSZ 77,F
0474:  GOTO   476
0475:  GOTO   479
0476:  BSF    03.5
0477:  BSF    03.6
0478:  GOTO   46C
0479:  GOTO   481
047A:  BSF    03.6
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
047B:  CLRF   6A
047C:  CLRF   6B
047D:  CLRF   6C
047E:  CLRF   6D
047F:  CLRF   6E
0480:  BCF    03.6
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
0481:  MOVLW  05
0482:  BSF    03.5
0483:  BSF    03.6
0484:  MOVWF  12
0485:  BCF    03.5
0486:  MOVF   63,W
0487:  BSF    03.5
0488:  MOVWF  13
0489:  BCF    03.5
048A:  BCF    03.6
048B:  CALL   21C
048C:  MOVF   78,W
048D:  BSF    03.6
048E:  ADDWF  5F,W
048F:  SUBLW  7F
0490:  BTFSC  03.0
0491:  GOTO   4A1
....................       { 
....................          x = 0;                           // Set x at far left position 
0492:  CLRF   5F
....................          y += 7*size + 1;                 // Set y at next position down 
0493:  MOVLW  07
0494:  BSF    03.5
0495:  MOVWF  12
0496:  BCF    03.5
0497:  MOVF   63,W
0498:  BSF    03.5
0499:  MOVWF  13
049A:  BCF    03.5
049B:  BCF    03.6
049C:  CALL   21C
049D:  MOVLW  01
049E:  ADDWF  78,W
049F:  BSF    03.6
04A0:  ADDWF  60,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
04A1:  CLRF   66
04A2:  MOVF   66,W
04A3:  SUBLW  04
04A4:  BTFSS  03.0
04A5:  GOTO   4FE
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
04A6:  CLRF   67
04A7:  MOVLW  07
04A8:  BSF    03.5
04A9:  MOVWF  12
04AA:  BCF    03.5
04AB:  MOVF   63,W
04AC:  BSF    03.5
04AD:  MOVWF  13
04AE:  BCF    03.5
04AF:  BCF    03.6
04B0:  CALL   21C
04B1:  MOVF   78,W
04B2:  BSF    03.6
04B3:  SUBWF  67,W
04B4:  BTFSC  03.0
04B5:  GOTO   4FA
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
04B6:  MOVLW  6A
04B7:  ADDWF  66,W
04B8:  MOVWF  04
04B9:  BSF    03.7
04BA:  MOVF   00,W
04BB:  BSF    03.5
04BC:  MOVWF  10
04BD:  MOVWF  77
04BE:  BCF    03.5
04BF:  MOVF   67,W
04C0:  MOVWF  78
04C1:  BTFSC  03.2
04C2:  GOTO   4C7
04C3:  BCF    03.0
04C4:  RRF    77,F
04C5:  DECFSZ 78,F
04C6:  GOTO   4C3
04C7:  BTFSS  77.0
04C8:  GOTO   4F8
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
04C9:  CLRF   68
04CA:  MOVF   63,W
04CB:  SUBWF  68,W
04CC:  BTFSC  03.0
04CD:  GOTO   4F8
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
04CE:  CLRF   69
04CF:  MOVF   63,W
04D0:  SUBWF  69,W
04D1:  BTFSC  03.0
04D2:  GOTO   4F6
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
04D3:  MOVF   69,W
04D4:  ADDWF  5F,W
04D5:  BSF    03.5
04D6:  MOVWF  10
04D7:  BCF    03.5
04D8:  MOVF   67,W
04D9:  BSF    03.5
04DA:  MOVWF  12
04DB:  BCF    03.5
04DC:  MOVF   63,W
04DD:  BSF    03.5
04DE:  MOVWF  13
04DF:  BCF    03.5
04E0:  BCF    03.6
04E1:  CALL   21C
04E2:  MOVF   78,W
04E3:  BSF    03.6
04E4:  ADDWF  60,W
04E5:  ADDWF  68,W
04E6:  BSF    03.5
04E7:  MOVWF  11
04E8:  MOVF   10,W
04E9:  MOVWF  12
04EA:  MOVF   11,W
04EB:  MOVWF  13
04EC:  BCF    03.5
04ED:  MOVF   64,W
04EE:  BSF    03.5
04EF:  MOVWF  14
04F0:  BCF    03.5
04F1:  BCF    03.6
04F2:  CALL   34D
04F3:  BSF    03.6
04F4:  INCF   69,F
04F5:  GOTO   4CF
....................                   } 
04F6:  INCF   68,F
04F7:  GOTO   4CA
....................                } 
....................             } 
04F8:  INCF   67,F
04F9:  GOTO   4A7
....................          } 
04FA:  INCF   66,F
04FB:  MOVF   63,W
04FC:  ADDWF  5F,F
04FD:  GOTO   4A2
....................       } 
04FE:  INCF   65,F
04FF:  INCF   5F,F
0500:  GOTO   40C
....................    } 
0501:  BCF    03.6
0502:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0245:  BSF    03.6
0246:  CLRF   5D
0247:  MOVF   5D,W
0248:  SUBLW  07
0249:  BTFSS  03.0
024A:  GOTO   2BC
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
024B:  BSF    03.5
024C:  BCF    03.6
024D:  BCF    06.2
024E:  BCF    03.5
024F:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0250:  MOVLW  30
0251:  BSF    03.5
0252:  BSF    03.6
0253:  MOVWF  18
0254:  MOVLW  40
0255:  MOVWF  19
0256:  BCF    03.5
0257:  BCF    03.6
0258:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
0259:  MOVLW  31
025A:  BSF    03.5
025B:  BSF    03.6
025C:  MOVWF  18
025D:  MOVLW  40
025E:  MOVWF  19
025F:  BCF    03.5
0260:  BCF    03.6
0261:  CALL   1EA
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
0262:  BSF    03.6
0263:  MOVF   5D,W
0264:  IORLW  B8
0265:  MOVWF  5F
0266:  MOVLW  30
0267:  BSF    03.5
0268:  MOVWF  18
0269:  BCF    03.5
026A:  MOVF   5F,W
026B:  BSF    03.5
026C:  MOVWF  19
026D:  BCF    03.5
026E:  BCF    03.6
026F:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
0270:  BSF    03.6
0271:  MOVF   5D,W
0272:  IORLW  B8
0273:  MOVWF  5F
0274:  MOVLW  31
0275:  BSF    03.5
0276:  MOVWF  18
0277:  BCF    03.5
0278:  MOVF   5F,W
0279:  BSF    03.5
027A:  MOVWF  19
027B:  BCF    03.5
027C:  BCF    03.6
027D:  CALL   1EA
....................       output_high(GLCD_DI);                     // Set for data 
027E:  BSF    03.5
027F:  BCF    06.2
0280:  BCF    03.5
0281:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
0282:  BSF    03.6
0283:  CLRF   5E
0284:  MOVF   5E,W
0285:  SUBLW  3F
0286:  BTFSS  03.0
0287:  GOTO   2BA
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0288:  MOVLW  FF
0289:  BSF    03.5
028A:  MOVWF  12
028B:  BCF    03.5
028C:  MOVF   5C,W
028D:  BSF    03.5
028E:  MOVWF  13
028F:  BCF    03.5
0290:  BCF    03.6
0291:  CALL   21C
0292:  MOVF   78,W
0293:  BSF    03.6
0294:  MOVWF  5F
0295:  MOVLW  30
0296:  BSF    03.5
0297:  MOVWF  18
0298:  BCF    03.5
0299:  MOVF   5F,W
029A:  BSF    03.5
029B:  MOVWF  19
029C:  BCF    03.5
029D:  BCF    03.6
029E:  CALL   1EA
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
029F:  MOVLW  FF
02A0:  BSF    03.5
02A1:  BSF    03.6
02A2:  MOVWF  12
02A3:  BCF    03.5
02A4:  MOVF   5C,W
02A5:  BSF    03.5
02A6:  MOVWF  13
02A7:  BCF    03.5
02A8:  BCF    03.6
02A9:  CALL   21C
02AA:  MOVF   78,W
02AB:  BSF    03.6
02AC:  MOVWF  5F
02AD:  MOVLW  31
02AE:  BSF    03.5
02AF:  MOVWF  18
02B0:  BCF    03.5
02B1:  MOVF   5F,W
02B2:  BSF    03.5
02B3:  MOVWF  19
02B4:  BCF    03.5
02B5:  BCF    03.6
02B6:  CALL   1EA
02B7:  BSF    03.6
02B8:  INCF   5E,F
02B9:  GOTO   284
....................       } 
02BA:  INCF   5D,F
02BB:  GOTO   247
....................    } 
02BC:  BCF    03.6
02BD:  RETURN
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
01EA:  BSF    03.5
01EB:  BSF    03.6
01EC:  MOVF   18,W
01ED:  SUBLW  30
01EE:  BTFSS  03.2
01EF:  GOTO   1F7
....................       output_high(GLCD_CS1); 
01F0:  BCF    03.6
01F1:  BCF    06.0
01F2:  BCF    03.5
01F3:  BSF    06.0
01F4:  GOTO   1FB
01F5:  BSF    03.5
01F6:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS2); 
01F7:  BCF    03.6
01F8:  BCF    06.1
01F9:  BCF    03.5
01FA:  BSF    06.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
01FB:  BSF    03.5
01FC:  BCF    06.4
01FD:  BCF    03.5
01FE:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
01FF:  BSF    03.5
0200:  CLRF   08
0201:  BSF    03.6
0202:  MOVF   19,W
0203:  BCF    03.5
0204:  BCF    03.6
0205:  MOVWF  08
....................    output_high(GLCD_E);       // Pulse the enable pin 
0206:  BSF    03.5
0207:  BCF    06.5
0208:  BCF    03.5
0209:  BSF    06.5
....................    delay_us(2); 
020A:  MOVLW  02
020B:  MOVWF  77
020C:  DECFSZ 77,F
020D:  GOTO   20C
020E:  NOP
....................    output_low(GLCD_E); 
020F:  BSF    03.5
0210:  BCF    06.5
0211:  BCF    03.5
0212:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0213:  BSF    03.5
0214:  BCF    06.0
0215:  BCF    03.5
0216:  BCF    06.0
....................    output_low(GLCD_CS2); 
0217:  BSF    03.5
0218:  BCF    06.1
0219:  BCF    03.5
021A:  BCF    06.1
021B:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
0383:  MOVF   17,W
0384:  SUBLW  30
0385:  BTFSS  03.2
0386:  GOTO   38E
....................       output_high(GLCD_CS1); 
0387:  BCF    03.6
0388:  BCF    06.0
0389:  BCF    03.5
038A:  BSF    06.0
038B:  GOTO   392
038C:  BSF    03.5
038D:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS2); 
038E:  BCF    03.6
038F:  BCF    06.1
0390:  BCF    03.5
0391:  BSF    06.1
....................  
....................    input_d();                 // Set port d to input 
0392:  MOVLW  FF
0393:  BSF    03.5
0394:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
0395:  BCF    06.4
0396:  BCF    03.5
0397:  BSF    06.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
0398:  BSF    03.5
0399:  BCF    06.5
039A:  BCF    03.5
039B:  BSF    06.5
....................    delay_us(2); 
039C:  MOVLW  02
039D:  MOVWF  77
039E:  DECFSZ 77,F
039F:  GOTO   39E
03A0:  NOP
....................    output_low(GLCD_E); 
03A1:  BSF    03.5
03A2:  BCF    06.5
03A3:  BCF    03.5
03A4:  BCF    06.5
....................    delay_us(2); 
03A5:  MOVLW  02
03A6:  MOVWF  77
03A7:  DECFSZ 77,F
03A8:  GOTO   3A7
03A9:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
03AA:  BSF    03.5
03AB:  BCF    06.5
03AC:  BCF    03.5
03AD:  BSF    06.5
....................    delay_us(2); 
03AE:  MOVLW  02
03AF:  MOVWF  77
03B0:  DECFSZ 77,F
03B1:  GOTO   3B0
03B2:  NOP
....................    data = input_d();          // Get the data from the display's output register 
03B3:  MOVLW  FF
03B4:  BSF    03.5
03B5:  MOVWF  08
03B6:  BCF    03.5
03B7:  MOVF   08,W
03B8:  BSF    03.5
03B9:  BSF    03.6
03BA:  MOVWF  18
....................    output_low(GLCD_E); 
03BB:  BCF    03.6
03BC:  BCF    06.5
03BD:  BCF    03.5
03BE:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
03BF:  BSF    03.5
03C0:  BCF    06.0
03C1:  BCF    03.5
03C2:  BCF    06.0
....................    output_low(GLCD_CS2); 
03C3:  BSF    03.5
03C4:  BCF    06.1
03C5:  BCF    03.5
03C6:  BCF    06.1
....................    return data;               // Return the read data 
03C7:  BSF    03.5
03C8:  BSF    03.6
03C9:  MOVF   18,W
03CA:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define uchar unsigned char 
....................  
.................... #define GRID_SIZE     6 
.................... #define GRID_COLS     10 
.................... #define GRID_ROWS     10 
.................... #define GRID_ORIGIN_X 0 
.................... #define GRID_ORIGIN_Y 0 
....................  
.................... uchar snakeX[32]; 
.................... uchar snakeY[32]; 
.................... uchar snakeX2[32]; 
.................... uchar snakeY2[32]; 
....................  
.................... #define getX(i) ((i < 32) ? snakeX[i] : snakeX2[(i)-32]) 
.................... #define getY(i) ((i < 32) ? snakeY[i] : snakeY2[(i)-32]) 
.................... #define setX(i,val) ((i < 32) ? (snakeX[i]=(val)) : (snakeX2[(i)-32]=(val))) 
.................... #define setY(i,val) ((i < 32) ? (snakeY[i]=(val)) : (snakeY2[(i)-32]=(val))) 
....................  
.................... uchar dir = 2; 
.................... uchar food[2], LENGTH_SNAKE = 64; 
.................... uchar posX = 0, posY = 2; 
.................... uchar score = 0; 
.................... uchar best_score = 0; 
.................... char score_txt[11] = "Score: 00"; 
*
09F7:  MOVLW  53
09F8:  BSF    03.5
09F9:  MOVWF  60
09FA:  MOVLW  63
09FB:  MOVWF  61
09FC:  MOVLW  6F
09FD:  MOVWF  62
09FE:  MOVLW  72
09FF:  MOVWF  63
0A00:  MOVLW  65
0A01:  MOVWF  64
0A02:  MOVLW  3A
0A03:  MOVWF  65
0A04:  MOVLW  20
0A05:  MOVWF  66
0A06:  MOVLW  30
0A07:  MOVWF  67
0A08:  MOVWF  68
0A09:  CLRF   69
.................... char best_score_txt[10] = "Best: 00"; 
0A0A:  MOVLW  42
0A0B:  BCF    03.5
0A0C:  BSF    03.6
0A0D:  MOVWF  10
0A0E:  MOVLW  65
0A0F:  MOVWF  11
0A10:  MOVLW  73
0A11:  MOVWF  12
0A12:  MOVLW  74
0A13:  MOVWF  13
0A14:  MOVLW  3A
0A15:  MOVWF  14
0A16:  MOVLW  20
0A17:  MOVWF  15
0A18:  MOVLW  30
0A19:  MOVWF  16
0A1A:  MOVWF  17
0A1B:  CLRF   18
.................... char gameover_msg[14] = "GAMEOVER !!!"; 
0A1C:  MOVLW  47
0A1D:  MOVWF  1A
0A1E:  MOVLW  41
0A1F:  MOVWF  1B
0A20:  MOVLW  4D
0A21:  MOVWF  1C
0A22:  MOVLW  45
0A23:  MOVWF  1D
0A24:  MOVLW  4F
0A25:  MOVWF  1E
0A26:  MOVLW  56
0A27:  MOVWF  1F
0A28:  MOVLW  45
0A29:  MOVWF  20
0A2A:  MOVLW  52
0A2B:  MOVWF  21
0A2C:  MOVLW  20
0A2D:  MOVWF  22
0A2E:  MOVLW  21
0A2F:  MOVWF  23
0A30:  MOVWF  24
0A31:  MOVWF  25
0A32:  CLRF   26
.................... char win_msg[] = "YOU WON!"; 
0A33:  MOVLW  59
0A34:  MOVWF  28
0A35:  MOVLW  4F
0A36:  MOVWF  29
0A37:  MOVLW  55
0A38:  MOVWF  2A
0A39:  MOVLW  20
0A3A:  MOVWF  2B
0A3B:  MOVLW  57
0A3C:  MOVWF  2C
0A3D:  MOVLW  4F
0A3E:  MOVWF  2D
0A3F:  MOVLW  4E
0A40:  MOVWF  2E
0A41:  MOVLW  21
0A42:  MOVWF  2F
0A43:  CLRF   30
.................... char splash_text[] = "SNAKE GAME"; 
0A44:  MOVLW  53
0A45:  MOVWF  31
0A46:  MOVLW  4E
0A47:  MOVWF  32
0A48:  MOVLW  41
0A49:  MOVWF  33
0A4A:  MOVLW  4B
0A4B:  MOVWF  34
0A4C:  MOVLW  45
0A4D:  MOVWF  35
0A4E:  MOVLW  20
0A4F:  MOVWF  36
0A50:  MOVLW  47
0A51:  MOVWF  37
0A52:  MOVLW  41
0A53:  MOVWF  38
0A54:  MOVLW  4D
0A55:  MOVWF  39
0A56:  MOVLW  45
0A57:  MOVWF  3A
0A58:  CLRF   3B
.................... uchar i; 
....................  
.................... int1 isFirstStart = 1; 
.................... uchar difficulty_index = 0; 
....................  
.................... // ? delay_time 2-bitlik RAM dostu yap 
.................... struct { 
....................    unsigned delay_time : 2; 
.................... } gameSettings; 
....................  
.................... // ? RAM'de tutulan yazlar (const DEL!) 
.................... char easy[]   = "EASY"; 
0A59:  BSF    03.5
0A5A:  BCF    03.6
0A5B:  MOVWF  6B
0A5C:  MOVLW  41
0A5D:  MOVWF  6C
0A5E:  MOVLW  53
0A5F:  MOVWF  6D
0A60:  MOVLW  59
0A61:  MOVWF  6E
0A62:  CLRF   6F
.................... char medium[] = "MEDIUM"; 
0A63:  MOVLW  4D
0A64:  BCF    03.5
0A65:  BSF    03.6
0A66:  MOVWF  3C
0A67:  MOVLW  45
0A68:  MOVWF  3D
0A69:  MOVLW  44
0A6A:  MOVWF  3E
0A6B:  MOVLW  49
0A6C:  MOVWF  3F
0A6D:  MOVLW  55
0A6E:  MOVWF  40
0A6F:  MOVLW  4D
0A70:  MOVWF  41
0A71:  CLRF   42
.................... char hard[]   = "HARD"; 
0A72:  MOVLW  48
0A73:  MOVWF  43
0A74:  MOVLW  41
0A75:  MOVWF  44
0A76:  MOVLW  52
0A77:  MOVWF  45
0A78:  MOVLW  44
0A79:  MOVWF  46
0A7A:  CLRF   47
....................  
.................... void fillCell(signed int gx, signed int gy, int1 color) { 
....................    if (gx < 0 || gx >= GRID_COLS || gy < 0 || gy >= GRID_ROWS) return; 
*
0880:  BSF    03.6
0881:  BTFSC  4C.7
0882:  GOTO   090
0883:  BTFSC  4C.7
0884:  GOTO   089
0885:  MOVF   4C,W
0886:  SUBLW  09
0887:  BTFSS  03.0
0888:  GOTO   090
0889:  BTFSC  4D.7
088A:  GOTO   090
088B:  BTFSC  4D.7
088C:  GOTO   091
088D:  MOVF   4D,W
088E:  SUBLW  09
088F:  BTFSS  03.0
0890:  GOTO   0D2
....................    uchar px = GRID_ORIGIN_X + gx * GRID_SIZE + 1; 
....................    uchar py = GRID_ORIGIN_Y + gy * GRID_SIZE + 1; 
0891:  MOVF   4C,W
0892:  BSF    03.5
0893:  MOVWF  12
0894:  MOVLW  06
0895:  MOVWF  13
0896:  BCF    0A.3
0897:  BCF    03.5
0898:  BCF    03.6
0899:  CALL   21C
089A:  BSF    0A.3
089B:  MOVLW  01
089C:  ADDWF  78,W
089D:  BSF    03.6
089E:  MOVWF  4F
089F:  MOVF   4D,W
08A0:  BSF    03.5
08A1:  MOVWF  12
08A2:  MOVLW  06
08A3:  MOVWF  13
08A4:  BCF    0A.3
08A5:  BCF    03.5
08A6:  BCF    03.6
08A7:  CALL   21C
08A8:  BSF    0A.3
08A9:  MOVLW  01
08AA:  ADDWF  78,W
08AB:  BSF    03.6
08AC:  MOVWF  50
....................    for (uchar dx = 0; dx < GRID_SIZE - 1; dx++) 
08AD:  CLRF   51
08AE:  MOVF   51,W
08AF:  SUBLW  04
08B0:  BTFSS  03.0
08B1:  GOTO   0D2
....................       for (uchar dy = 0; dy < GRID_SIZE - 1; dy++) 
08B2:  CLRF   52
08B3:  MOVF   52,W
08B4:  SUBLW  04
08B5:  BTFSS  03.0
08B6:  GOTO   0D0
....................          glcd_pixel(px + dx, py + dy, color); 
08B7:  MOVF   51,W
08B8:  ADDWF  4F,W
08B9:  MOVWF  53
08BA:  MOVF   52,W
08BB:  ADDWF  50,W
08BC:  MOVWF  54
08BD:  MOVF   53,W
08BE:  BSF    03.5
08BF:  MOVWF  12
08C0:  BCF    03.5
08C1:  MOVF   54,W
08C2:  BSF    03.5
08C3:  MOVWF  13
08C4:  BCF    03.5
08C5:  MOVF   4E,W
08C6:  BSF    03.5
08C7:  MOVWF  14
08C8:  BCF    0A.3
08C9:  BCF    03.5
08CA:  BCF    03.6
08CB:  CALL   34D
08CC:  BSF    0A.3
08CD:  BSF    03.6
08CE:  INCF   52,F
08CF:  GOTO   0B3
08D0:  INCF   51,F
08D1:  GOTO   0AE
08D2:  BCF    03.6
08D3:  RETURN
.................... } 
....................  
.................... void screenWipeDown() { 
....................    for (uchar y = 0; y < 64; y++) { 
*
0523:  BSF    03.6
0524:  CLRF   4A
0525:  MOVF   4A,W
0526:  SUBLW  3F
0527:  BTFSS  03.0
0528:  GOTO   544
....................       for (uchar x = 0; x < 128; x++) { 
0529:  CLRF   4B
052A:  MOVF   4B,W
052B:  SUBLW  7F
052C:  BTFSS  03.0
052D:  GOTO   53D
....................          glcd_pixel(x, y, 1); 
052E:  MOVF   4B,W
052F:  BSF    03.5
0530:  MOVWF  12
0531:  BCF    03.5
0532:  MOVF   4A,W
0533:  BSF    03.5
0534:  MOVWF  13
0535:  MOVLW  01
0536:  MOVWF  14
0537:  BCF    03.5
0538:  BCF    03.6
0539:  CALL   34D
053A:  BSF    03.6
053B:  INCF   4B,F
053C:  GOTO   52A
....................       } 
....................       delay_ms(5); 
053D:  MOVLW  05
053E:  MOVWF  5D
053F:  BCF    03.6
0540:  CALL   338
0541:  BSF    03.6
0542:  INCF   4A,F
0543:  GOTO   525
....................    } 
0544:  BCF    03.6
0545:  RETURN
.................... } 
....................  
.................... void drawGrid() { 
....................    for (uchar c = 0; c <= GRID_COLS; c++) { 
*
074B:  BSF    03.6
074C:  CLRF   4A
074D:  MOVF   4A,W
074E:  SUBLW  0A
074F:  BTFSS  03.0
0750:  GOTO   76A
....................       uchar x = GRID_ORIGIN_X + c * GRID_SIZE; 
0751:  MOVF   4A,W
0752:  BSF    03.5
0753:  MOVWF  12
0754:  MOVLW  06
0755:  MOVWF  13
0756:  BCF    03.5
0757:  BCF    03.6
0758:  CALL   21C
0759:  MOVF   78,W
075A:  BSF    03.6
075B:  MOVWF  4B
....................       glcd_line(x, GRID_ORIGIN_Y, x, GRID_ORIGIN_Y + GRID_ROWS * GRID_SIZE, 1); 
075C:  MOVF   4B,W
075D:  MOVWF  4E
075E:  CLRF   4F
075F:  MOVF   4B,W
0760:  MOVWF  50
0761:  MOVLW  3C
0762:  MOVWF  51
0763:  MOVLW  01
0764:  MOVWF  52
0765:  BCF    03.6
0766:  CALL   63B
0767:  BSF    03.6
0768:  INCF   4A,F
0769:  GOTO   74D
....................    } 
....................    for (uchar r = 0; r <= GRID_ROWS; r++) { 
076A:  CLRF   4C
076B:  MOVF   4C,W
076C:  SUBLW  0A
076D:  BTFSS  03.0
076E:  GOTO   788
....................       uchar y = GRID_ORIGIN_Y + r * GRID_SIZE; 
076F:  MOVF   4C,W
0770:  BSF    03.5
0771:  MOVWF  12
0772:  MOVLW  06
0773:  MOVWF  13
0774:  BCF    03.5
0775:  BCF    03.6
0776:  CALL   21C
0777:  MOVF   78,W
0778:  BSF    03.6
0779:  MOVWF  4D
....................       glcd_line(GRID_ORIGIN_X, y, GRID_ORIGIN_X + GRID_COLS * GRID_SIZE, y, 1); 
077A:  CLRF   4E
077B:  MOVF   4D,W
077C:  MOVWF  4F
077D:  MOVLW  3C
077E:  MOVWF  50
077F:  MOVF   4D,W
0780:  MOVWF  51
0781:  MOVLW  01
0782:  MOVWF  52
0783:  BCF    03.6
0784:  CALL   63B
0785:  BSF    03.6
0786:  INCF   4C,F
0787:  GOTO   76B
....................    } 
0788:  BCF    03.6
0789:  RETURN
.................... } 
....................  
.................... void clearScoreArea() { 
....................    for (uchar x = 65; x < 125; x++) { 
078A:  MOVLW  41
078B:  BSF    03.6
078C:  MOVWF  4A
078D:  MOVF   4A,W
078E:  SUBLW  7C
078F:  BTFSS  03.0
0790:  GOTO   7A6
....................       for (uchar y = 0; y < 20; y++) { 
0791:  CLRF   4B
0792:  MOVF   4B,W
0793:  SUBLW  13
0794:  BTFSS  03.0
0795:  GOTO   7A4
....................          glcd_pixel(x, y, 0); 
0796:  MOVF   4A,W
0797:  BSF    03.5
0798:  MOVWF  12
0799:  BCF    03.5
079A:  MOVF   4B,W
079B:  BSF    03.5
079C:  MOVWF  13
079D:  CLRF   14
079E:  BCF    03.5
079F:  BCF    03.6
07A0:  CALL   34D
07A1:  BSF    03.6
07A2:  INCF   4B,F
07A3:  GOTO   792
....................       } 
07A4:  INCF   4A,F
07A5:  GOTO   78D
....................    } 
.................... } 
....................  
.................... void writeScore() { 
....................    clearScoreArea(); 
....................    glcd_text57(65, 0, score_txt, 1, 1); 
07A6:  MOVLW  41
07A7:  MOVWF  5F
07A8:  CLRF   60
07A9:  CLRF   62
07AA:  MOVLW  E0
07AB:  MOVWF  61
07AC:  MOVLW  01
07AD:  MOVWF  63
07AE:  MOVWF  64
07AF:  BCF    03.6
07B0:  CALL   40A
....................    glcd_text57(65, 10, best_score_txt, 1, 1); 
07B1:  MOVLW  41
07B2:  BSF    03.6
07B3:  MOVWF  5F
07B4:  MOVLW  0A
07B5:  MOVWF  60
07B6:  MOVLW  01
07B7:  MOVWF  62
07B8:  MOVLW  10
07B9:  MOVWF  61
07BA:  MOVLW  01
07BB:  MOVWF  63
07BC:  MOVWF  64
07BD:  BCF    03.6
07BE:  CALL   40A
07BF:  RETURN
.................... } 
....................  
.................... void criar_comida() { 
*
08D4:  BSF    03.6
08D5:  CLRF   4A
....................    uchar valid = 0; 
....................    while (!valid) { 
08D6:  MOVF   4A,F
08D7:  BTFSS  03.2
08D8:  GOTO   13B
....................       food[0] = rand() % GRID_COLS; 
08D9:  BCF    03.6
08DA:  CALL   000
08DB:  MOVF   79,W
08DC:  BSF    03.6
08DD:  MOVWF  4D
08DE:  MOVF   78,W
08DF:  MOVWF  4C
08E0:  MOVF   4D,W
08E1:  MOVWF  50
08E2:  MOVF   4C,W
08E3:  MOVWF  4F
08E4:  CLRF   52
08E5:  MOVLW  0A
08E6:  MOVWF  51
08E7:  BCF    0A.3
08E8:  BCF    03.6
08E9:  CALL   7C0
08EA:  BSF    0A.3
08EB:  MOVF   77,W
08EC:  MOVWF  68
....................       food[1] = rand() % GRID_ROWS; 
08ED:  CALL   000
08EE:  MOVF   79,W
08EF:  BSF    03.6
08F0:  MOVWF  4D
08F1:  MOVF   78,W
08F2:  MOVWF  4C
08F3:  MOVF   4D,W
08F4:  MOVWF  50
08F5:  MOVF   4C,W
08F6:  MOVWF  4F
08F7:  CLRF   52
08F8:  MOVLW  0A
08F9:  MOVWF  51
08FA:  BCF    0A.3
08FB:  BCF    03.6
08FC:  CALL   7C0
08FD:  BSF    0A.3
08FE:  MOVF   77,W
08FF:  MOVWF  69
....................       valid = 1; 
0900:  MOVLW  01
0901:  BSF    03.6
0902:  MOVWF  4A
....................       for (uchar j = 0; j < LENGTH_SNAKE; j++) { 
0903:  CLRF   4B
0904:  BCF    03.6
0905:  MOVF   6A,W
0906:  BSF    03.6
0907:  SUBWF  4B,W
0908:  BTFSC  03.0
0909:  GOTO   13A
....................          if (getX(j) == food[0] && getY(j) == food[1]) { 
090A:  MOVF   4B,W
090B:  SUBLW  1F
090C:  BTFSS  03.0
090D:  GOTO   114
090E:  MOVLW  27
090F:  ADDWF  4B,W
0910:  MOVWF  04
0911:  BCF    03.7
0912:  MOVF   00,W
0913:  GOTO   11A
0914:  MOVLW  20
0915:  SUBWF  4B,W
0916:  ADDLW  A0
0917:  MOVWF  04
0918:  BCF    03.7
0919:  MOVF   00,W
091A:  BCF    03.6
091B:  SUBWF  68,W
091C:  BTFSS  03.2
091D:  GOTO   137
091E:  BSF    03.6
091F:  MOVF   4B,W
0920:  SUBLW  1F
0921:  BTFSS  03.0
0922:  GOTO   129
0923:  MOVLW  47
0924:  ADDWF  4B,W
0925:  MOVWF  04
0926:  BCF    03.7
0927:  MOVF   00,W
0928:  GOTO   12F
0929:  MOVLW  20
092A:  SUBWF  4B,W
092B:  ADDLW  C0
092C:  MOVWF  04
092D:  BCF    03.7
092E:  MOVF   00,W
092F:  BCF    03.6
0930:  SUBWF  69,W
0931:  BTFSS  03.2
0932:  GOTO   137
....................             valid = 0; 
0933:  BSF    03.6
0934:  CLRF   4A
....................             break; 
0935:  GOTO   13A
0936:  BCF    03.6
....................          } 
0937:  BSF    03.6
0938:  INCF   4B,F
0939:  GOTO   104
....................       } 
093A:  GOTO   0D6
....................    } 
....................    fillCell(food[0], food[1], 1); 
093B:  BCF    03.6
093C:  MOVF   68,W
093D:  BSF    03.6
093E:  MOVWF  4C
093F:  BCF    03.6
0940:  MOVF   69,W
0941:  BSF    03.6
0942:  MOVWF  4D
0943:  MOVLW  01
0944:  MOVWF  4E
0945:  BCF    03.6
0946:  CALL   080
0947:  RETURN
.................... } 
....................  
.................... void gameover() { 
....................    LENGTH_SNAKE = 5; 
0948:  MOVLW  05
0949:  MOVWF  6A
....................    posX = 0; 
094A:  CLRF   6B
....................    posY = 2; 
094B:  MOVLW  02
094C:  MOVWF  6C
....................    score = 0; 
094D:  CLRF   6D
....................    score_txt[7] = '0'; 
094E:  MOVLW  30
094F:  BSF    03.5
0950:  MOVWF  67
....................    score_txt[8] = '0'; 
0951:  MOVWF  68
....................    dir = 2; 
0952:  MOVLW  02
0953:  BCF    03.5
0954:  MOVWF  67
....................  
....................    glcd_fillScreen(0); 
0955:  BSF    03.6
0956:  CLRF   5C
0957:  BCF    0A.3
0958:  BCF    03.6
0959:  CALL   245
095A:  BSF    0A.3
....................    glcd_text57(25, 30, gameover_msg, 1, 1); 
095B:  MOVLW  19
095C:  BSF    03.6
095D:  MOVWF  5F
095E:  MOVLW  1E
095F:  MOVWF  60
0960:  MOVLW  01
0961:  MOVWF  62
0962:  MOVLW  1A
0963:  MOVWF  61
0964:  MOVLW  01
0965:  MOVWF  63
0966:  MOVWF  64
0967:  BCF    0A.3
0968:  BCF    03.6
0969:  CALL   40A
096A:  BSF    0A.3
....................    delay_ms(1500); 
096B:  MOVLW  06
096C:  BSF    03.6
096D:  MOVWF  4A
096E:  MOVLW  FA
096F:  MOVWF  5D
0970:  BCF    0A.3
0971:  BCF    03.6
0972:  CALL   338
0973:  BSF    0A.3
0974:  BSF    03.6
0975:  DECFSZ 4A,F
0976:  GOTO   16E
....................    screenWipeDown(); 
0977:  BCF    0A.3
0978:  BCF    03.6
0979:  CALL   523
097A:  BSF    0A.3
....................    glcd_fillScreen(0); 
097B:  BSF    03.6
097C:  CLRF   5C
097D:  BCF    0A.3
097E:  BCF    03.6
097F:  CALL   245
0980:  BSF    0A.3
....................    drawGrid(); 
0981:  BCF    0A.3
0982:  CALL   74B
0983:  BSF    0A.3
0984:  RETURN
.................... } 
....................  
.................... void winScreen() { 
....................    glcd_fillScreen(0); 
0985:  BSF    03.6
0986:  CLRF   5C
0987:  BCF    0A.3
0988:  BCF    03.6
0989:  CALL   245
098A:  BSF    0A.3
....................    glcd_text57(35, 35, win_msg, 1, 1); 
098B:  MOVLW  23
098C:  BSF    03.6
098D:  MOVWF  5F
098E:  MOVWF  60
098F:  MOVLW  01
0990:  MOVWF  62
0991:  MOVLW  28
0992:  MOVWF  61
0993:  MOVLW  01
0994:  MOVWF  63
0995:  MOVWF  64
0996:  BCF    0A.3
0997:  BCF    03.6
0998:  CALL   40A
0999:  BSF    0A.3
....................    delay_ms(2500); 
099A:  MOVLW  0A
099B:  BSF    03.6
099C:  MOVWF  4A
099D:  MOVLW  FA
099E:  MOVWF  5D
099F:  BCF    0A.3
09A0:  BCF    03.6
09A1:  CALL   338
09A2:  BSF    0A.3
09A3:  BSF    03.6
09A4:  DECFSZ 4A,F
09A5:  GOTO   19D
....................    screenWipeDown(); 
09A6:  BCF    0A.3
09A7:  BCF    03.6
09A8:  CALL   523
09A9:  BSF    0A.3
....................    glcd_fillScreen(0); 
09AA:  BSF    03.6
09AB:  CLRF   5C
09AC:  BCF    0A.3
09AD:  BCF    03.6
09AE:  CALL   245
09AF:  BSF    0A.3
....................    drawGrid(); 
09B0:  BCF    0A.3
09B1:  CALL   74B
09B2:  BSF    0A.3
....................    LENGTH_SNAKE = 5; 
09B3:  MOVLW  05
09B4:  MOVWF  6A
....................    posX = 0; 
09B5:  CLRF   6B
....................    posY = 2; 
09B6:  MOVLW  02
09B7:  MOVWF  6C
....................    score = 0; 
09B8:  CLRF   6D
....................    score_txt[7] = '0'; 
09B9:  MOVLW  30
09BA:  BSF    03.5
09BB:  MOVWF  67
....................    score_txt[8] = '0'; 
09BC:  MOVWF  68
....................    dir = 2; 
09BD:  MOVLW  02
09BE:  BCF    03.5
09BF:  MOVWF  67
09C0:  BSF    0A.3
09C1:  BCF    0A.4
09C2:  GOTO   4BB (RETURN)
.................... } 
....................  
.................... void showSplashScreen() { 
....................    glcd_fillScreen(0); 
*
0503:  BSF    03.6
0504:  CLRF   5C
0505:  BCF    03.6
0506:  CALL   245
....................    glcd_text57(20, 25, splash_text, 1, 1); 
0507:  MOVLW  14
0508:  BSF    03.6
0509:  MOVWF  5F
050A:  MOVLW  19
050B:  MOVWF  60
050C:  MOVLW  01
050D:  MOVWF  62
050E:  MOVLW  31
050F:  MOVWF  61
0510:  MOVLW  01
0511:  MOVWF  63
0512:  MOVWF  64
0513:  BCF    03.6
0514:  CALL   40A
....................    delay_ms(2000); 
0515:  MOVLW  08
0516:  BSF    03.6
0517:  MOVWF  4A
0518:  MOVLW  FA
0519:  MOVWF  5D
051A:  BCF    03.6
051B:  CALL   338
051C:  BSF    03.6
051D:  DECFSZ 4A,F
051E:  GOTO   518
051F:  BCF    03.6
0520:  BSF    0A.3
0521:  BCF    0A.4
0522:  GOTO   298 (RETURN)
.................... } 
....................  
.................... void displayDifficulty(uchar index) { 
....................    for (uchar x = 40; x < 88; x++) { 
*
0546:  MOVLW  28
0547:  BSF    03.6
0548:  MOVWF  5D
0549:  MOVF   5D,W
054A:  SUBLW  57
054B:  BTFSS  03.0
054C:  GOTO   563
....................       for (uchar y = 30; y < 38; y++) { 
054D:  MOVLW  1E
054E:  MOVWF  5E
054F:  MOVF   5E,W
0550:  SUBLW  25
0551:  BTFSS  03.0
0552:  GOTO   561
....................          glcd_pixel(x, y, 0); 
0553:  MOVF   5D,W
0554:  BSF    03.5
0555:  MOVWF  12
0556:  BCF    03.5
0557:  MOVF   5E,W
0558:  BSF    03.5
0559:  MOVWF  13
055A:  CLRF   14
055B:  BCF    03.5
055C:  BCF    03.6
055D:  CALL   34D
055E:  BSF    03.6
055F:  INCF   5E,F
0560:  GOTO   54F
....................       } 
0561:  INCF   5D,F
0562:  GOTO   549
....................    } 
....................    switch(index) { 
0563:  MOVF   5C,W
0564:  XORLW  00
0565:  BCF    03.6
0566:  BTFSC  03.2
0567:  GOTO   56F
0568:  XORLW  01
0569:  BTFSC  03.2
056A:  GOTO   57D
056B:  XORLW  03
056C:  BTFSC  03.2
056D:  GOTO   58C
056E:  GOTO   59A
....................       case 0: glcd_text57(40, 30, easy, 1, 1); break; 
056F:  MOVLW  28
0570:  BSF    03.6
0571:  MOVWF  5F
0572:  MOVLW  1E
0573:  MOVWF  60
0574:  CLRF   62
0575:  MOVLW  EB
0576:  MOVWF  61
0577:  MOVLW  01
0578:  MOVWF  63
0579:  MOVWF  64
057A:  BCF    03.6
057B:  CALL   40A
057C:  GOTO   59A
....................       case 1: glcd_text57(40, 30, medium, 1, 1); break; 
057D:  MOVLW  28
057E:  BSF    03.6
057F:  MOVWF  5F
0580:  MOVLW  1E
0581:  MOVWF  60
0582:  MOVLW  01
0583:  MOVWF  62
0584:  MOVLW  3C
0585:  MOVWF  61
0586:  MOVLW  01
0587:  MOVWF  63
0588:  MOVWF  64
0589:  BCF    03.6
058A:  CALL   40A
058B:  GOTO   59A
....................       case 2: glcd_text57(40, 30, hard, 1, 1); break; 
058C:  MOVLW  28
058D:  BSF    03.6
058E:  MOVWF  5F
058F:  MOVLW  1E
0590:  MOVWF  60
0591:  MOVLW  01
0592:  MOVWF  62
0593:  MOVLW  43
0594:  MOVWF  61
0595:  MOVLW  01
0596:  MOVWF  63
0597:  MOVWF  64
0598:  BCF    03.6
0599:  CALL   40A
....................    } 
059A:  RETURN
.................... } 
....................  
.................... void selectDifficulty() { 
....................    char title[] = "SELECT DIFFICULTY"; 
059B:  MOVLW  53
059C:  BSF    03.6
059D:  MOVWF  4A
059E:  MOVLW  45
059F:  MOVWF  4B
05A0:  MOVLW  4C
05A1:  MOVWF  4C
05A2:  MOVLW  45
05A3:  MOVWF  4D
05A4:  MOVLW  43
05A5:  MOVWF  4E
05A6:  MOVLW  54
05A7:  MOVWF  4F
05A8:  MOVLW  20
05A9:  MOVWF  50
05AA:  MOVLW  44
05AB:  MOVWF  51
05AC:  MOVLW  49
05AD:  MOVWF  52
05AE:  MOVLW  46
05AF:  MOVWF  53
05B0:  MOVWF  54
05B1:  MOVLW  49
05B2:  MOVWF  55
05B3:  MOVLW  43
05B4:  MOVWF  56
05B5:  MOVLW  55
05B6:  MOVWF  57
05B7:  MOVLW  4C
05B8:  MOVWF  58
05B9:  MOVLW  54
05BA:  MOVWF  59
05BB:  MOVLW  59
05BC:  MOVWF  5A
05BD:  CLRF   5B
....................    glcd_fillScreen(0); 
05BE:  CLRF   5C
05BF:  BCF    03.6
05C0:  CALL   245
....................    glcd_text57(10, 10, title, 1, 1); 
05C1:  MOVLW  0A
05C2:  BSF    03.6
05C3:  MOVWF  5F
05C4:  MOVWF  60
05C5:  MOVLW  01
05C6:  MOVWF  62
05C7:  MOVLW  4A
05C8:  MOVWF  61
05C9:  MOVLW  01
05CA:  MOVWF  63
05CB:  MOVWF  64
05CC:  BCF    03.6
05CD:  CALL   40A
....................    displayDifficulty(difficulty_index); 
05CE:  MOVF   71,W
05CF:  BSF    03.6
05D0:  MOVWF  5C
05D1:  BCF    03.6
05D2:  CALL   546
....................  
....................    while(TRUE) { 
....................       if (input(PIN_C3)) { 
05D3:  BSF    26.3
05D4:  MOVF   26,W
05D5:  BSF    03.5
05D6:  MOVWF  07
05D7:  BCF    03.5
05D8:  BTFSS  07.3
05D9:  GOTO   5EF
....................          if (difficulty_index < 2) { 
05DA:  MOVF   71,W
05DB:  SUBLW  01
05DC:  BTFSS  03.0
05DD:  GOTO   5E4
....................             difficulty_index++; 
05DE:  INCF   71,F
....................             displayDifficulty(difficulty_index); 
05DF:  MOVF   71,W
05E0:  BSF    03.6
05E1:  MOVWF  5C
05E2:  BCF    03.6
05E3:  CALL   546
....................          } 
....................          delay_ms(300); 
05E4:  MOVLW  02
05E5:  BSF    03.6
05E6:  MOVWF  5C
05E7:  MOVLW  96
05E8:  MOVWF  5D
05E9:  BCF    03.6
05EA:  CALL   338
05EB:  BSF    03.6
05EC:  DECFSZ 5C,F
05ED:  GOTO   5E7
05EE:  BCF    03.6
....................       } 
....................  
....................       if (input(PIN_C4)) { 
05EF:  BSF    26.4
05F0:  MOVF   26,W
05F1:  BSF    03.5
05F2:  MOVWF  07
05F3:  BCF    03.5
05F4:  BTFSS  07.4
05F5:  GOTO   60A
....................          if (difficulty_index > 0) { 
05F6:  MOVF   71,F
05F7:  BTFSC  03.2
05F8:  GOTO   5FF
....................             difficulty_index--; 
05F9:  DECF   71,F
....................             displayDifficulty(difficulty_index); 
05FA:  MOVF   71,W
05FB:  BSF    03.6
05FC:  MOVWF  5C
05FD:  BCF    03.6
05FE:  CALL   546
....................          } 
....................          delay_ms(300); 
05FF:  MOVLW  02
0600:  BSF    03.6
0601:  MOVWF  5C
0602:  MOVLW  96
0603:  MOVWF  5D
0604:  BCF    03.6
0605:  CALL   338
0606:  BSF    03.6
0607:  DECFSZ 5C,F
0608:  GOTO   602
0609:  BCF    03.6
....................       } 
....................  
....................       if (input(PIN_C5)) { 
060A:  BSF    26.5
060B:  MOVF   26,W
060C:  BSF    03.5
060D:  MOVWF  07
060E:  BCF    03.5
060F:  BTFSS  07.5
0610:  GOTO   635
....................          switch (difficulty_index) { 
0611:  MOVF   71,W
0612:  BTFSC  03.2
0613:  GOTO   61B
0614:  XORLW  01
0615:  BTFSC  03.2
0616:  GOTO   620
0617:  XORLW  03
0618:  BTFSC  03.2
0619:  GOTO   625
061A:  GOTO   629
....................                case 0: gameSettings.delay_time = 3; break; // EASY 
061B:  MOVLW  FC
061C:  ANDWF  72,W
061D:  IORLW  03
061E:  MOVWF  72
061F:  GOTO   629
....................                case 1: gameSettings.delay_time = 2; break; // MEDIUM 
0620:  MOVLW  FC
0621:  ANDWF  72,W
0622:  IORLW  02
0623:  MOVWF  72
0624:  GOTO   629
....................                case 2: gameSettings.delay_time = 1; break; // HARD 
0625:  MOVLW  FC
0626:  ANDWF  72,W
0627:  IORLW  01
0628:  MOVWF  72
....................             } 
....................          delay_ms(300); 
0629:  MOVLW  02
062A:  BSF    03.6
062B:  MOVWF  5C
062C:  MOVLW  96
062D:  MOVWF  5D
062E:  BCF    03.6
062F:  CALL   338
0630:  BSF    03.6
0631:  DECFSZ 5C,F
0632:  GOTO   62C
....................          return; 
0633:  GOTO   637
0634:  BCF    03.6
....................       } 
0635:  GOTO   5D3
0636:  BSF    03.6
....................    } 
0637:  BCF    03.6
0638:  BSF    0A.3
0639:  BCF    0A.4
063A:  GOTO   29E (RETURN)
.................... } 
....................  
.................... void main() { 
*
09DC:  MOVF   03,W
09DD:  ANDLW  1F
09DE:  MOVWF  03
09DF:  MOVLW  FF
09E0:  MOVWF  26
09E1:  MOVLW  02
09E2:  MOVWF  67
09E3:  MOVLW  40
09E4:  MOVWF  6A
09E5:  CLRF   6B
09E6:  MOVLW  02
09E7:  MOVWF  6C
09E8:  CLRF   6D
09E9:  CLRF   6E
09EA:  BSF    70.0
09EB:  CLRF   71
09EC:  BSF    03.5
09ED:  BSF    1F.0
09EE:  BSF    1F.1
09EF:  BSF    1F.2
09F0:  BCF    1F.3
09F1:  MOVLW  07
09F2:  MOVWF  1C
09F3:  BCF    03.7
....................    glcd_init(ON); 
*
0A7B:  MOVLW  01
0A7C:  MOVWF  4A
0A7D:  BCF    0A.3
0A7E:  BCF    03.6
0A7F:  GOTO   2BE
0A80:  BSF    0A.3
....................    glcd_fillScreen(0); 
0A81:  BSF    03.6
0A82:  CLRF   5C
0A83:  BCF    0A.3
0A84:  BCF    03.6
0A85:  CALL   245
0A86:  BSF    0A.3
....................    delay_ms(500); 
0A87:  MOVLW  02
0A88:  BSF    03.6
0A89:  MOVWF  4A
0A8A:  MOVLW  FA
0A8B:  MOVWF  5D
0A8C:  BCF    0A.3
0A8D:  BCF    03.6
0A8E:  CALL   338
0A8F:  BSF    0A.3
0A90:  BSF    03.6
0A91:  DECFSZ 4A,F
0A92:  GOTO   28A
....................  
.................... Start: 
....................    if (isFirstStart) { 
0A93:  BTFSS  70.0
0A94:  GOTO   2A1
....................       showSplashScreen(); 
0A95:  BCF    0A.3
0A96:  BCF    03.6
0A97:  GOTO   503
0A98:  BSF    0A.3
....................       screenWipeDown(); 
0A99:  BCF    0A.3
0A9A:  CALL   523
0A9B:  BSF    0A.3
....................       selectDifficulty(); 
0A9C:  BCF    0A.3
0A9D:  GOTO   59B
0A9E:  BSF    0A.3
....................       isFirstStart = 0; 
0A9F:  BCF    70.0
0AA0:  BSF    03.6
....................    } 
....................  
....................    glcd_fillScreen(0); 
0AA1:  CLRF   5C
0AA2:  BCF    0A.3
0AA3:  BCF    03.6
0AA4:  CALL   245
0AA5:  BSF    0A.3
....................    drawGrid(); 
0AA6:  BCF    0A.3
0AA7:  CALL   74B
0AA8:  BSF    0A.3
....................    writeScore(); 
0AA9:  BCF    0A.3
0AAA:  CALL   78A
0AAB:  BSF    0A.3
....................    criar_comida(); 
0AAC:  CALL   0D4
....................  
....................    for (i = 0; i < LENGTH_SNAKE; i++) { 
0AAD:  CLRF   6F
0AAE:  MOVF   6A,W
0AAF:  SUBWF  6F,W
0AB0:  BTFSC  03.0
0AB1:  GOTO   308
....................       setX(i, posX - i); 
0AB2:  MOVF   6F,W
0AB3:  SUBLW  1F
0AB4:  BTFSS  03.0
0AB5:  GOTO   2BE
0AB6:  MOVLW  27
0AB7:  ADDWF  6F,W
0AB8:  MOVWF  04
0AB9:  BCF    03.7
0ABA:  MOVF   6F,W
0ABB:  SUBWF  6B,W
0ABC:  MOVWF  00
0ABD:  GOTO   2C6
0ABE:  MOVLW  20
0ABF:  SUBWF  6F,W
0AC0:  ADDLW  A0
0AC1:  MOVWF  04
0AC2:  BCF    03.7
0AC3:  MOVF   6F,W
0AC4:  SUBWF  6B,W
0AC5:  MOVWF  00
....................       setY(i, posY); 
0AC6:  MOVF   6F,W
0AC7:  SUBLW  1F
0AC8:  BTFSS  03.0
0AC9:  GOTO   2D2
0ACA:  MOVLW  47
0ACB:  ADDWF  6F,W
0ACC:  MOVWF  04
0ACD:  BCF    03.7
0ACE:  MOVF   6C,W
0ACF:  MOVWF  00
0AD0:  MOVF   6C,W
0AD1:  GOTO   2D9
0AD2:  MOVLW  20
0AD3:  SUBWF  6F,W
0AD4:  ADDLW  C0
0AD5:  MOVWF  04
0AD6:  BCF    03.7
0AD7:  MOVF   6C,W
0AD8:  MOVWF  00
....................       fillCell(getX(i), getY(i), 1); 
0AD9:  MOVF   6F,W
0ADA:  SUBLW  1F
0ADB:  BTFSS  03.0
0ADC:  GOTO   2E3
0ADD:  MOVLW  27
0ADE:  ADDWF  6F,W
0ADF:  MOVWF  04
0AE0:  BCF    03.7
0AE1:  MOVF   00,W
0AE2:  GOTO   2E9
0AE3:  MOVLW  20
0AE4:  SUBWF  6F,W
0AE5:  ADDLW  A0
0AE6:  MOVWF  04
0AE7:  BCF    03.7
0AE8:  MOVF   00,W
0AE9:  BSF    03.6
0AEA:  MOVWF  4A
0AEB:  BCF    03.6
0AEC:  MOVF   6F,W
0AED:  SUBLW  1F
0AEE:  BTFSS  03.0
0AEF:  GOTO   2F6
0AF0:  MOVLW  47
0AF1:  ADDWF  6F,W
0AF2:  MOVWF  04
0AF3:  BCF    03.7
0AF4:  MOVF   00,W
0AF5:  GOTO   2FC
0AF6:  MOVLW  20
0AF7:  SUBWF  6F,W
0AF8:  ADDLW  C0
0AF9:  MOVWF  04
0AFA:  BCF    03.7
0AFB:  MOVF   00,W
0AFC:  BSF    03.6
0AFD:  MOVWF  4B
0AFE:  MOVF   4A,W
0AFF:  MOVWF  4C
0B00:  MOVF   4B,W
0B01:  MOVWF  4D
0B02:  MOVLW  01
0B03:  MOVWF  4E
0B04:  BCF    03.6
0B05:  CALL   080
0B06:  INCF   6F,F
0B07:  GOTO   2AE
....................    } 
....................  
....................    while (TRUE) { 
....................       if (input(PIN_C3) && dir != 0) dir = 3; 
0B08:  BSF    26.3
0B09:  MOVF   26,W
0B0A:  BSF    03.5
0B0B:  MOVWF  07
0B0C:  BCF    03.5
0B0D:  BTFSS  07.3
0B0E:  GOTO   314
0B0F:  MOVF   67,F
0B10:  BTFSC  03.2
0B11:  GOTO   314
0B12:  MOVLW  03
0B13:  MOVWF  67
....................       if (input(PIN_C2) && dir != 1) dir = 2; 
0B14:  BSF    26.2
0B15:  MOVF   26,W
0B16:  BSF    03.5
0B17:  MOVWF  07
0B18:  BCF    03.5
0B19:  BTFSS  07.2
0B1A:  GOTO   320
0B1B:  DECFSZ 67,W
0B1C:  GOTO   31E
0B1D:  GOTO   320
0B1E:  MOVLW  02
0B1F:  MOVWF  67
....................       if (input(PIN_C1) && dir != 2) dir = 1; 
0B20:  BSF    26.1
0B21:  MOVF   26,W
0B22:  BSF    03.5
0B23:  MOVWF  07
0B24:  BCF    03.5
0B25:  BTFSS  07.1
0B26:  GOTO   32D
0B27:  MOVF   67,W
0B28:  SUBLW  02
0B29:  BTFSC  03.2
0B2A:  GOTO   32D
0B2B:  MOVLW  01
0B2C:  MOVWF  67
....................       if (input(PIN_C4) && dir != 3) dir = 0; 
0B2D:  BSF    26.4
0B2E:  MOVF   26,W
0B2F:  BSF    03.5
0B30:  MOVWF  07
0B31:  BCF    03.5
0B32:  BTFSS  07.4
0B33:  GOTO   338
0B34:  MOVF   67,W
0B35:  SUBLW  03
0B36:  BTFSS  03.2
0B37:  CLRF   67
....................       if (input(PIN_C5)) { gameover(); goto Start; } 
0B38:  BSF    26.5
0B39:  MOVF   26,W
0B3A:  BSF    03.5
0B3B:  MOVWF  07
0B3C:  BCF    03.5
0B3D:  BTFSS  07.5
0B3E:  GOTO   343
0B3F:  CALL   148
0B40:  BSF    03.6
0B41:  GOTO   293
0B42:  BCF    03.6
....................  
....................       switch(dir) { 
0B43:  MOVF   67,W
0B44:  ADDLW  FC
0B45:  BTFSC  03.0
0B46:  GOTO   37A
0B47:  ADDLW  04
0B48:  GOTO   529
....................          case 0: if (posX == 0) { gameover(); goto Start; } else posX--; break; 
0B49:  MOVF   6B,F
0B4A:  BTFSS  03.2
0B4B:  GOTO   351
0B4C:  CALL   148
0B4D:  BSF    03.6
0B4E:  GOTO   293
0B4F:  GOTO   353
0B50:  BCF    03.6
0B51:  DECF   6B,F
0B52:  BSF    03.6
0B53:  BCF    03.6
0B54:  GOTO   37A
....................          case 1: if (posY == 0) { gameover(); goto Start; } else posY--; break; 
0B55:  MOVF   6C,F
0B56:  BTFSS  03.2
0B57:  GOTO   35D
0B58:  CALL   148
0B59:  BSF    03.6
0B5A:  GOTO   293
0B5B:  GOTO   35F
0B5C:  BCF    03.6
0B5D:  DECF   6C,F
0B5E:  BSF    03.6
0B5F:  BCF    03.6
0B60:  GOTO   37A
....................          case 2: if (posY == GRID_ROWS - 1) { gameover(); goto Start; } else posY++; break; 
0B61:  MOVF   6C,W
0B62:  SUBLW  09
0B63:  BTFSS  03.2
0B64:  GOTO   36A
0B65:  CALL   148
0B66:  BSF    03.6
0B67:  GOTO   293
0B68:  GOTO   36C
0B69:  BCF    03.6
0B6A:  INCF   6C,F
0B6B:  BSF    03.6
0B6C:  BCF    03.6
0B6D:  GOTO   37A
....................          case 3: if (posX == GRID_COLS - 1) { gameover(); goto Start; } else posX++; break; 
0B6E:  MOVF   6B,W
0B6F:  SUBLW  09
0B70:  BTFSS  03.2
0B71:  GOTO   377
0B72:  CALL   148
0B73:  BSF    03.6
0B74:  GOTO   293
0B75:  GOTO   379
0B76:  BCF    03.6
0B77:  INCF   6B,F
0B78:  BSF    03.6
0B79:  BCF    03.6
....................       } 
....................  
....................       uchar tailX = getX(0), tailY = getY(0); 
0B7A:  MOVF   27,W
0B7B:  BSF    03.6
0B7C:  MOVWF  48
0B7D:  BCF    03.6
0B7E:  MOVF   47,W
0B7F:  BSF    03.6
0B80:  MOVWF  49
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
0B81:  BCF    03.6
0B82:  CLRF   6F
0B83:  MOVLW  01
0B84:  SUBWF  6A,W
0B85:  SUBWF  6F,W
0B86:  BTFSC  03.0
0B87:  GOTO   43C
....................          setX(i, getX(i + 1)); 
0B88:  MOVF   6F,W
0B89:  SUBLW  1F
0B8A:  BTFSS  03.0
0B8B:  GOTO   3B7
0B8C:  MOVLW  27
0B8D:  ADDWF  6F,W
0B8E:  MOVWF  78
0B8F:  CLRF   7A
0B90:  BTFSC  03.0
0B91:  INCF   7A,F
0B92:  MOVF   78,W
0B93:  BSF    03.6
0B94:  MOVWF  4A
0B95:  MOVF   7A,W
0B96:  MOVWF  4B
0B97:  MOVLW  01
0B98:  BCF    03.6
0B99:  ADDWF  6F,W
0B9A:  SUBLW  1F
0B9B:  BTFSS  03.0
0B9C:  GOTO   3A4
0B9D:  MOVLW  01
0B9E:  ADDWF  6F,W
0B9F:  ADDLW  27
0BA0:  MOVWF  04
0BA1:  BCF    03.7
0BA2:  MOVF   00,W
0BA3:  GOTO   3AB
0BA4:  MOVLW  01
0BA5:  ADDWF  6F,W
0BA6:  ADDLW  E0
0BA7:  ADDLW  A0
0BA8:  MOVWF  04
0BA9:  BCF    03.7
0BAA:  MOVF   00,W
0BAB:  BSF    03.6
0BAC:  MOVWF  4C
0BAD:  MOVF   4A,W
0BAE:  MOVWF  04
0BAF:  BCF    03.7
0BB0:  BTFSC  4B.0
0BB1:  BSF    03.7
0BB2:  MOVF   4C,W
0BB3:  MOVWF  00
0BB4:  MOVF   4C,W
0BB5:  GOTO   3E0
0BB6:  BCF    03.6
0BB7:  MOVLW  20
0BB8:  SUBWF  6F,W
0BB9:  ADDLW  A0
0BBA:  MOVWF  78
0BBB:  CLRF   7A
0BBC:  BTFSC  03.0
0BBD:  INCF   7A,F
0BBE:  MOVF   78,W
0BBF:  BSF    03.6
0BC0:  MOVWF  4C
0BC1:  MOVF   7A,W
0BC2:  MOVWF  4D
0BC3:  MOVLW  01
0BC4:  BCF    03.6
0BC5:  ADDWF  6F,W
0BC6:  SUBLW  1F
0BC7:  BTFSS  03.0
0BC8:  GOTO   3D0
0BC9:  MOVLW  01
0BCA:  ADDWF  6F,W
0BCB:  ADDLW  27
0BCC:  MOVWF  04
0BCD:  BCF    03.7
0BCE:  MOVF   00,W
0BCF:  GOTO   3D7
0BD0:  MOVLW  01
0BD1:  ADDWF  6F,W
0BD2:  ADDLW  E0
0BD3:  ADDLW  A0
0BD4:  MOVWF  04
0BD5:  BCF    03.7
0BD6:  MOVF   00,W
0BD7:  BSF    03.6
0BD8:  MOVWF  4A
0BD9:  MOVF   4C,W
0BDA:  MOVWF  04
0BDB:  BCF    03.7
0BDC:  BTFSC  4D.0
0BDD:  BSF    03.7
0BDE:  MOVF   4A,W
0BDF:  MOVWF  00
....................          setY(i, getY(i + 1)); 
0BE0:  BCF    03.6
0BE1:  MOVF   6F,W
0BE2:  SUBLW  1F
0BE3:  BTFSS  03.0
0BE4:  GOTO   410
0BE5:  MOVLW  47
0BE6:  ADDWF  6F,W
0BE7:  MOVWF  78
0BE8:  CLRF   7A
0BE9:  BTFSC  03.0
0BEA:  INCF   7A,F
0BEB:  MOVF   78,W
0BEC:  BSF    03.6
0BED:  MOVWF  4A
0BEE:  MOVF   7A,W
0BEF:  MOVWF  4B
0BF0:  MOVLW  01
0BF1:  BCF    03.6
0BF2:  ADDWF  6F,W
0BF3:  SUBLW  1F
0BF4:  BTFSS  03.0
0BF5:  GOTO   3FD
0BF6:  MOVLW  01
0BF7:  ADDWF  6F,W
0BF8:  ADDLW  47
0BF9:  MOVWF  04
0BFA:  BCF    03.7
0BFB:  MOVF   00,W
0BFC:  GOTO   404
0BFD:  MOVLW  01
0BFE:  ADDWF  6F,W
0BFF:  ADDLW  E0
0C00:  ADDLW  C0
0C01:  MOVWF  04
0C02:  BCF    03.7
0C03:  MOVF   00,W
0C04:  BSF    03.6
0C05:  MOVWF  4C
0C06:  MOVF   4A,W
0C07:  MOVWF  04
0C08:  BCF    03.7
0C09:  BTFSC  4B.0
0C0A:  BSF    03.7
0C0B:  MOVF   4C,W
0C0C:  MOVWF  00
0C0D:  MOVF   4C,W
0C0E:  GOTO   439
0C0F:  BCF    03.6
0C10:  MOVLW  20
0C11:  SUBWF  6F,W
0C12:  ADDLW  C0
0C13:  MOVWF  78
0C14:  CLRF   7A
0C15:  BTFSC  03.0
0C16:  INCF   7A,F
0C17:  MOVF   78,W
0C18:  BSF    03.6
0C19:  MOVWF  4C
0C1A:  MOVF   7A,W
0C1B:  MOVWF  4D
0C1C:  MOVLW  01
0C1D:  BCF    03.6
0C1E:  ADDWF  6F,W
0C1F:  SUBLW  1F
0C20:  BTFSS  03.0
0C21:  GOTO   429
0C22:  MOVLW  01
0C23:  ADDWF  6F,W
0C24:  ADDLW  47
0C25:  MOVWF  04
0C26:  BCF    03.7
0C27:  MOVF   00,W
0C28:  GOTO   430
0C29:  MOVLW  01
0C2A:  ADDWF  6F,W
0C2B:  ADDLW  E0
0C2C:  ADDLW  C0
0C2D:  MOVWF  04
0C2E:  BCF    03.7
0C2F:  MOVF   00,W
0C30:  BSF    03.6
0C31:  MOVWF  4A
0C32:  MOVF   4C,W
0C33:  MOVWF  04
0C34:  BCF    03.7
0C35:  BTFSC  4D.0
0C36:  BSF    03.7
0C37:  MOVF   4A,W
0C38:  MOVWF  00
0C39:  BCF    03.6
0C3A:  INCF   6F,F
0C3B:  GOTO   383
....................       } 
....................       setX(LENGTH_SNAKE - 1, posX); 
0C3C:  MOVLW  01
0C3D:  SUBWF  6A,W
0C3E:  SUBLW  1F
0C3F:  BTFSS  03.0
0C40:  GOTO   44A
0C41:  MOVLW  01
0C42:  SUBWF  6A,W
0C43:  ADDLW  27
0C44:  MOVWF  04
0C45:  BCF    03.7
0C46:  MOVF   6B,W
0C47:  MOVWF  00
0C48:  MOVF   6B,W
0C49:  GOTO   452
0C4A:  MOVLW  01
0C4B:  SUBWF  6A,W
0C4C:  ADDLW  E0
0C4D:  ADDLW  A0
0C4E:  MOVWF  04
0C4F:  BCF    03.7
0C50:  MOVF   6B,W
0C51:  MOVWF  00
....................       setY(LENGTH_SNAKE - 1, posY); 
0C52:  MOVLW  01
0C53:  SUBWF  6A,W
0C54:  SUBLW  1F
0C55:  BTFSS  03.0
0C56:  GOTO   460
0C57:  MOVLW  01
0C58:  SUBWF  6A,W
0C59:  ADDLW  47
0C5A:  MOVWF  04
0C5B:  BCF    03.7
0C5C:  MOVF   6C,W
0C5D:  MOVWF  00
0C5E:  MOVF   6C,W
0C5F:  GOTO   468
0C60:  MOVLW  01
0C61:  SUBWF  6A,W
0C62:  ADDLW  E0
0C63:  ADDLW  C0
0C64:  MOVWF  04
0C65:  BCF    03.7
0C66:  MOVF   6C,W
0C67:  MOVWF  00
....................  
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
0C68:  CLRF   6F
0C69:  MOVLW  01
0C6A:  SUBWF  6A,W
0C6B:  SUBWF  6F,W
0C6C:  BTFSC  03.0
0C6D:  GOTO   49A
....................          if (getX(i) == posX && getY(i) == posY) { 
0C6E:  MOVF   6F,W
0C6F:  SUBLW  1F
0C70:  BTFSS  03.0
0C71:  GOTO   478
0C72:  MOVLW  27
0C73:  ADDWF  6F,W
0C74:  MOVWF  04
0C75:  BCF    03.7
0C76:  MOVF   00,W
0C77:  GOTO   47E
0C78:  MOVLW  20
0C79:  SUBWF  6F,W
0C7A:  ADDLW  A0
0C7B:  MOVWF  04
0C7C:  BCF    03.7
0C7D:  MOVF   00,W
0C7E:  SUBWF  6B,W
0C7F:  BTFSS  03.2
0C80:  GOTO   498
0C81:  MOVF   6F,W
0C82:  SUBLW  1F
0C83:  BTFSS  03.0
0C84:  GOTO   48B
0C85:  MOVLW  47
0C86:  ADDWF  6F,W
0C87:  MOVWF  04
0C88:  BCF    03.7
0C89:  MOVF   00,W
0C8A:  GOTO   491
0C8B:  MOVLW  20
0C8C:  SUBWF  6F,W
0C8D:  ADDLW  C0
0C8E:  MOVWF  04
0C8F:  BCF    03.7
0C90:  MOVF   00,W
0C91:  SUBWF  6C,W
0C92:  BTFSS  03.2
0C93:  GOTO   498
....................             gameover(); goto Start; 
0C94:  CALL   148
0C95:  BSF    03.6
0C96:  GOTO   293
0C97:  BCF    03.6
....................          } 
0C98:  INCF   6F,F
0C99:  GOTO   469
....................       } 
....................  
....................       fillCell(posX, posY, 1); 
0C9A:  MOVF   6B,W
0C9B:  BSF    03.6
0C9C:  MOVWF  4C
0C9D:  BCF    03.6
0C9E:  MOVF   6C,W
0C9F:  BSF    03.6
0CA0:  MOVWF  4D
0CA1:  MOVLW  01
0CA2:  MOVWF  4E
0CA3:  BCF    03.6
0CA4:  CALL   080
....................       fillCell(tailX, tailY, 0); 
0CA5:  BSF    03.6
0CA6:  MOVF   48,W
0CA7:  MOVWF  4C
0CA8:  MOVF   49,W
0CA9:  MOVWF  4D
0CAA:  CLRF   4E
0CAB:  BCF    03.6
0CAC:  CALL   080
....................  
....................       if (posX == food[0] && posY == food[1]) { 
0CAD:  MOVF   68,W
0CAE:  SUBWF  6B,W
0CAF:  BTFSS  03.2
0CB0:  GOTO   501
0CB1:  MOVF   69,W
0CB2:  SUBWF  6C,W
0CB3:  BTFSS  03.2
0CB4:  GOTO   501
....................          LENGTH_SNAKE++; 
0CB5:  INCF   6A,F
....................          if (LENGTH_SNAKE >= 64) { 
0CB6:  MOVF   6A,W
0CB7:  SUBLW  3F
0CB8:  BTFSC  03.0
0CB9:  GOTO   4BE
....................             winScreen(); goto Start; 
0CBA:  GOTO   185
0CBB:  BSF    03.6
0CBC:  GOTO   293
0CBD:  BCF    03.6
....................          } 
....................          criar_comida(); 
0CBE:  CALL   0D4
....................          score++; 
0CBF:  INCF   6D,F
....................          score_txt[7] = '0' + (score / 10); 
0CC0:  MOVF   6D,W
0CC1:  BSF    03.6
0CC2:  MOVWF  4A
0CC3:  MOVLW  0A
0CC4:  MOVWF  4B
0CC5:  BCF    0A.3
0CC6:  BCF    03.6
0CC7:  CALL   7E7
0CC8:  BSF    0A.3
0CC9:  MOVF   78,W
0CCA:  ADDLW  30
0CCB:  BSF    03.5
0CCC:  MOVWF  67
....................          score_txt[8] = '0' + (score % 10); 
0CCD:  BCF    03.5
0CCE:  MOVF   6D,W
0CCF:  BSF    03.6
0CD0:  MOVWF  4A
0CD1:  MOVLW  0A
0CD2:  MOVWF  4B
0CD3:  BCF    0A.3
0CD4:  BCF    03.6
0CD5:  CALL   7E7
0CD6:  BSF    0A.3
0CD7:  MOVF   77,W
0CD8:  ADDLW  30
0CD9:  BSF    03.5
0CDA:  MOVWF  68
....................  
....................          if (score > best_score) { 
0CDB:  BCF    03.5
0CDC:  MOVF   6D,W
0CDD:  SUBWF  6E,W
0CDE:  BTFSC  03.0
0CDF:  GOTO   4FE
....................             best_score = score; 
0CE0:  MOVF   6D,W
0CE1:  MOVWF  6E
....................             best_score_txt[7] = '0' + (best_score / 10); 
0CE2:  MOVF   6E,W
0CE3:  BSF    03.6
0CE4:  MOVWF  4A
0CE5:  MOVLW  0A
0CE6:  MOVWF  4B
0CE7:  BCF    0A.3
0CE8:  BCF    03.6
0CE9:  CALL   7E7
0CEA:  BSF    0A.3
0CEB:  MOVF   78,W
0CEC:  ADDLW  30
0CED:  BSF    03.6
0CEE:  MOVWF  17
....................             best_score_txt[8] = '0' + (best_score % 10); 
0CEF:  BCF    03.6
0CF0:  MOVF   6E,W
0CF1:  BSF    03.6
0CF2:  MOVWF  4A
0CF3:  MOVLW  0A
0CF4:  MOVWF  4B
0CF5:  BCF    0A.3
0CF6:  BCF    03.6
0CF7:  CALL   7E7
0CF8:  BSF    0A.3
0CF9:  MOVF   77,W
0CFA:  ADDLW  30
0CFB:  BSF    03.6
0CFC:  MOVWF  18
0CFD:  BCF    03.6
....................          } 
....................  
....................          writeScore(); 
0CFE:  BCF    0A.3
0CFF:  CALL   78A
0D00:  BSF    0A.3
....................       } 
....................  
....................       delay_ms(gameSettings.delay_time * 300);  // Zorluk seviyesine gre hz 
0D01:  MOVF   72,W
0D02:  ANDLW  03
0D03:  BSF    03.6
0D04:  MOVWF  4B
0D05:  CLRF   4D
0D06:  MOVF   4B,W
0D07:  MOVWF  4C
0D08:  MOVLW  01
0D09:  MOVWF  4F
0D0A:  MOVLW  2C
0D0B:  MOVWF  4E
0D0C:  BCF    03.6
0D0D:  GOTO   1C3
0D0E:  MOVF   79,W
0D0F:  BSF    03.6
0D10:  MOVWF  4B
0D11:  MOVF   78,W
0D12:  MOVWF  4A
0D13:  MOVF   4B,W
0D14:  MOVWF  4C
0D15:  INCF   4C,F
0D16:  DECF   4C,F
0D17:  BTFSC  03.2
0D18:  GOTO   521
0D19:  MOVLW  FF
0D1A:  MOVWF  5D
0D1B:  BCF    0A.3
0D1C:  BCF    03.6
0D1D:  CALL   338
0D1E:  BSF    0A.3
0D1F:  BSF    03.6
0D20:  GOTO   516
0D21:  MOVF   4A,W
0D22:  MOVWF  5D
0D23:  BCF    0A.3
0D24:  BCF    03.6
0D25:  CALL   338
0D26:  BSF    0A.3
0D27:  GOTO   308
....................    } 
.................... } 
....................  
0D28:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
