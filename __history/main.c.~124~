#include <16F877A.h>
#fuses HS,NOWDT,NOPROTECT,NOLVP
#use delay(clock=16000000)
#include <stdlib.h>
#include <glcd.c>
#include <stdio.h>

#define uchar unsigned char
#define GRID_SIZE     6 
#define GRID_COLS     10 
#define GRID_ROWS     10  
#define GRID_ORIGIN_X 0
#define GRID_ORIGIN_Y 0       
#define BUZZER_PIN PIN_B3

// -------------------- BUZZER --------------------
void buzzer_beep(int duration_ms) {
   int cycles = duration_ms * 1000 / 2000;
   for (int i = 0; i < cycles; i++) {
      output_high(BUZZER_PIN);
      delay_us(1000);
      output_low(BUZZER_PIN);
      delay_us(1000);
   }
   output_low(BUZZER_PIN); // Sürekli ötmesini engeller
   delay_ms(5);
}

void short_beep() { buzzer_beep(30); }

void win_melody() {
   for (int i = 0; i < 3; i++) {
      buzzer_beep(100);
      delay_ms(100);
   }
}

// -------------------- GLOBAL --------------------
uchar snakeX[32], snakeY[32], snakeX2[32], snakeY2[32];
#define getX(i) ((i < 32) ? snakeX[i] : snakeX2[(i)-32])
#define getY(i) ((i < 32) ? snakeY[i] : snakeY2[(i)-32])
#define setX(i,val) ((i < 32) ? (snakeX[i]=(val)) : (snakeX2[(i)-32]=(val)))
#define setY(i,val) ((i < 32) ? (snakeY[i]=(val)) : (snakeY2[(i)-32]=(val)))

uchar dir = 2, food[2], LENGTH_SNAKE = 5, posX = 0, posY = 2;
uchar score = 0, best_score = 0, i;
int1 isFirstStart = 1, difficulty_index = 0;

char score_txt[11] = "Score: 00";
char best_score_txt[10] = "Best: 00";
char gameover_msg[] = "GAMEOVER !!!";
char win_msg[] = "YOU WON!";
char splash_text[] = "SNAKE GAME";
char easy[] = "EASY", medium[] = "MEDIUM", hard[] = "HARD";

struct { unsigned delay_time : 2; } gameSettings;

// -------------------- GLCD FONKSÝYONLARI --------------------
void fillCell(signed int gx, signed int gy, int1 color) {
   if (gx < 0 || gx >= GRID_COLS || gy < 0 || gy >= GRID_ROWS) return;
   uchar px = GRID_ORIGIN_X + gx * GRID_SIZE + 1;
   uchar py = GRID_ORIGIN_Y + gy * GRID_SIZE + 1;
   for (uchar dx = 0; dx < GRID_SIZE - 1; dx++)
      for (uchar dy = 0; dy < GRID_SIZE - 1; dy++)
         glcd_pixel(px + dx, py + dy, color);
}

void screenWipeDown() {
   for (uchar y = 0; y < 64; y++) {
      for (uchar x = 0; x < 128; x++) glcd_pixel(x, y, 1);
      delay_ms(5);
   }
}

void drawGrid() {
   for (uchar c = 0; c <= GRID_COLS; c++)
      glcd_line(GRID_ORIGIN_X + c * GRID_SIZE, GRID_ORIGIN_Y, GRID_ORIGIN_X + c * GRID_SIZE, GRID_ORIGIN_Y + GRID_ROWS * GRID_SIZE, 1);
   for (uchar r = 0; r <= GRID_ROWS; r++)
      glcd_line(GRID_ORIGIN_X, GRID_ORIGIN_Y + r * GRID_SIZE, GRID_ORIGIN_X + GRID_COLS * GRID_SIZE, GRID_ORIGIN_Y + r * GRID_SIZE, 1);
}

void clearScoreArea() {
   for (uchar x = 65; x < 125; x++)
      for (uchar y = 0; y < 20; y++) glcd_pixel(x, y, 0);
}

void writeScore() {
   clearScoreArea();
   glcd_text57(65, 0, score_txt, 1, 1);
   glcd_text57(65, 10, best_score_txt, 1, 1);
}

void criar_comida() {
   uchar valid = 0;
   while (!valid) {
      food[0] = rand() % GRID_COLS;
      food[1] = rand() % GRID_ROWS;
      valid = 1;
      for (uchar j = 0; j < LENGTH_SNAKE; j++)
         if (getX(j) == food[0] && getY(j) == food[1]) { valid = 0; break; }
   }
   fillCell(food[0], food[1], 1);
}

// -------------------- OYUN DURUMLARI --------------------
void gameover() {
   buzzer_beep(200);
   LENGTH_SNAKE = 5; posX = 0; posY = 2; score = 0; dir = 2;
   score_txt[7] = score_txt[8] = '0';
   glcd_fillScreen(0);
   glcd_text57(25, 30, gameover_msg, 1, 1);
   delay_ms(1500);
   screenWipeDown(); glcd_fillScreen(0); drawGrid();
}

void winScreen() {
   win_melody();
   glcd_fillScreen(0);
   glcd_text57(35, 35, win_msg, 1, 1);
   delay_ms(2500);
   screenWipeDown(); glcd_fillScreen(0); drawGrid();
   LENGTH_SNAKE = 5; posX = 0; posY = 2; score = 0; dir = 2;
   score_txt[7] = score_txt[8] = '0';
}

void showSplashScreen() {
   glcd_fillScreen(0);
   glcd_text57(20, 25, splash_text, 1, 1);
   delay_ms(2000);
}

void displayDifficulty(uchar index) {
   for (uchar x = 40; x < 88; x++)
      for (uchar y = 30; y < 38; y++) glcd_pixel(x, y, 0);
   switch(index) {
      case 0: glcd_text57(40, 30, easy, 1, 1); break;
      case 1: glcd_text57(40, 30, medium, 1, 1); break;
      case 2: glcd_text57(40, 30, hard, 1, 1); break;
   }
}

void selectDifficulty() {
   char title[] = "SELECT DIFFICULTY";
   glcd_fillScreen(0);
   glcd_text57(10, 10, title, 1, 1);
   displayDifficulty(difficulty_index);

   while(TRUE) {
      if (input(PIN_C3)) {
         if (difficulty_index < 2) {
            difficulty_index++; displayDifficulty(difficulty_index); short_beep();
         }
         delay_ms(300);
      }
      if (input(PIN_C4)) {
         if (difficulty_index > 0) {
            difficulty_index--; displayDifficulty(difficulty_index); short_beep();
         }
         delay_ms(300);
      }
      if (input(PIN_C5)) {
         gameSettings.delay_time = 3 - difficulty_index;
         buzzer_beep(100);
         delay_ms(300);
         return;
      }
   }
}

// -------------------- MAIN --------------------
void main() {
   set_tris_b(0b00000111); // RB0-1-2 input, RB3 output
   output_low(BUZZER_PIN);

   glcd_init(ON); glcd_fillScreen(0); delay_ms(500);

Start:
   if (isFirstStart) {
      buzzer_beep(100);
      showSplashScreen();
      screenWipeDown();
      selectDifficulty();
      isFirstStart = 0;
   }

   glcd_fillScreen(0); drawGrid(); writeScore(); criar_comida();
   for (i = 0; i < LENGTH_SNAKE; i++) {
      setX(i, posX - i); setY(i, posY);
      fillCell(getX(i), getY(i), 1);
   }

   while (TRUE) {
      if (input(PIN_C3) && dir != 0) { dir = 3; short_beep(); }
      if (input(PIN_C2) && dir != 1) { dir = 2; short_beep(); }
      if (input(PIN_C1) && dir != 2) { dir = 1; short_beep(); }
      if (input(PIN_C4) && dir != 3) { dir = 0; short_beep(); }
      if (input(PIN_C5)) { gameover(); goto Start; }

      switch(dir) {
         case 0: if (posX == 0) { gameover(); goto Start; } else posX--; break;
         case 1: if (posY == 0) { gameover(); goto Start; } else posY--; break;
         case 2: if (posY == GRID_ROWS - 1) { gameover(); goto Start; } else posY++; break;
         case 3: if (posX == GRID_COLS - 1) { gameover(); goto Start; } else posX++; break;
      }

      uchar tailX = getX(0), tailY = getY(0);
      for (i = 0; i < LENGTH_SNAKE - 1; i++) {
         setX(i, getX(i + 1)); setY(i, getY(i + 1));
      }
      setX(LENGTH_SNAKE - 1, posX);
      setY(LENGTH_SNAKE - 1, posY);

      for (i = 0; i < LENGTH_SNAKE - 1; i++) {
         if (getX(i) == posX && getY(i) == posY) {
            gameover(); goto Start;
         }
      }

      fillCell(posX, posY, 1);
      fillCell(tailX, tailY, 0);

      if (posX == food[0] && posY == food[1]) {
         buzzer_beep(50);
         LENGTH_SNAKE++;
         if (LENGTH_SNAKE >= 64) { winScreen(); goto Start; }
         criar_comida(); score++;
         score_txt[7] = '0' + (score / 10);
         score_txt[8] = '0' + (score % 10);
         if (score > best_score) {
            best_score = score;
            best_score_txt[7] = '0' + (best_score / 10);
            best_score_txt[8] = '0' + (best_score % 10);
         }
         writeScore();
      }

      delay_ms(gameSettings.delay_time * 300);
   }
}

