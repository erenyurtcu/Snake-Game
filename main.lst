CCS PCM C Compiler, Version 5.025, 5967               24-May-25 16:00

               Filename:   C:\Users\Eren\Documents\CCS C Projects\snake_project\main.lst

               ROM used:   2402 words (29%)
                           Largest free fragment is 2048
               RAM used:   128 (35%) at main() level
                           153 (42%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDLW  0B
0008:  BTFSC  03.0
0009:  INCF   0A,F
000A:  MOVWF  02
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  5F
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  03
0017:  RETLW  00
0018:  RETLW  03
0019:  RETLW  00
001A:  RETLW  14
001B:  RETLW  3E
001C:  RETLW  14
001D:  RETLW  3E
001E:  RETLW  14
001F:  RETLW  24
0020:  RETLW  2A
0021:  RETLW  7F
0022:  RETLW  2A
0023:  RETLW  12
0024:  RETLW  43
0025:  RETLW  33
0026:  RETLW  08
0027:  RETLW  66
0028:  RETLW  61
0029:  RETLW  36
002A:  RETLW  49
002B:  RETLW  55
002C:  RETLW  22
002D:  RETLW  50
002E:  RETLW  00
002F:  RETLW  05
0030:  RETLW  03
0031:  RETLW  00
0032:  RETLW  00
0033:  RETLW  00
0034:  RETLW  1C
0035:  RETLW  22
0036:  RETLW  41
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  41
003A:  RETLW  22
003B:  RETLW  1C
003C:  RETLW  00
003D:  RETLW  14
003E:  RETLW  08
003F:  RETLW  3E
0040:  RETLW  08
0041:  RETLW  14
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  3E
0045:  RETLW  08
0046:  RETLW  08
0047:  RETLW  00
0048:  RETLW  50
0049:  RETLW  30
004A:  RETLW  00
004B:  RETLW  00
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  08
004F:  RETLW  08
0050:  RETLW  08
0051:  RETLW  00
0052:  RETLW  60
0053:  RETLW  60
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  20
0057:  RETLW  10
0058:  RETLW  08
0059:  RETLW  04
005A:  RETLW  02
005B:  RETLW  3E
005C:  RETLW  51
005D:  RETLW  49
005E:  RETLW  45
005F:  RETLW  3E
0060:  RETLW  04
0061:  RETLW  02
0062:  RETLW  7F
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  61
0067:  RETLW  51
0068:  RETLW  49
0069:  RETLW  46
006A:  RETLW  22
006B:  RETLW  41
006C:  RETLW  49
006D:  RETLW  49
006E:  RETLW  36
006F:  RETLW  18
0070:  RETLW  14
0071:  RETLW  12
0072:  RETLW  7F
0073:  RETLW  10
0074:  RETLW  27
0075:  RETLW  45
0076:  RETLW  45
0077:  RETLW  45
0078:  RETLW  39
0079:  RETLW  3E
007A:  RETLW  49
007B:  RETLW  49
007C:  RETLW  49
007D:  RETLW  32
007E:  RETLW  01
007F:  RETLW  01
0080:  RETLW  71
0081:  RETLW  09
0082:  RETLW  07
0083:  RETLW  36
0084:  RETLW  49
0085:  RETLW  49
0086:  RETLW  49
0087:  RETLW  36
0088:  RETLW  26
0089:  RETLW  49
008A:  RETLW  49
008B:  RETLW  49
008C:  RETLW  3E
008D:  RETLW  00
008E:  RETLW  36
008F:  RETLW  36
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  56
0094:  RETLW  36
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  08
0098:  RETLW  14
0099:  RETLW  22
009A:  RETLW  41
009B:  RETLW  00
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  14
009F:  RETLW  14
00A0:  RETLW  14
00A1:  RETLW  00
00A2:  RETLW  41
00A3:  RETLW  22
00A4:  RETLW  14
00A5:  RETLW  08
00A6:  RETLW  02
00A7:  RETLW  01
00A8:  RETLW  51
00A9:  RETLW  09
00AA:  RETLW  06
00AB:  RETLW  3E
00AC:  RETLW  41
00AD:  RETLW  59
00AE:  RETLW  55
00AF:  RETLW  5E
00B0:  RETLW  7E
00B1:  RETLW  09
00B2:  RETLW  09
00B3:  RETLW  09
00B4:  RETLW  7E
00B5:  RETLW  7F
00B6:  RETLW  49
00B7:  RETLW  49
00B8:  RETLW  49
00B9:  RETLW  36
00BA:  RETLW  3E
00BB:  RETLW  41
00BC:  RETLW  41
00BD:  RETLW  41
00BE:  RETLW  22
00BF:  RETLW  7F
00C0:  RETLW  41
00C1:  RETLW  41
00C2:  RETLW  41
00C3:  RETLW  3E
00C4:  RETLW  7F
00C5:  RETLW  49
00C6:  RETLW  49
00C7:  RETLW  49
00C8:  RETLW  41
00C9:  RETLW  7F
00CA:  RETLW  09
00CB:  RETLW  09
00CC:  RETLW  09
00CD:  RETLW  01
00CE:  RETLW  3E
00CF:  RETLW  41
00D0:  RETLW  41
00D1:  RETLW  49
00D2:  RETLW  3A
00D3:  RETLW  7F
00D4:  RETLW  08
00D5:  RETLW  08
00D6:  RETLW  08
00D7:  RETLW  7F
00D8:  RETLW  00
00D9:  RETLW  41
00DA:  RETLW  7F
00DB:  RETLW  41
00DC:  RETLW  00
00DD:  RETLW  30
00DE:  RETLW  40
00DF:  RETLW  40
00E0:  RETLW  40
00E1:  RETLW  3F
00E2:  RETLW  7F
00E3:  RETLW  08
00E4:  RETLW  14
00E5:  RETLW  22
00E6:  RETLW  41
00E7:  RETLW  7F
00E8:  RETLW  40
00E9:  RETLW  40
00EA:  RETLW  40
00EB:  RETLW  40
00EC:  RETLW  7F
00ED:  RETLW  02
00EE:  RETLW  0C
00EF:  RETLW  02
00F0:  RETLW  7F
00F1:  RETLW  7F
00F2:  RETLW  02
00F3:  RETLW  04
00F4:  RETLW  08
00F5:  RETLW  7F
00F6:  RETLW  3E
00F7:  RETLW  41
00F8:  RETLW  41
00F9:  RETLW  41
00FA:  RETLW  3E
00FB:  RETLW  7F
00FC:  RETLW  09
00FD:  RETLW  09
00FE:  RETLW  09
00FF:  RETLW  06
0100:  RETLW  1E
0101:  RETLW  21
0102:  RETLW  21
0103:  RETLW  21
0104:  RETLW  5E
0105:  RETLW  7F
0106:  RETLW  09
0107:  RETLW  09
0108:  RETLW  09
0109:  RETLW  76
010A:  BSF    0A.0
010B:  BCF    0A.1
010C:  BCF    0A.2
010D:  ADDWF  02,F
010E:  RETLW  26
010F:  RETLW  49
0110:  RETLW  49
0111:  RETLW  49
0112:  RETLW  32
0113:  RETLW  01
0114:  RETLW  01
0115:  RETLW  7F
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  3F
0119:  RETLW  40
011A:  RETLW  40
011B:  RETLW  40
011C:  RETLW  3F
011D:  RETLW  1F
011E:  RETLW  20
011F:  RETLW  40
0120:  RETLW  20
0121:  RETLW  1F
0122:  RETLW  7F
0123:  RETLW  20
0124:  RETLW  10
0125:  RETLW  20
0126:  RETLW  7F
0127:  RETLW  41
0128:  RETLW  22
0129:  RETLW  1C
012A:  RETLW  22
012B:  RETLW  41
012C:  RETLW  07
012D:  RETLW  08
012E:  RETLW  70
012F:  RETLW  08
0130:  RETLW  07
0131:  RETLW  61
0132:  RETLW  51
0133:  RETLW  49
0134:  RETLW  45
0135:  RETLW  43
0136:  RETLW  00
0137:  RETLW  7F
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  02
013C:  RETLW  04
013D:  RETLW  08
013E:  RETLW  10
013F:  RETLW  20
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  41
0143:  RETLW  7F
0144:  RETLW  00
0145:  RETLW  04
0146:  RETLW  02
0147:  RETLW  01
0148:  RETLW  02
0149:  RETLW  04
014A:  RETLW  40
014B:  RETLW  40
014C:  RETLW  40
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  00
0150:  RETLW  01
0151:  RETLW  02
0152:  RETLW  04
0153:  RETLW  00
0154:  RETLW  20
0155:  RETLW  54
0156:  RETLW  54
0157:  RETLW  54
0158:  RETLW  78
0159:  RETLW  7F
015A:  RETLW  44
015B:  RETLW  44
015C:  RETLW  44
015D:  RETLW  38
015E:  RETLW  38
015F:  RETLW  44
0160:  RETLW  44
0161:  RETLW  44
0162:  RETLW  44
0163:  RETLW  38
0164:  RETLW  44
0165:  RETLW  44
0166:  RETLW  44
0167:  RETLW  7F
0168:  RETLW  38
0169:  RETLW  54
016A:  RETLW  54
016B:  RETLW  54
016C:  RETLW  18
016D:  RETLW  04
016E:  RETLW  04
016F:  RETLW  7E
0170:  RETLW  05
0171:  RETLW  05
0172:  RETLW  08
0173:  RETLW  54
0174:  RETLW  54
0175:  RETLW  54
0176:  RETLW  3C
0177:  RETLW  7F
0178:  RETLW  08
0179:  RETLW  04
017A:  RETLW  04
017B:  RETLW  78
017C:  RETLW  00
017D:  RETLW  44
017E:  RETLW  7D
017F:  RETLW  40
0180:  RETLW  00
0181:  RETLW  20
0182:  RETLW  40
0183:  RETLW  44
0184:  RETLW  3D
0185:  RETLW  00
0186:  RETLW  7F
0187:  RETLW  10
0188:  RETLW  28
0189:  RETLW  44
018A:  RETLW  00
018B:  RETLW  00
018C:  RETLW  41
018D:  RETLW  7F
018E:  RETLW  40
018F:  RETLW  00
0190:  RETLW  7C
0191:  RETLW  04
0192:  RETLW  78
0193:  RETLW  04
0194:  RETLW  78
0195:  RETLW  7C
0196:  RETLW  08
0197:  RETLW  04
0198:  RETLW  04
0199:  RETLW  78
019A:  RETLW  38
019B:  RETLW  44
019C:  RETLW  44
019D:  RETLW  44
019E:  RETLW  38
019F:  RETLW  7C
01A0:  RETLW  14
01A1:  RETLW  14
01A2:  RETLW  14
01A3:  RETLW  08
01A4:  RETLW  08
01A5:  RETLW  14
01A6:  RETLW  14
01A7:  RETLW  14
01A8:  RETLW  7C
01A9:  RETLW  00
01AA:  RETLW  7C
01AB:  RETLW  08
01AC:  RETLW  04
01AD:  RETLW  04
01AE:  RETLW  48
01AF:  RETLW  54
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  20
01B3:  RETLW  04
01B4:  RETLW  04
01B5:  RETLW  3F
01B6:  RETLW  44
01B7:  RETLW  44
01B8:  RETLW  3C
01B9:  RETLW  40
01BA:  RETLW  40
01BB:  RETLW  20
01BC:  RETLW  7C
01BD:  RETLW  1C
01BE:  RETLW  20
01BF:  RETLW  40
01C0:  RETLW  20
01C1:  RETLW  1C
01C2:  RETLW  3C
01C3:  RETLW  40
01C4:  RETLW  30
01C5:  RETLW  40
01C6:  RETLW  3C
01C7:  RETLW  44
01C8:  RETLW  28
01C9:  RETLW  10
01CA:  RETLW  28
01CB:  RETLW  44
01CC:  RETLW  0C
01CD:  RETLW  50
01CE:  RETLW  50
01CF:  RETLW  50
01D0:  RETLW  3C
01D1:  RETLW  44
01D2:  RETLW  64
01D3:  RETLW  54
01D4:  RETLW  4C
01D5:  RETLW  44
01D6:  RETLW  00
01D7:  RETLW  08
01D8:  RETLW  36
01D9:  RETLW  41
01DA:  RETLW  41
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  7F
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  41
01E1:  RETLW  41
01E2:  RETLW  36
01E3:  RETLW  08
01E4:  RETLW  00
01E5:  RETLW  02
01E6:  RETLW  01
01E7:  RETLW  02
01E8:  RETLW  04
01E9:  RETLW  02
*
0216:  CLRF   77
0217:  CLRF   78
0218:  BSF    03.5
0219:  MOVF   52,W
021A:  BCF    03.0
021B:  BTFSC  53.0
021C:  ADDWF  77,F
021D:  RRF    77,F
021E:  RRF    78,F
021F:  BTFSC  53.1
0220:  ADDWF  77,F
0221:  RRF    77,F
0222:  RRF    78,F
0223:  BTFSC  53.2
0224:  ADDWF  77,F
0225:  RRF    77,F
0226:  RRF    78,F
0227:  BTFSC  53.3
0228:  ADDWF  77,F
0229:  RRF    77,F
022A:  RRF    78,F
022B:  BTFSC  53.4
022C:  ADDWF  77,F
022D:  RRF    77,F
022E:  RRF    78,F
022F:  BTFSC  53.5
0230:  ADDWF  77,F
0231:  RRF    77,F
0232:  RRF    78,F
0233:  BTFSC  53.6
0234:  ADDWF  77,F
0235:  RRF    77,F
0236:  RRF    78,F
0237:  BTFSC  53.7
0238:  ADDWF  77,F
0239:  RRF    77,F
023A:  RRF    78,F
023B:  BCF    03.5
023C:  RETURN
*
05E2:  CLRF   78
05E3:  CLRF   79
05E4:  CLRF   77
05E5:  CLRF   7A
05E6:  BSF    03.5
05E7:  MOVF   47,W
05E8:  BTFSS  03.2
05E9:  GOTO   5ED
05EA:  MOVF   46,W
05EB:  BTFSC  03.2
05EC:  GOTO   607
05ED:  MOVLW  10
05EE:  MOVWF  48
05EF:  BCF    03.0
05F0:  RLF    44,F
05F1:  RLF    45,F
05F2:  RLF    77,F
05F3:  RLF    7A,F
05F4:  MOVF   47,W
05F5:  SUBWF  7A,W
05F6:  BTFSS  03.2
05F7:  GOTO   5FA
05F8:  MOVF   46,W
05F9:  SUBWF  77,W
05FA:  BTFSS  03.0
05FB:  GOTO   603
05FC:  MOVF   46,W
05FD:  SUBWF  77,F
05FE:  BTFSS  03.0
05FF:  DECF   7A,F
0600:  MOVF   47,W
0601:  SUBWF  7A,F
0602:  BSF    03.0
0603:  RLF    78,F
0604:  RLF    79,F
0605:  DECFSZ 48,F
0606:  GOTO   5EF
0607:  BCF    03.5
0608:  RETURN
*
0620:  MOVLW  20
0621:  MOVWF  4D
0622:  CLRF   49
0623:  CLRF   4A
0624:  CLRF   4B
0625:  CLRF   4C
0626:  MOVF   44,W
0627:  MOVWF  7A
0628:  MOVF   43,W
0629:  MOVWF  79
062A:  MOVF   42,W
062B:  MOVWF  78
062C:  MOVF   41,W
062D:  MOVWF  77
062E:  BCF    03.0
062F:  BTFSS  77.0
0630:  GOTO   63F
0631:  MOVF   45,W
0632:  ADDWF  49,F
0633:  MOVF   46,W
0634:  BTFSC  03.0
0635:  INCFSZ 46,W
0636:  ADDWF  4A,F
0637:  MOVF   47,W
0638:  BTFSC  03.0
0639:  INCFSZ 47,W
063A:  ADDWF  4B,F
063B:  MOVF   48,W
063C:  BTFSC  03.0
063D:  INCFSZ 48,W
063E:  ADDWF  4C,F
063F:  RRF    4C,F
0640:  RRF    4B,F
0641:  RRF    4A,F
0642:  RRF    49,F
0643:  RRF    7A,F
0644:  RRF    79,F
0645:  RRF    78,F
0646:  RRF    77,F
0647:  DECFSZ 4D,F
0648:  GOTO   62E
*
0736:  BSF    03.5
0737:  MOVF   40,W
0738:  CLRF   78
0739:  SUBWF  3F,W
073A:  BTFSC  03.0
073B:  GOTO   73F
073C:  MOVF   3F,W
073D:  MOVWF  77
073E:  GOTO   74B
073F:  CLRF   77
0740:  MOVLW  08
0741:  MOVWF  41
0742:  RLF    3F,F
0743:  RLF    77,F
0744:  MOVF   40,W
0745:  SUBWF  77,W
0746:  BTFSC  03.0
0747:  MOVWF  77
0748:  RLF    78,F
0749:  DECFSZ 41,F
074A:  GOTO   742
074B:  BCF    03.5
074C:  RETURN
*
0A0D:  BCF    0A.0
0A0E:  BSF    0A.1
0A0F:  BCF    0A.2
0A10:  ADDWF  02,F
0A11:  GOTO   0E8
0A12:  GOTO   0F6
0A13:  GOTO   104
0A14:  GOTO   113
....................  
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=16000000) 
*
04C8:  MOVLW  C2
04C9:  MOVWF  04
04CA:  BCF    03.7
04CB:  MOVF   00,W
04CC:  BTFSC  03.2
04CD:  GOTO   4DC
04CE:  MOVLW  05
04CF:  MOVWF  78
04D0:  CLRF   77
04D1:  DECFSZ 77,F
04D2:  GOTO   4D1
04D3:  DECFSZ 78,F
04D4:  GOTO   4D0
04D5:  MOVLW  2E
04D6:  MOVWF  77
04D7:  DECFSZ 77,F
04D8:  GOTO   4D7
04D9:  GOTO   4DA
04DA:  DECFSZ 00,F
04DB:  GOTO   4CE
04DC:  RETURN
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0816:  BCF    03.5
0817:  CLRF   20
0818:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
0609:  MOVF   25,W
060A:  BSF    03.5
060B:  MOVWF  44
060C:  BCF    03.5
060D:  MOVF   24,W
060E:  BSF    03.5
060F:  MOVWF  43
0610:  BCF    03.5
0611:  MOVF   23,W
0612:  BSF    03.5
0613:  MOVWF  42
0614:  BCF    03.5
0615:  MOVF   22,W
0616:  BSF    03.5
0617:  MOVWF  41
0618:  MOVLW  41
0619:  MOVWF  48
061A:  MOVLW  C6
061B:  MOVWF  47
061C:  MOVLW  4E
061D:  MOVWF  46
061E:  MOVLW  6D
061F:  MOVWF  45
*
0649:  MOVF   7A,W
064A:  MOVWF  44
064B:  MOVF   79,W
064C:  MOVWF  43
064D:  MOVF   78,W
064E:  MOVWF  42
064F:  MOVF   77,W
0650:  MOVWF  41
0651:  MOVLW  39
0652:  ADDWF  41,W
0653:  BCF    03.5
0654:  MOVWF  22
0655:  BSF    03.5
0656:  MOVF   42,W
0657:  BCF    03.5
0658:  MOVWF  23
0659:  MOVLW  30
065A:  BTFSC  03.0
065B:  MOVLW  31
065C:  ADDWF  23,F
065D:  BSF    03.5
065E:  MOVF   43,W
065F:  BCF    03.5
0660:  MOVWF  24
0661:  MOVLW  00
0662:  BTFSC  03.0
0663:  MOVLW  01
0664:  ADDWF  24,F
0665:  BSF    03.5
0666:  MOVF   44,W
0667:  BCF    03.5
0668:  MOVWF  25
0669:  MOVLW  00
066A:  BTFSC  03.0
066B:  MOVLW  01
066C:  ADDWF  25,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
066D:  MOVF   24,W
066E:  MOVWF  77
066F:  MOVF   25,W
0670:  MOVWF  78
0671:  CLRF   79
0672:  CLRF   7A
0673:  MOVF   25,W
0674:  BSF    03.5
0675:  MOVWF  43
0676:  MOVF   77,W
0677:  MOVWF  42
0678:  MOVF   43,W
0679:  MOVWF  45
067A:  MOVF   42,W
067B:  MOVWF  44
067C:  MOVLW  7F
067D:  MOVWF  47
067E:  MOVLW  FF
067F:  MOVWF  46
0680:  BCF    03.5
0681:  CALL   5E2
0682:  MOVF   77,W
0683:  MOVWF  78
0684:  MOVF   7A,W
0685:  MOVWF  79
0686:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <glcd.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
0298:  BCF    26.0
0299:  MOVF   26,W
029A:  BSF    03.5
029B:  MOVWF  07
029C:  BCF    03.5
029D:  BSF    07.0
....................    output_low(GLCD_E); 
029E:  BSF    03.5
029F:  BCF    06.5
02A0:  BCF    03.5
02A1:  BCF    06.5
....................    output_low(GLCD_CS1); 
02A2:  BSF    03.5
02A3:  BCF    06.0
02A4:  BCF    03.5
02A5:  BCF    06.0
....................    output_low(GLCD_CS2); 
02A6:  BSF    03.5
02A7:  BCF    06.1
02A8:  BCF    03.5
02A9:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
02AA:  BSF    03.5
02AB:  BCF    06.2
02AC:  BCF    03.5
02AD:  BCF    06.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
02AE:  MOVLW  30
02AF:  BSF    03.5
02B0:  MOVWF  57
02B1:  MOVLW  C0
02B2:  MOVWF  58
02B3:  BCF    03.5
02B4:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
02B5:  MOVLW  31
02B6:  BSF    03.5
02B7:  MOVWF  57
02B8:  MOVLW  C0
02B9:  MOVWF  58
02BA:  BCF    03.5
02BB:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
02BC:  MOVLW  30
02BD:  BSF    03.5
02BE:  MOVWF  57
02BF:  MOVLW  40
02C0:  MOVWF  58
02C1:  BCF    03.5
02C2:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0x40); 
02C3:  MOVLW  31
02C4:  BSF    03.5
02C5:  MOVWF  57
02C6:  MOVLW  40
02C7:  MOVWF  58
02C8:  BCF    03.5
02C9:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
02CA:  MOVLW  30
02CB:  BSF    03.5
02CC:  MOVWF  57
02CD:  MOVLW  B8
02CE:  MOVWF  58
02CF:  BCF    03.5
02D0:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
02D1:  MOVLW  31
02D2:  BSF    03.5
02D3:  MOVWF  57
02D4:  MOVLW  B8
02D5:  MOVWF  58
02D6:  BCF    03.5
02D7:  CALL   1EA
....................    if(mode == ON) 
02D8:  BSF    03.5
02D9:  DECFSZ 3F,W
02DA:  GOTO   2EA
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
02DB:  MOVLW  30
02DC:  MOVWF  57
02DD:  MOVLW  3F
02DE:  MOVWF  58
02DF:  BCF    03.5
02E0:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
02E1:  MOVLW  31
02E2:  BSF    03.5
02E3:  MOVWF  57
02E4:  MOVLW  3F
02E5:  MOVWF  58
02E6:  BCF    03.5
02E7:  CALL   1EA
....................    } 
02E8:  GOTO   2F7
02E9:  BSF    03.5
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
02EA:  MOVLW  30
02EB:  MOVWF  57
02EC:  MOVLW  3E
02ED:  MOVWF  58
02EE:  BCF    03.5
02EF:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
02F0:  MOVLW  31
02F1:  BSF    03.5
02F2:  MOVWF  57
02F3:  MOVLW  3E
02F4:  MOVWF  58
02F5:  BCF    03.5
02F6:  CALL   1EA
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
02F7:  BSF    03.5
02F8:  CLRF   40
02F9:  BCF    03.5
02FA:  CALL   23D
02FB:  BSF    0A.3
02FC:  BCF    0A.4
02FD:  GOTO   04A (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
02FE:  MOVLW  30
02FF:  BSF    03.5
0300:  MOVWF  55
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
0301:  MOVF   51,W
0302:  SUBLW  3F
0303:  BTFSC  03.0
0304:  GOTO   309
....................    { 
....................       x -= 64; 
0305:  MOVLW  40
0306:  SUBWF  51,F
....................       chip = GLCD_CS2; 
0307:  MOVLW  31
0308:  MOVWF  55
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
0309:  BCF    06.2
030A:  BCF    03.5
030B:  BCF    06.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
030C:  BSF    03.5
030D:  BCF    51.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
030E:  BSF    51.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
030F:  MOVF   55,W
0310:  MOVWF  57
0311:  MOVF   51,W
0312:  MOVWF  58
0313:  BCF    03.5
0314:  CALL   1EA
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
0315:  BSF    03.5
0316:  RRF    52,W
0317:  MOVWF  77
0318:  RRF    77,F
0319:  RRF    77,F
031A:  MOVLW  1F
031B:  ANDWF  77,F
031C:  MOVF   77,W
031D:  ANDLW  BF
031E:  IORLW  B8
031F:  MOVWF  56
0320:  MOVF   55,W
0321:  MOVWF  57
0322:  MOVF   56,W
0323:  MOVWF  58
0324:  BCF    03.5
0325:  CALL   1EA
....................    output_high(GLCD_DI);                                    // Set for data 
0326:  BSF    03.5
0327:  BCF    06.2
0328:  BCF    03.5
0329:  BSF    06.2
....................    data = glcd_readByte(chip); 
032A:  BSF    03.5
032B:  MOVF   55,W
032C:  MOVWF  56
*
036F:  MOVF   78,W
0370:  MOVWF  54
....................  
....................    if(color == ON) 
0371:  DECFSZ 53,W
0372:  GOTO   383
....................       bit_set(data, y%8);        // Turn the pixel on 
0373:  MOVF   52,W
0374:  ANDLW  07
0375:  MOVWF  56
0376:  MOVLW  01
0377:  MOVWF  77
0378:  MOVF   56,W
0379:  MOVWF  78
037A:  BTFSC  03.2
037B:  GOTO   380
037C:  BCF    03.0
037D:  RLF    77,F
037E:  DECFSZ 78,F
037F:  GOTO   37C
0380:  MOVF   77,W
0381:  IORWF  54,F
0382:  GOTO   393
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
0383:  MOVF   52,W
0384:  ANDLW  07
0385:  MOVWF  56
0386:  MOVLW  01
0387:  MOVWF  77
0388:  MOVF   56,W
0389:  MOVWF  78
038A:  BTFSC  03.2
038B:  GOTO   390
038C:  BCF    03.0
038D:  RLF    77,F
038E:  DECFSZ 78,F
038F:  GOTO   38C
0390:  MOVF   77,W
0391:  XORLW  FF
0392:  ANDWF  54,F
....................    output_low(GLCD_DI);          // Set for instruction 
0393:  BCF    06.2
0394:  BCF    03.5
0395:  BCF    06.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
0396:  BSF    03.5
0397:  MOVF   55,W
0398:  MOVWF  57
0399:  MOVF   51,W
039A:  MOVWF  58
039B:  BCF    03.5
039C:  CALL   1EA
....................    output_high(GLCD_DI);         // Set for data 
039D:  BSF    03.5
039E:  BCF    06.2
039F:  BCF    03.5
03A0:  BSF    06.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
03A1:  BSF    03.5
03A2:  MOVF   55,W
03A3:  MOVWF  57
03A4:  MOVF   54,W
03A5:  MOVWF  58
03A6:  BCF    03.5
03A7:  CALL   1EA
03A8:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
03A9:  BSF    03.5
03AA:  MOVF   43,W
03AB:  SUBWF  45,W
03AC:  MOVWF  51
03AD:  MOVF   51,W
03AE:  BTFSS  51.7
03AF:  GOTO   3B2
03B0:  MOVF   51,W
03B1:  SUBLW  00
03B2:  MOVWF  4C
....................    dy = abs((signed int)(y2 - y1)); 
03B3:  MOVF   44,W
03B4:  SUBWF  46,W
03B5:  MOVWF  51
03B6:  MOVF   51,W
03B7:  BTFSS  51.7
03B8:  GOTO   3BB
03B9:  MOVF   51,W
03BA:  SUBLW  00
03BB:  MOVWF  4D
....................    x = x1; 
03BC:  MOVF   43,W
03BD:  MOVWF  48
....................    y = y1; 
03BE:  MOVF   44,W
03BF:  MOVWF  49
....................  
....................    if(x1 > x2) 
03C0:  MOVF   43,W
03C1:  SUBWF  45,W
03C2:  BTFSC  03.0
03C3:  GOTO   3C7
....................       addx = -1; 
03C4:  MOVLW  FF
03C5:  MOVWF  4A
03C6:  GOTO   3C9
....................    else 
....................       addx = 1; 
03C7:  MOVLW  01
03C8:  MOVWF  4A
....................    if(y1 > y2) 
03C9:  MOVF   44,W
03CA:  SUBWF  46,W
03CB:  BTFSC  03.0
03CC:  GOTO   3D0
....................       addy = -1; 
03CD:  MOVLW  FF
03CE:  MOVWF  4B
03CF:  GOTO   3D2
....................    else 
....................       addy = 1; 
03D0:  MOVLW  01
03D1:  MOVWF  4B
....................  
....................    if(dx >= dy) 
03D2:  MOVF   4D,W
03D3:  XORLW  80
03D4:  MOVWF  77
03D5:  MOVF   4C,W
03D6:  XORLW  80
03D7:  SUBWF  77,W
03D8:  BTFSC  03.2
03D9:  GOTO   3DC
03DA:  BTFSC  03.0
03DB:  GOTO   434
....................    { 
....................       P = 2*dy - dx; 
03DC:  MOVLW  02
03DD:  MOVWF  52
03DE:  MOVF   4D,W
03DF:  MOVWF  53
03E0:  BCF    03.5
03E1:  CALL   216
03E2:  BSF    03.5
03E3:  MOVF   4C,W
03E4:  SUBWF  78,W
03E5:  CLRF   7A
03E6:  MOVWF  77
03E7:  BTFSC  77.7
03E8:  DECF   7A,F
03E9:  MOVWF  4E
03EA:  MOVF   7A,W
03EB:  MOVWF  4F
....................  
....................       for(i=0; i<=dx; ++i) 
03EC:  CLRF   50
03ED:  BTFSC  4C.7
03EE:  GOTO   433
03EF:  MOVF   50,W
03F0:  SUBWF  4C,W
03F1:  BTFSS  03.0
03F2:  GOTO   433
....................       { 
....................          glcd_pixel(x, y, color); 
03F3:  MOVF   48,W
03F4:  MOVWF  51
03F5:  MOVF   49,W
03F6:  MOVWF  52
03F7:  MOVF   47,W
03F8:  MOVWF  53
03F9:  BCF    03.5
03FA:  CALL   2FE
....................  
....................          if(P < 0) 
03FB:  BSF    03.5
03FC:  BTFSS  4F.7
03FD:  GOTO   412
....................          { 
....................             P += 2*dy; 
03FE:  MOVLW  02
03FF:  MOVWF  52
0400:  MOVF   4D,W
0401:  MOVWF  53
0402:  BCF    03.5
0403:  CALL   216
0404:  MOVF   78,W
0405:  CLRF   7A
0406:  MOVWF  77
0407:  BTFSC  77.7
0408:  DECF   7A,F
0409:  BSF    03.5
040A:  ADDWF  4E,F
040B:  MOVF   7A,W
040C:  BTFSC  03.0
040D:  INCFSZ 7A,W
040E:  ADDWF  4F,F
....................             x += addx; 
040F:  MOVF   4A,W
0410:  ADDWF  48,F
....................          } 
0411:  GOTO   431
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
0412:  MOVLW  02
0413:  MOVWF  52
0414:  MOVF   4D,W
0415:  MOVWF  53
0416:  BCF    03.5
0417:  CALL   216
0418:  MOVF   78,W
0419:  BSF    03.5
041A:  MOVWF  51
041B:  MOVLW  02
041C:  MOVWF  52
041D:  MOVF   4C,W
041E:  MOVWF  53
041F:  BCF    03.5
0420:  CALL   216
0421:  MOVF   78,W
0422:  BSF    03.5
0423:  SUBWF  51,W
0424:  CLRF   7A
0425:  MOVWF  77
0426:  BTFSC  77.7
0427:  DECF   7A,F
0428:  ADDWF  4E,F
0429:  MOVF   7A,W
042A:  BTFSC  03.0
042B:  INCFSZ 7A,W
042C:  ADDWF  4F,F
....................             x += addx; 
042D:  MOVF   4A,W
042E:  ADDWF  48,F
....................             y += addy; 
042F:  MOVF   4B,W
0430:  ADDWF  49,F
....................          } 
0431:  INCF   50,F
0432:  GOTO   3ED
....................       } 
....................    } 
0433:  GOTO   48B
....................    else 
....................    { 
....................       P = 2*dx - dy; 
0434:  MOVLW  02
0435:  MOVWF  52
0436:  MOVF   4C,W
0437:  MOVWF  53
0438:  BCF    03.5
0439:  CALL   216
043A:  BSF    03.5
043B:  MOVF   4D,W
043C:  SUBWF  78,W
043D:  CLRF   7A
043E:  MOVWF  77
043F:  BTFSC  77.7
0440:  DECF   7A,F
0441:  MOVWF  4E
0442:  MOVF   7A,W
0443:  MOVWF  4F
....................  
....................       for(i=0; i<=dy; ++i) 
0444:  CLRF   50
0445:  BTFSC  4D.7
0446:  GOTO   48B
0447:  MOVF   50,W
0448:  SUBWF  4D,W
0449:  BTFSS  03.0
044A:  GOTO   48B
....................       { 
....................          glcd_pixel(x, y, color); 
044B:  MOVF   48,W
044C:  MOVWF  51
044D:  MOVF   49,W
044E:  MOVWF  52
044F:  MOVF   47,W
0450:  MOVWF  53
0451:  BCF    03.5
0452:  CALL   2FE
....................  
....................          if(P < 0) 
0453:  BSF    03.5
0454:  BTFSS  4F.7
0455:  GOTO   46A
....................          { 
....................             P += 2*dx; 
0456:  MOVLW  02
0457:  MOVWF  52
0458:  MOVF   4C,W
0459:  MOVWF  53
045A:  BCF    03.5
045B:  CALL   216
045C:  MOVF   78,W
045D:  CLRF   7A
045E:  MOVWF  77
045F:  BTFSC  77.7
0460:  DECF   7A,F
0461:  BSF    03.5
0462:  ADDWF  4E,F
0463:  MOVF   7A,W
0464:  BTFSC  03.0
0465:  INCFSZ 7A,W
0466:  ADDWF  4F,F
....................             y += addy; 
0467:  MOVF   4B,W
0468:  ADDWF  49,F
....................          } 
0469:  GOTO   489
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
046A:  MOVLW  02
046B:  MOVWF  52
046C:  MOVF   4C,W
046D:  MOVWF  53
046E:  BCF    03.5
046F:  CALL   216
0470:  MOVF   78,W
0471:  BSF    03.5
0472:  MOVWF  51
0473:  MOVLW  02
0474:  MOVWF  52
0475:  MOVF   4D,W
0476:  MOVWF  53
0477:  BCF    03.5
0478:  CALL   216
0479:  MOVF   78,W
047A:  BSF    03.5
047B:  SUBWF  51,W
047C:  CLRF   7A
047D:  MOVWF  77
047E:  BTFSC  77.7
047F:  DECF   7A,F
0480:  ADDWF  4E,F
0481:  MOVF   7A,W
0482:  BTFSC  03.0
0483:  INCFSZ 7A,W
0484:  ADDWF  4F,F
....................             x += addx; 
0485:  MOVF   4A,W
0486:  ADDWF  48,F
....................             y += addy; 
0487:  MOVF   4B,W
0488:  ADDWF  49,F
....................          } 
0489:  INCF   50,F
048A:  GOTO   445
....................       } 
....................    } 
048B:  BCF    03.5
048C:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
*
04DD:  BSF    03.5
04DE:  CLRF   45
04DF:  MOVF   45,W
04E0:  ADDWF  41,W
04E1:  MOVWF  04
04E2:  BCF    03.7
04E3:  BTFSC  42.0
04E4:  BSF    03.7
04E5:  MOVF   00,F
04E6:  BTFSC  03.2
04E7:  GOTO   5B2
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
04E8:  MOVF   45,W
04E9:  ADDWF  41,W
04EA:  MOVWF  04
04EB:  BCF    03.7
04EC:  BTFSC  42.0
04ED:  BSF    03.7
04EE:  MOVF   00,W
04EF:  SUBLW  52
04F0:  BTFSS  03.0
04F1:  GOTO   516
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
04F2:  MOVF   45,W
04F3:  ADDWF  41,W
04F4:  MOVWF  04
04F5:  BCF    03.7
04F6:  BTFSC  42.0
04F7:  BSF    03.7
04F8:  MOVLW  20
04F9:  SUBWF  00,W
04FA:  MOVWF  50
04FB:  MOVWF  52
04FC:  MOVLW  05
04FD:  MOVWF  53
04FE:  BCF    03.5
04FF:  CALL   216
0500:  MOVF   78,W
0501:  BSF    03.5
0502:  MOVWF  4F
0503:  MOVWF  78
0504:  MOVLW  05
0505:  MOVWF  77
0506:  MOVLW  CA
0507:  MOVWF  04
0508:  BCF    03.7
0509:  MOVF   78,W
050A:  BCF    03.5
050B:  CALL   004
050C:  MOVWF  00
050D:  INCF   78,F
050E:  INCF   04,F
050F:  DECFSZ 77,F
0510:  GOTO   512
0511:  GOTO   514
0512:  BSF    03.5
0513:  GOTO   509
0514:  GOTO   54A
0515:  BSF    03.5
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
0516:  MOVF   45,W
0517:  ADDWF  41,W
0518:  MOVWF  04
0519:  BCF    03.7
051A:  BTFSC  42.0
051B:  BSF    03.7
051C:  MOVF   00,W
051D:  SUBLW  7E
051E:  BTFSS  03.0
051F:  GOTO   544
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
0520:  MOVF   45,W
0521:  ADDWF  41,W
0522:  MOVWF  04
0523:  BCF    03.7
0524:  BTFSC  42.0
0525:  BSF    03.7
0526:  MOVLW  53
0527:  SUBWF  00,W
0528:  MOVWF  50
0529:  MOVWF  52
052A:  MOVLW  05
052B:  MOVWF  53
052C:  BCF    03.5
052D:  CALL   216
052E:  MOVF   78,W
052F:  BSF    03.5
0530:  MOVWF  4F
0531:  MOVWF  78
0532:  MOVLW  05
0533:  MOVWF  77
0534:  MOVLW  CA
0535:  MOVWF  04
0536:  BCF    03.7
0537:  MOVF   78,W
0538:  BCF    03.5
0539:  CALL   10A
053A:  MOVWF  00
053B:  INCF   78,F
053C:  INCF   04,F
053D:  DECFSZ 77,F
053E:  GOTO   540
053F:  GOTO   542
0540:  BSF    03.5
0541:  GOTO   537
0542:  GOTO   54A
0543:  BSF    03.5
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
0544:  CLRF   4A
0545:  CLRF   4B
0546:  CLRF   4C
0547:  CLRF   4D
0548:  CLRF   4E
0549:  BCF    03.5
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
054A:  MOVLW  05
054B:  BSF    03.5
054C:  MOVWF  52
054D:  MOVF   43,W
054E:  MOVWF  53
054F:  BCF    03.5
0550:  CALL   216
0551:  MOVF   78,W
0552:  BSF    03.5
0553:  ADDWF  3F,W
0554:  SUBLW  7F
0555:  BTFSC  03.0
0556:  GOTO   562
....................       { 
....................          x = 0;                           // Set x at far left position 
0557:  CLRF   3F
....................          y += 7*size + 1;                 // Set y at next position down 
0558:  MOVLW  07
0559:  MOVWF  52
055A:  MOVF   43,W
055B:  MOVWF  53
055C:  BCF    03.5
055D:  CALL   216
055E:  MOVLW  01
055F:  ADDWF  78,W
0560:  BSF    03.5
0561:  ADDWF  40,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0562:  CLRF   46
0563:  MOVF   46,W
0564:  SUBLW  04
0565:  BTFSS  03.0
0566:  GOTO   5AF
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
0567:  CLRF   47
0568:  MOVLW  07
0569:  MOVWF  52
056A:  MOVF   43,W
056B:  MOVWF  53
056C:  BCF    03.5
056D:  CALL   216
056E:  MOVF   78,W
056F:  BSF    03.5
0570:  SUBWF  47,W
0571:  BTFSC  03.0
0572:  GOTO   5AB
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
0573:  MOVLW  CA
0574:  ADDWF  46,W
0575:  MOVWF  04
0576:  BCF    03.7
0577:  MOVF   00,W
0578:  MOVWF  4F
0579:  MOVWF  77
057A:  MOVF   47,W
057B:  MOVWF  78
057C:  BTFSC  03.2
057D:  GOTO   582
057E:  BCF    03.0
057F:  RRF    77,F
0580:  DECFSZ 78,F
0581:  GOTO   57E
0582:  BTFSS  77.0
0583:  GOTO   5A9
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
0584:  CLRF   48
0585:  MOVF   43,W
0586:  SUBWF  48,W
0587:  BTFSC  03.0
0588:  GOTO   5A9
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
0589:  CLRF   49
058A:  MOVF   43,W
058B:  SUBWF  49,W
058C:  BTFSC  03.0
058D:  GOTO   5A7
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
058E:  MOVF   49,W
058F:  ADDWF  3F,W
0590:  MOVWF  4F
0591:  MOVF   47,W
0592:  MOVWF  52
0593:  MOVF   43,W
0594:  MOVWF  53
0595:  BCF    03.5
0596:  CALL   216
0597:  MOVF   78,W
0598:  BSF    03.5
0599:  ADDWF  40,W
059A:  ADDWF  48,W
059B:  MOVWF  50
059C:  MOVF   4F,W
059D:  MOVWF  51
059E:  MOVF   50,W
059F:  MOVWF  52
05A0:  MOVF   44,W
05A1:  MOVWF  53
05A2:  BCF    03.5
05A3:  CALL   2FE
05A4:  BSF    03.5
05A5:  INCF   49,F
05A6:  GOTO   58A
....................                   } 
05A7:  INCF   48,F
05A8:  GOTO   585
....................                } 
....................             } 
05A9:  INCF   47,F
05AA:  GOTO   568
....................          } 
05AB:  INCF   46,F
05AC:  MOVF   43,W
05AD:  ADDWF  3F,F
05AE:  GOTO   563
....................       } 
05AF:  INCF   45,F
05B0:  INCF   3F,F
05B1:  GOTO   4DF
....................    } 
05B2:  BCF    03.5
05B3:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
023D:  BSF    03.5
023E:  CLRF   41
023F:  MOVF   41,W
0240:  SUBLW  07
0241:  BTFSS  03.0
0242:  GOTO   296
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
0243:  BCF    06.2
0244:  BCF    03.5
0245:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0246:  MOVLW  30
0247:  BSF    03.5
0248:  MOVWF  57
0249:  MOVLW  40
024A:  MOVWF  58
024B:  BCF    03.5
024C:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
024D:  MOVLW  31
024E:  BSF    03.5
024F:  MOVWF  57
0250:  MOVLW  40
0251:  MOVWF  58
0252:  BCF    03.5
0253:  CALL   1EA
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
0254:  BSF    03.5
0255:  MOVF   41,W
0256:  IORLW  B8
0257:  MOVWF  43
0258:  MOVLW  30
0259:  MOVWF  57
025A:  MOVF   43,W
025B:  MOVWF  58
025C:  BCF    03.5
025D:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
025E:  BSF    03.5
025F:  MOVF   41,W
0260:  IORLW  B8
0261:  MOVWF  43
0262:  MOVLW  31
0263:  MOVWF  57
0264:  MOVF   43,W
0265:  MOVWF  58
0266:  BCF    03.5
0267:  CALL   1EA
....................       output_high(GLCD_DI);                     // Set for data 
0268:  BSF    03.5
0269:  BCF    06.2
026A:  BCF    03.5
026B:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
026C:  BSF    03.5
026D:  CLRF   42
026E:  MOVF   42,W
026F:  SUBLW  3F
0270:  BTFSS  03.0
0271:  GOTO   294
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0272:  MOVLW  FF
0273:  MOVWF  52
0274:  MOVF   40,W
0275:  MOVWF  53
0276:  BCF    03.5
0277:  CALL   216
0278:  MOVF   78,W
0279:  BSF    03.5
027A:  MOVWF  43
027B:  MOVLW  30
027C:  MOVWF  57
027D:  MOVF   43,W
027E:  MOVWF  58
027F:  BCF    03.5
0280:  CALL   1EA
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
0281:  MOVLW  FF
0282:  BSF    03.5
0283:  MOVWF  52
0284:  MOVF   40,W
0285:  MOVWF  53
0286:  BCF    03.5
0287:  CALL   216
0288:  MOVF   78,W
0289:  BSF    03.5
028A:  MOVWF  43
028B:  MOVLW  31
028C:  MOVWF  57
028D:  MOVF   43,W
028E:  MOVWF  58
028F:  BCF    03.5
0290:  CALL   1EA
0291:  BSF    03.5
0292:  INCF   42,F
0293:  GOTO   26E
....................       } 
0294:  INCF   41,F
0295:  GOTO   23F
....................    } 
0296:  BCF    03.5
0297:  RETURN
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
01EA:  BSF    03.5
01EB:  MOVF   57,W
01EC:  SUBLW  30
01ED:  BTFSS  03.2
01EE:  GOTO   1F4
....................       output_high(GLCD_CS1); 
01EF:  BCF    06.0
01F0:  BCF    03.5
01F1:  BSF    06.0
01F2:  GOTO   1F7
01F3:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS2); 
01F4:  BCF    06.1
01F5:  BCF    03.5
01F6:  BSF    06.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
01F7:  BSF    03.5
01F8:  BCF    06.4
01F9:  BCF    03.5
01FA:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
01FB:  BSF    03.5
01FC:  CLRF   08
01FD:  MOVF   58,W
01FE:  BCF    03.5
01FF:  MOVWF  08
....................    output_high(GLCD_E);       // Pulse the enable pin 
0200:  BSF    03.5
0201:  BCF    06.5
0202:  BCF    03.5
0203:  BSF    06.5
....................    delay_us(2); 
0204:  MOVLW  02
0205:  MOVWF  77
0206:  DECFSZ 77,F
0207:  GOTO   206
0208:  NOP
....................    output_low(GLCD_E); 
0209:  BSF    03.5
020A:  BCF    06.5
020B:  BCF    03.5
020C:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
020D:  BSF    03.5
020E:  BCF    06.0
020F:  BCF    03.5
0210:  BCF    06.0
....................    output_low(GLCD_CS2); 
0211:  BSF    03.5
0212:  BCF    06.1
0213:  BCF    03.5
0214:  BCF    06.1
0215:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
032D:  MOVF   56,W
032E:  SUBLW  30
032F:  BTFSS  03.2
0330:  GOTO   336
....................       output_high(GLCD_CS1); 
0331:  BCF    06.0
0332:  BCF    03.5
0333:  BSF    06.0
0334:  GOTO   339
0335:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS2); 
0336:  BCF    06.1
0337:  BCF    03.5
0338:  BSF    06.1
....................  
....................    input_d();                 // Set port d to input 
0339:  MOVLW  FF
033A:  BSF    03.5
033B:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
033C:  BCF    06.4
033D:  BCF    03.5
033E:  BSF    06.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
033F:  BSF    03.5
0340:  BCF    06.5
0341:  BCF    03.5
0342:  BSF    06.5
....................    delay_us(2); 
0343:  MOVLW  02
0344:  MOVWF  77
0345:  DECFSZ 77,F
0346:  GOTO   345
0347:  NOP
....................    output_low(GLCD_E); 
0348:  BSF    03.5
0349:  BCF    06.5
034A:  BCF    03.5
034B:  BCF    06.5
....................    delay_us(2); 
034C:  MOVLW  02
034D:  MOVWF  77
034E:  DECFSZ 77,F
034F:  GOTO   34E
0350:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
0351:  BSF    03.5
0352:  BCF    06.5
0353:  BCF    03.5
0354:  BSF    06.5
....................    delay_us(2); 
0355:  MOVLW  02
0356:  MOVWF  77
0357:  DECFSZ 77,F
0358:  GOTO   357
0359:  NOP
....................    data = input_d();          // Get the data from the display's output register 
035A:  MOVLW  FF
035B:  BSF    03.5
035C:  MOVWF  08
035D:  BCF    03.5
035E:  MOVF   08,W
035F:  BSF    03.5
0360:  MOVWF  57
....................    output_low(GLCD_E); 
0361:  BCF    06.5
0362:  BCF    03.5
0363:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0364:  BSF    03.5
0365:  BCF    06.0
0366:  BCF    03.5
0367:  BCF    06.0
....................    output_low(GLCD_CS2); 
0368:  BSF    03.5
0369:  BCF    06.1
036A:  BCF    03.5
036B:  BCF    06.1
....................    return data;               // Return the read data 
036C:  BSF    03.5
036D:  MOVF   57,W
036E:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define uchar unsigned char 
....................  
.................... // Izgara parametreleri 
.................... #define GRID_SIZE     6 
.................... #define GRID_COLS     10 
.................... #define GRID_ROWS     10 
.................... #define GRID_ORIGIN_X 0 
.................... #define GRID_ORIGIN_Y 0 
....................  
.................... uchar SNAKE[40][2]; 
.................... uchar dir = 2; 
.................... uchar food[2], LENGTH_SNAKE = 10; 
.................... // Ylan biraz daha aa balatyoruz: 
.................... uchar posX = 1, posY = 2; 
.................... uchar score = 0; 
.................... char score_txt[11] = "Score: 00"; 
*
0819:  MOVLW  53
081A:  BSF    03.5
081B:  MOVWF  23
081C:  MOVLW  63
081D:  MOVWF  24
081E:  MOVLW  6F
081F:  MOVWF  25
0820:  MOVLW  72
0821:  MOVWF  26
0822:  MOVLW  65
0823:  MOVWF  27
0824:  MOVLW  3A
0825:  MOVWF  28
0826:  MOVLW  20
0827:  MOVWF  29
0828:  MOVLW  30
0829:  MOVWF  2A
082A:  MOVWF  2B
082B:  CLRF   2C
.................... char gayover[14]= "GAME OVER !!!"; 
082C:  MOVLW  47
082D:  MOVWF  2E
082E:  MOVLW  41
082F:  MOVWF  2F
0830:  MOVLW  4D
0831:  MOVWF  30
0832:  MOVLW  45
0833:  MOVWF  31
0834:  MOVLW  20
0835:  MOVWF  32
0836:  MOVLW  4F
0837:  MOVWF  33
0838:  MOVLW  56
0839:  MOVWF  34
083A:  MOVLW  45
083B:  MOVWF  35
083C:  MOVLW  52
083D:  MOVWF  36
083E:  MOVLW  20
083F:  MOVWF  37
0840:  MOVLW  21
0841:  MOVWF  38
0842:  MOVWF  39
0843:  MOVWF  3A
0844:  CLRF   3B
.................... uchar i; 
....................  
.................... // Izgaray tek seferlik iz 
.................... void drawGrid() { 
....................    for (uchar c = 0; c <= GRID_COLS; c++) { 
*
048D:  BSF    03.5
048E:  CLRF   3F
048F:  MOVF   3F,W
0490:  SUBLW  0A
0491:  BTFSS  03.0
0492:  GOTO   4AA
....................       uchar x = GRID_ORIGIN_X + c * GRID_SIZE; 
0493:  MOVF   3F,W
0494:  MOVWF  52
0495:  MOVLW  06
0496:  MOVWF  53
0497:  BCF    03.5
0498:  CALL   216
0499:  MOVF   78,W
049A:  BSF    03.5
049B:  MOVWF  40
....................       glcd_line(x, 
....................                 GRID_ORIGIN_Y, 
....................                 x, 
....................                 GRID_ORIGIN_Y + GRID_ROWS*GRID_SIZE, 
....................                 1); 
049C:  MOVF   40,W
049D:  MOVWF  43
049E:  CLRF   44
049F:  MOVF   40,W
04A0:  MOVWF  45
04A1:  MOVLW  3C
04A2:  MOVWF  46
04A3:  MOVLW  01
04A4:  MOVWF  47
04A5:  BCF    03.5
04A6:  CALL   3A9
04A7:  BSF    03.5
04A8:  INCF   3F,F
04A9:  GOTO   48F
....................    } 
....................    for (uchar r = 0; r <= GRID_ROWS; r++) { 
04AA:  CLRF   41
04AB:  MOVF   41,W
04AC:  SUBLW  0A
04AD:  BTFSS  03.0
04AE:  GOTO   4C6
....................       uchar y = GRID_ORIGIN_Y + r * GRID_SIZE; 
04AF:  MOVF   41,W
04B0:  MOVWF  52
04B1:  MOVLW  06
04B2:  MOVWF  53
04B3:  BCF    03.5
04B4:  CALL   216
04B5:  MOVF   78,W
04B6:  BSF    03.5
04B7:  MOVWF  42
....................       glcd_line(GRID_ORIGIN_X, 
....................                 y, 
....................                 GRID_ORIGIN_X + GRID_COLS*GRID_SIZE, 
....................                 y, 
....................                 1); 
04B8:  CLRF   43
04B9:  MOVF   42,W
04BA:  MOVWF  44
04BB:  MOVLW  3C
04BC:  MOVWF  45
04BD:  MOVF   42,W
04BE:  MOVWF  46
04BF:  MOVLW  01
04C0:  MOVWF  47
04C1:  BCF    03.5
04C2:  CALL   3A9
04C3:  BSF    03.5
04C4:  INCF   41,F
04C5:  GOTO   4AB
....................    } 
04C6:  BCF    03.5
04C7:  RETURN
.................... } 
....................  
.................... // Hcre iini doldur/boalt 
.................... void fillCell(uchar gx, uchar gy, int1 color) { 
*
0687:  BSF    03.5
0688:  MOVF   41,W
0689:  MOVWF  52
068A:  MOVLW  06
068B:  MOVWF  53
068C:  BCF    03.5
068D:  CALL   216
068E:  MOVLW  01
068F:  ADDWF  78,W
0690:  BSF    03.5
0691:  MOVWF  44
0692:  MOVF   42,W
0693:  MOVWF  52
0694:  MOVLW  06
0695:  MOVWF  53
0696:  BCF    03.5
0697:  CALL   216
0698:  MOVLW  01
0699:  ADDWF  78,W
069A:  BSF    03.5
069B:  MOVWF  45
....................    uchar px = GRID_ORIGIN_X + gx * GRID_SIZE + 1; 
....................    uchar py = GRID_ORIGIN_Y + gy * GRID_SIZE + 1; 
....................    for (uchar dx = 0; dx < GRID_SIZE-1; dx++) 
069C:  CLRF   46
069D:  MOVF   46,W
069E:  SUBLW  04
069F:  BTFSS  03.0
06A0:  GOTO   6B9
....................       for (uchar dy = 0; dy < GRID_SIZE-1; dy++) 
06A1:  CLRF   47
06A2:  MOVF   47,W
06A3:  SUBLW  04
06A4:  BTFSS  03.0
06A5:  GOTO   6B7
....................          glcd_pixel(px + dx, py + dy, color); 
06A6:  MOVF   46,W
06A7:  ADDWF  44,W
06A8:  MOVWF  48
06A9:  MOVF   47,W
06AA:  ADDWF  45,W
06AB:  MOVWF  49
06AC:  MOVF   48,W
06AD:  MOVWF  51
06AE:  MOVF   49,W
06AF:  MOVWF  52
06B0:  MOVF   43,W
06B1:  MOVWF  53
06B2:  BCF    03.5
06B3:  CALL   2FE
06B4:  BSF    03.5
06B5:  INCF   47,F
06B6:  GOTO   6A2
06B7:  INCF   46,F
06B8:  GOTO   69D
06B9:  BCF    03.5
06BA:  RETURN
.................... } 
....................  
.................... // Skor alann temizleyen fonksiyon 
.................... void clearScoreArea() { 
*
05B4:  MOVLW  41
05B5:  BSF    03.5
05B6:  MOVWF  3F
05B7:  CLRF   40
05B8:  MOVLW  3C
05B9:  MOVWF  41
05BA:  MOVLW  0A
05BB:  MOVWF  42
....................    uchar startX = 65; 
....................    uchar startY = 0; 
....................    uchar width = 60; 
....................    uchar height = 10; 
....................    uchar x, y; 
....................    for (x = startX; x < startX + width; x++) { 
05BC:  MOVF   3F,W
05BD:  MOVWF  43
05BE:  MOVF   41,W
05BF:  ADDWF  3F,W
05C0:  SUBWF  43,W
05C1:  BTFSC  03.0
05C2:  GOTO   5D6
....................       for (y = startY; y < startY + height; y++) { 
05C3:  MOVF   40,W
05C4:  MOVWF  44
05C5:  MOVF   42,W
05C6:  ADDWF  40,W
05C7:  SUBWF  44,W
05C8:  BTFSC  03.0
05C9:  GOTO   5D4
....................          glcd_pixel(x, y, 0); 
05CA:  MOVF   43,W
05CB:  MOVWF  51
05CC:  MOVF   44,W
05CD:  MOVWF  52
05CE:  CLRF   53
05CF:  BCF    03.5
05D0:  CALL   2FE
05D1:  BSF    03.5
05D2:  INCF   44,F
05D3:  GOTO   5C5
....................       } 
05D4:  INCF   43,F
05D5:  GOTO   5BE
....................    } 
.................... } 
....................  
.................... // --- HATALI prevX-prevY ve eski yem silme kodu TAMAMEN kaldrld --- 
.................... // Yemi yalnzca ylan olmayan bo bir gridde retir ve izer 
.................... void criar_comida() { 
*
06BB:  BSF    03.5
06BC:  CLRF   3F
....................    uchar valid = 0; 
....................    while (!valid) { 
06BD:  MOVF   3F,F
06BE:  BTFSS  03.2
06BF:  GOTO   703
....................       food[0] = rand() % GRID_COLS; 
06C0:  BCF    03.5
06C1:  CALL   609
06C2:  MOVF   79,W
06C3:  BSF    03.5
06C4:  MOVWF  42
06C5:  MOVF   78,W
06C6:  MOVWF  41
06C7:  MOVF   42,W
06C8:  MOVWF  45
06C9:  MOVF   41,W
06CA:  MOVWF  44
06CB:  CLRF   47
06CC:  MOVLW  0A
06CD:  MOVWF  46
06CE:  BCF    03.5
06CF:  CALL   5E2
06D0:  MOVF   77,W
06D1:  MOVWF  7C
....................       food[1] = rand() % GRID_ROWS; 
06D2:  CALL   609
06D3:  MOVF   79,W
06D4:  BSF    03.5
06D5:  MOVWF  42
06D6:  MOVF   78,W
06D7:  MOVWF  41
06D8:  MOVF   42,W
06D9:  MOVWF  45
06DA:  MOVF   41,W
06DB:  MOVWF  44
06DC:  CLRF   47
06DD:  MOVLW  0A
06DE:  MOVWF  46
06DF:  BCF    03.5
06E0:  CALL   5E2
06E1:  MOVF   77,W
06E2:  MOVWF  7D
....................       valid = 1; 
06E3:  MOVLW  01
06E4:  BSF    03.5
06E5:  MOVWF  3F
....................       for (uchar j = 0; j < LENGTH_SNAKE; j++) { 
06E6:  CLRF   40
06E7:  MOVF   7E,W
06E8:  SUBWF  40,W
06E9:  BTFSC  03.0
06EA:  GOTO   702
....................          if (SNAKE[j][0] == food[0] && SNAKE[j][1] == food[1]) { 
06EB:  BCF    03.0
06EC:  RLF    40,W
06ED:  ADDLW  27
06EE:  MOVWF  04
06EF:  BCF    03.7
06F0:  MOVF   7C,W
06F1:  SUBWF  00,W
06F2:  BTFSS  03.2
06F3:  GOTO   700
06F4:  BCF    03.0
06F5:  RLF    40,W
06F6:  ADDLW  01
06F7:  ADDLW  27
06F8:  MOVWF  04
06F9:  BCF    03.7
06FA:  MOVF   7D,W
06FB:  SUBWF  00,W
06FC:  BTFSS  03.2
06FD:  GOTO   700
....................             valid = 0; 
06FE:  CLRF   3F
....................             break; 
06FF:  GOTO   702
....................          } 
0700:  INCF   40,F
0701:  GOTO   6E7
....................       } 
0702:  GOTO   6BD
....................    } 
....................    fillCell(food[0], food[1], 1); 
0703:  MOVF   7C,W
0704:  MOVWF  41
0705:  MOVF   7D,W
0706:  MOVWF  42
0707:  MOVLW  01
0708:  MOVWF  43
0709:  BCF    03.5
070A:  CALL   687
070B:  RETURN
.................... } 
....................  
.................... void gameover() { 
....................    LENGTH_SNAKE = 10; 
070C:  MOVLW  0A
070D:  MOVWF  7E
....................    posX = 1; 
070E:  MOVLW  01
070F:  BSF    03.5
0710:  MOVWF  20
....................    posY = 2;  // Ylan biraz aada balyor 
0711:  MOVLW  02
0712:  MOVWF  21
....................    score = 0; 
0713:  CLRF   22
....................    score_txt[7] = score_txt[8] = '0'; 
0714:  MOVLW  30
0715:  MOVWF  2B
0716:  MOVWF  2A
....................    dir = 2; 
0717:  MOVLW  02
0718:  MOVWF  7B
....................    glcd_fillScreen(0); 
0719:  CLRF   40
071A:  BCF    03.5
071B:  CALL   23D
....................    drawGrid(); 
071C:  CALL   48D
....................    glcd_text57(25, 60, gayover, 1, 1); 
071D:  MOVLW  19
071E:  BSF    03.5
071F:  MOVWF  3F
0720:  MOVLW  3C
0721:  MOVWF  40
0722:  CLRF   42
0723:  MOVLW  AE
0724:  MOVWF  41
0725:  MOVLW  01
0726:  MOVWF  43
0727:  MOVWF  44
0728:  BCF    03.5
0729:  CALL   4DD
....................    delay_ms(1000); 
072A:  MOVLW  04
072B:  BSF    03.5
072C:  MOVWF  3F
072D:  MOVLW  FA
072E:  MOVWF  42
072F:  BCF    03.5
0730:  CALL   4C8
0731:  BSF    03.5
0732:  DECFSZ 3F,F
0733:  GOTO   72D
0734:  BCF    03.5
0735:  RETURN
.................... } 
....................  
.................... void writeScore() { 
....................    clearScoreArea(); 
....................    glcd_text57(65, 0, score_txt, 1, 1); 
*
05D6:  MOVLW  41
05D7:  MOVWF  3F
05D8:  CLRF   40
05D9:  CLRF   42
05DA:  MOVLW  A3
05DB:  MOVWF  41
05DC:  MOVLW  01
05DD:  MOVWF  43
05DE:  MOVWF  44
05DF:  BCF    03.5
05E0:  CALL   4DD
05E1:  RETURN
.................... } 
....................  
.................... void main() { 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  FF
0804:  MOVWF  26
0805:  MOVLW  02
0806:  MOVWF  7B
0807:  MOVLW  0A
0808:  MOVWF  7E
0809:  MOVLW  01
080A:  BSF    03.5
080B:  MOVWF  20
080C:  MOVLW  02
080D:  MOVWF  21
080E:  CLRF   22
080F:  BSF    1F.0
0810:  BSF    1F.1
0811:  BSF    1F.2
0812:  BCF    1F.3
0813:  MOVLW  07
0814:  MOVWF  1C
0815:  BCF    03.7
....................    glcd_init(ON); 
*
0845:  MOVLW  01
0846:  MOVWF  3F
0847:  BCF    0A.3
0848:  BCF    03.5
0849:  GOTO   298
084A:  BSF    0A.3
....................    glcd_fillScreen(0); 
084B:  BSF    03.5
084C:  CLRF   40
084D:  BCF    0A.3
084E:  BCF    03.5
084F:  CALL   23D
0850:  BSF    0A.3
....................    drawGrid(); 
0851:  BCF    0A.3
0852:  CALL   48D
0853:  BSF    0A.3
....................    delay_ms(500); 
0854:  MOVLW  02
0855:  BSF    03.5
0856:  MOVWF  3F
0857:  MOVLW  FA
0858:  MOVWF  42
0859:  BCF    0A.3
085A:  BCF    03.5
085B:  CALL   4C8
085C:  BSF    0A.3
085D:  BSF    03.5
085E:  DECFSZ 3F,F
085F:  GOTO   057
....................  
.................... Start: 
....................    glcd_fillScreen(0); 
0860:  CLRF   40
0861:  BCF    0A.3
0862:  BCF    03.5
0863:  CALL   23D
0864:  BSF    0A.3
....................    drawGrid(); 
0865:  BCF    0A.3
0866:  CALL   48D
0867:  BSF    0A.3
....................    writeScore(); 
0868:  BCF    0A.3
0869:  CALL   5B4
086A:  BSF    0A.3
....................    criar_comida(); 
086B:  BCF    0A.3
086C:  CALL   6BB
086D:  BSF    0A.3
....................  
....................    for (i = 0; i < LENGTH_SNAKE; i++) { 
086E:  BSF    03.5
086F:  CLRF   3C
0870:  MOVF   7E,W
0871:  SUBWF  3C,W
0872:  BTFSC  03.0
0873:  GOTO   0A4
....................       SNAKE[i][0] = posX - (LENGTH_SNAKE - 1 - i); 
0874:  BCF    03.0
0875:  RLF    3C,W
0876:  ADDLW  27
0877:  MOVWF  04
0878:  BCF    03.7
0879:  MOVLW  01
087A:  SUBWF  7E,W
087B:  MOVWF  78
087C:  MOVF   3C,W
087D:  SUBWF  78,W
087E:  SUBWF  20,W
087F:  MOVWF  00
....................       SNAKE[i][1] = posY; 
0880:  BCF    03.0
0881:  RLF    3C,W
0882:  ADDLW  01
0883:  ADDLW  27
0884:  MOVWF  04
0885:  BCF    03.7
0886:  MOVF   21,W
0887:  MOVWF  00
....................       fillCell(SNAKE[i][0], SNAKE[i][1], 1); 
0888:  BCF    03.0
0889:  RLF    3C,W
088A:  ADDLW  27
088B:  MOVWF  04
088C:  BCF    03.7
088D:  MOVF   00,W
088E:  MOVWF  3F
088F:  BCF    03.0
0890:  RLF    3C,W
0891:  ADDLW  01
0892:  ADDLW  27
0893:  MOVWF  04
0894:  BCF    03.7
0895:  MOVF   00,W
0896:  MOVWF  40
0897:  MOVF   3F,W
0898:  MOVWF  41
0899:  MOVF   40,W
089A:  MOVWF  42
089B:  MOVLW  01
089C:  MOVWF  43
089D:  BCF    0A.3
089E:  BCF    03.5
089F:  CALL   687
08A0:  BSF    0A.3
08A1:  BSF    03.5
08A2:  INCF   3C,F
08A3:  GOTO   070
....................    } 
....................  
....................    while (TRUE) { 
....................       if (input(PIN_C3) && dir != 0) dir = 3; 
08A4:  BCF    03.5
08A5:  BSF    26.3
08A6:  MOVF   26,W
08A7:  BSF    03.5
08A8:  MOVWF  07
08A9:  BCF    03.5
08AA:  BTFSS  07.3
08AB:  GOTO   0B1
08AC:  MOVF   7B,F
08AD:  BTFSC  03.2
08AE:  GOTO   0B1
08AF:  MOVLW  03
08B0:  MOVWF  7B
....................       if (input(PIN_C2) && dir != 1) dir = 2; 
08B1:  BSF    26.2
08B2:  MOVF   26,W
08B3:  BSF    03.5
08B4:  MOVWF  07
08B5:  BCF    03.5
08B6:  BTFSS  07.2
08B7:  GOTO   0BD
08B8:  DECFSZ 7B,W
08B9:  GOTO   0BB
08BA:  GOTO   0BD
08BB:  MOVLW  02
08BC:  MOVWF  7B
....................       if (input(PIN_C1) && dir != 2) dir = 1; 
08BD:  BSF    26.1
08BE:  MOVF   26,W
08BF:  BSF    03.5
08C0:  MOVWF  07
08C1:  BCF    03.5
08C2:  BTFSS  07.1
08C3:  GOTO   0CA
08C4:  MOVF   7B,W
08C5:  SUBLW  02
08C6:  BTFSC  03.2
08C7:  GOTO   0CA
08C8:  MOVLW  01
08C9:  MOVWF  7B
....................       if (input(PIN_C4) && dir != 3) dir = 0; 
08CA:  BSF    26.4
08CB:  MOVF   26,W
08CC:  BSF    03.5
08CD:  MOVWF  07
08CE:  BCF    03.5
08CF:  BTFSS  07.4
08D0:  GOTO   0D5
08D1:  MOVF   7B,W
08D2:  SUBLW  03
08D3:  BTFSS  03.2
08D4:  CLRF   7B
....................       if (input(PIN_C5)) { gameover(); goto Start; } 
08D5:  BSF    26.5
08D6:  MOVF   26,W
08D7:  BSF    03.5
08D8:  MOVWF  07
08D9:  BCF    03.5
08DA:  BTFSS  07.5
08DB:  GOTO   0E2
08DC:  BCF    0A.3
08DD:  CALL   70C
08DE:  BSF    0A.3
08DF:  BSF    03.5
08E0:  GOTO   060
08E1:  BCF    03.5
....................  
....................       switch(dir) { 
08E2:  MOVF   7B,W
08E3:  ADDLW  FC
08E4:  BTFSC  03.0
08E5:  GOTO   121
08E6:  ADDLW  04
08E7:  GOTO   20D
....................          case 0: if (posX == 0) { gameover(); goto Start; } else posX--; break; 
08E8:  BSF    03.5
08E9:  MOVF   20,F
08EA:  BTFSS  03.2
08EB:  GOTO   0F3
08EC:  BCF    0A.3
08ED:  BCF    03.5
08EE:  CALL   70C
08EF:  BSF    0A.3
08F0:  BSF    03.5
08F1:  GOTO   060
08F2:  GOTO   0F4
08F3:  DECF   20,F
08F4:  BCF    03.5
08F5:  GOTO   121
....................          case 1: if (posY == 0) { gameover(); goto Start; } else posY--; break; 
08F6:  BSF    03.5
08F7:  MOVF   21,F
08F8:  BTFSS  03.2
08F9:  GOTO   101
08FA:  BCF    0A.3
08FB:  BCF    03.5
08FC:  CALL   70C
08FD:  BSF    0A.3
08FE:  BSF    03.5
08FF:  GOTO   060
0900:  GOTO   102
0901:  DECF   21,F
0902:  BCF    03.5
0903:  GOTO   121
....................          case 2: if (posY == GRID_ROWS - 1) { gameover(); goto Start; } else posY++; break; 
0904:  BSF    03.5
0905:  MOVF   21,W
0906:  SUBLW  09
0907:  BTFSS  03.2
0908:  GOTO   110
0909:  BCF    0A.3
090A:  BCF    03.5
090B:  CALL   70C
090C:  BSF    0A.3
090D:  BSF    03.5
090E:  GOTO   060
090F:  GOTO   111
0910:  INCF   21,F
0911:  BCF    03.5
0912:  GOTO   121
....................          case 3: if (posX == GRID_COLS - 1) { gameover(); goto Start; } else posX++; break; 
0913:  BSF    03.5
0914:  MOVF   20,W
0915:  SUBLW  09
0916:  BTFSS  03.2
0917:  GOTO   11F
0918:  BCF    0A.3
0919:  BCF    03.5
091A:  CALL   70C
091B:  BSF    0A.3
091C:  BSF    03.5
091D:  GOTO   060
091E:  GOTO   120
091F:  INCF   20,F
0920:  BCF    03.5
....................       } 
....................  
....................       uchar tailX = SNAKE[0][0], tailY = SNAKE[0][1]; 
0921:  MOVF   27,W
0922:  BSF    03.5
0923:  MOVWF  3D
0924:  BCF    03.5
0925:  MOVF   28,W
0926:  BSF    03.5
0927:  MOVWF  3E
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
0928:  CLRF   3C
0929:  MOVLW  01
092A:  SUBWF  7E,W
092B:  SUBWF  3C,W
092C:  BTFSC  03.0
092D:  GOTO   164
....................          SNAKE[i][0] = SNAKE[i + 1][0]; 
092E:  BCF    03.0
092F:  RLF    3C,W
0930:  ADDLW  27
0931:  MOVWF  3F
0932:  CLRF   40
0933:  BTFSC  03.0
0934:  INCF   40,F
0935:  MOVLW  01
0936:  ADDWF  3C,W
0937:  MOVWF  77
0938:  BCF    03.0
0939:  RLF    77,F
093A:  MOVF   77,W
093B:  ADDLW  27
093C:  MOVWF  04
093D:  BCF    03.7
093E:  MOVF   00,W
093F:  MOVWF  41
0940:  MOVF   3F,W
0941:  MOVWF  04
0942:  BCF    03.7
0943:  BTFSC  40.0
0944:  BSF    03.7
0945:  MOVF   41,W
0946:  MOVWF  00
....................          SNAKE[i][1] = SNAKE[i + 1][1]; 
0947:  BCF    03.0
0948:  RLF    3C,W
0949:  ADDLW  01
094A:  ADDLW  27
094B:  MOVWF  3F
094C:  CLRF   40
094D:  BTFSC  03.0
094E:  INCF   40,F
094F:  MOVLW  01
0950:  ADDWF  3C,W
0951:  MOVWF  77
0952:  BCF    03.0
0953:  RLF    77,F
0954:  MOVF   77,W
0955:  ADDLW  01
0956:  ADDLW  27
0957:  MOVWF  04
0958:  BCF    03.7
0959:  MOVF   00,W
095A:  MOVWF  41
095B:  MOVF   3F,W
095C:  MOVWF  04
095D:  BCF    03.7
095E:  BTFSC  40.0
095F:  BSF    03.7
0960:  MOVF   41,W
0961:  MOVWF  00
0962:  INCF   3C,F
0963:  GOTO   129
....................       } 
....................       SNAKE[LENGTH_SNAKE - 1][0] = posX; 
0964:  MOVLW  01
0965:  SUBWF  7E,W
0966:  MOVWF  77
0967:  BCF    03.0
0968:  RLF    77,F
0969:  MOVF   77,W
096A:  ADDLW  27
096B:  MOVWF  04
096C:  BCF    03.7
096D:  MOVF   20,W
096E:  MOVWF  00
....................       SNAKE[LENGTH_SNAKE - 1][1] = posY; 
096F:  MOVLW  01
0970:  SUBWF  7E,W
0971:  MOVWF  77
0972:  BCF    03.0
0973:  RLF    77,F
0974:  MOVF   77,W
0975:  ADDLW  01
0976:  ADDLW  27
0977:  MOVWF  04
0978:  BCF    03.7
0979:  MOVF   21,W
097A:  MOVWF  00
....................  
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
097B:  CLRF   3C
097C:  MOVLW  01
097D:  SUBWF  7E,W
097E:  SUBWF  3C,W
097F:  BTFSC  03.0
0980:  GOTO   19C
....................          if (SNAKE[i][0] == posX && SNAKE[i][1] == posY) { 
0981:  BCF    03.0
0982:  RLF    3C,W
0983:  ADDLW  27
0984:  MOVWF  04
0985:  BCF    03.7
0986:  MOVF   20,W
0987:  SUBWF  00,W
0988:  BTFSS  03.2
0989:  GOTO   19A
098A:  BCF    03.0
098B:  RLF    3C,W
098C:  ADDLW  01
098D:  ADDLW  27
098E:  MOVWF  04
098F:  BCF    03.7
0990:  MOVF   21,W
0991:  SUBWF  00,W
0992:  BTFSS  03.2
0993:  GOTO   19A
....................             gameover(); goto Start; 
0994:  BCF    0A.3
0995:  BCF    03.5
0996:  CALL   70C
0997:  BSF    0A.3
0998:  BSF    03.5
0999:  GOTO   060
....................          } 
099A:  INCF   3C,F
099B:  GOTO   17C
....................       } 
....................  
....................       fillCell(posX, posY, 1); 
099C:  MOVF   20,W
099D:  MOVWF  41
099E:  MOVF   21,W
099F:  MOVWF  42
09A0:  MOVLW  01
09A1:  MOVWF  43
09A2:  BCF    0A.3
09A3:  BCF    03.5
09A4:  CALL   687
09A5:  BSF    0A.3
....................       fillCell(tailX, tailY, 0); 
09A6:  BSF    03.5
09A7:  MOVF   3D,W
09A8:  MOVWF  41
09A9:  MOVF   3E,W
09AA:  MOVWF  42
09AB:  CLRF   43
09AC:  BCF    0A.3
09AD:  BCF    03.5
09AE:  CALL   687
09AF:  BSF    0A.3
....................  
....................       if (posX == food[0] && posY == food[1]) { 
09B0:  MOVF   7C,W
09B1:  BSF    03.5
09B2:  SUBWF  20,W
09B3:  BTFSS  03.2
09B4:  GOTO   1E7
09B5:  MOVF   7D,W
09B6:  SUBWF  21,W
09B7:  BTFSS  03.2
09B8:  GOTO   1E7
....................          LENGTH_SNAKE++; 
09B9:  INCF   7E,F
....................          if (LENGTH_SNAKE >= GRID_COLS * GRID_ROWS - 2) { 
09BA:  MOVF   7E,W
09BB:  SUBLW  61
09BC:  BTFSC  03.0
09BD:  GOTO   1C4
....................             gameover(); goto Start; 
09BE:  BCF    0A.3
09BF:  BCF    03.5
09C0:  CALL   70C
09C1:  BSF    0A.3
09C2:  BSF    03.5
09C3:  GOTO   060
....................          } 
....................          criar_comida(); 
09C4:  BCF    0A.3
09C5:  BCF    03.5
09C6:  CALL   6BB
09C7:  BSF    0A.3
....................          score++; 
09C8:  BSF    03.5
09C9:  INCF   22,F
....................          score_txt[7] = '0' + (score / 10); 
09CA:  MOVF   22,W
09CB:  MOVWF  3F
09CC:  MOVLW  0A
09CD:  MOVWF  40
09CE:  BCF    0A.3
09CF:  BCF    03.5
09D0:  CALL   736
09D1:  BSF    0A.3
09D2:  MOVF   78,W
09D3:  ADDLW  30
09D4:  BSF    03.5
09D5:  MOVWF  2A
....................          score_txt[8] = '0' + (score % 10); 
09D6:  MOVF   22,W
09D7:  MOVWF  3F
09D8:  MOVLW  0A
09D9:  MOVWF  40
09DA:  BCF    0A.3
09DB:  BCF    03.5
09DC:  CALL   736
09DD:  BSF    0A.3
09DE:  MOVF   77,W
09DF:  ADDLW  30
09E0:  BSF    03.5
09E1:  MOVWF  2B
....................          writeScore(); 
09E2:  BCF    0A.3
09E3:  BCF    03.5
09E4:  CALL   5B4
09E5:  BSF    0A.3
09E6:  BSF    03.5
....................       } 
....................  
....................       delay_ms(5000 / LENGTH_SNAKE); 
09E7:  MOVLW  13
09E8:  MOVWF  45
09E9:  MOVLW  88
09EA:  MOVWF  44
09EB:  CLRF   47
09EC:  MOVF   7E,W
09ED:  MOVWF  46
09EE:  BCF    0A.3
09EF:  BCF    03.5
09F0:  CALL   5E2
09F1:  BSF    0A.3
09F2:  MOVF   79,W
09F3:  BSF    03.5
09F4:  MOVWF  40
09F5:  MOVF   78,W
09F6:  MOVWF  3F
09F7:  MOVF   40,W
09F8:  MOVWF  41
09F9:  INCF   41,F
09FA:  DECF   41,F
09FB:  BTFSC  03.2
09FC:  GOTO   205
09FD:  MOVLW  FF
09FE:  MOVWF  42
09FF:  BCF    0A.3
0A00:  BCF    03.5
0A01:  CALL   4C8
0A02:  BSF    0A.3
0A03:  BSF    03.5
0A04:  GOTO   1FA
0A05:  MOVF   3F,W
0A06:  MOVWF  42
0A07:  BCF    0A.3
0A08:  BCF    03.5
0A09:  CALL   4C8
0A0A:  BSF    0A.3
0A0B:  GOTO   0A5
....................    } 
.................... } 
0A0C:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
