CCS PCM C Compiler, Version 5.025, 5967               25-May-25 14:06

               Filename:   C:\Users\Eren\Documents\CCS C Projects\snake_project\main.lst

               ROM used:   2425 words (30%)
                           Largest free fragment is 2048
               RAM used:   140 (38%) at main() level
                           165 (45%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDLW  0B
0008:  BTFSC  03.0
0009:  INCF   0A,F
000A:  MOVWF  02
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  5F
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  03
0017:  RETLW  00
0018:  RETLW  03
0019:  RETLW  00
001A:  RETLW  14
001B:  RETLW  3E
001C:  RETLW  14
001D:  RETLW  3E
001E:  RETLW  14
001F:  RETLW  24
0020:  RETLW  2A
0021:  RETLW  7F
0022:  RETLW  2A
0023:  RETLW  12
0024:  RETLW  43
0025:  RETLW  33
0026:  RETLW  08
0027:  RETLW  66
0028:  RETLW  61
0029:  RETLW  36
002A:  RETLW  49
002B:  RETLW  55
002C:  RETLW  22
002D:  RETLW  50
002E:  RETLW  00
002F:  RETLW  05
0030:  RETLW  03
0031:  RETLW  00
0032:  RETLW  00
0033:  RETLW  00
0034:  RETLW  1C
0035:  RETLW  22
0036:  RETLW  41
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  41
003A:  RETLW  22
003B:  RETLW  1C
003C:  RETLW  00
003D:  RETLW  14
003E:  RETLW  08
003F:  RETLW  3E
0040:  RETLW  08
0041:  RETLW  14
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  3E
0045:  RETLW  08
0046:  RETLW  08
0047:  RETLW  00
0048:  RETLW  50
0049:  RETLW  30
004A:  RETLW  00
004B:  RETLW  00
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  08
004F:  RETLW  08
0050:  RETLW  08
0051:  RETLW  00
0052:  RETLW  60
0053:  RETLW  60
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  20
0057:  RETLW  10
0058:  RETLW  08
0059:  RETLW  04
005A:  RETLW  02
005B:  RETLW  3E
005C:  RETLW  51
005D:  RETLW  49
005E:  RETLW  45
005F:  RETLW  3E
0060:  RETLW  04
0061:  RETLW  02
0062:  RETLW  7F
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  61
0067:  RETLW  51
0068:  RETLW  49
0069:  RETLW  46
006A:  RETLW  22
006B:  RETLW  41
006C:  RETLW  49
006D:  RETLW  49
006E:  RETLW  36
006F:  RETLW  18
0070:  RETLW  14
0071:  RETLW  12
0072:  RETLW  7F
0073:  RETLW  10
0074:  RETLW  27
0075:  RETLW  45
0076:  RETLW  45
0077:  RETLW  45
0078:  RETLW  39
0079:  RETLW  3E
007A:  RETLW  49
007B:  RETLW  49
007C:  RETLW  49
007D:  RETLW  32
007E:  RETLW  01
007F:  RETLW  01
0080:  RETLW  71
0081:  RETLW  09
0082:  RETLW  07
0083:  RETLW  36
0084:  RETLW  49
0085:  RETLW  49
0086:  RETLW  49
0087:  RETLW  36
0088:  RETLW  26
0089:  RETLW  49
008A:  RETLW  49
008B:  RETLW  49
008C:  RETLW  3E
008D:  RETLW  00
008E:  RETLW  36
008F:  RETLW  36
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  56
0094:  RETLW  36
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  08
0098:  RETLW  14
0099:  RETLW  22
009A:  RETLW  41
009B:  RETLW  00
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  14
009F:  RETLW  14
00A0:  RETLW  14
00A1:  RETLW  00
00A2:  RETLW  41
00A3:  RETLW  22
00A4:  RETLW  14
00A5:  RETLW  08
00A6:  RETLW  02
00A7:  RETLW  01
00A8:  RETLW  51
00A9:  RETLW  09
00AA:  RETLW  06
00AB:  RETLW  3E
00AC:  RETLW  41
00AD:  RETLW  59
00AE:  RETLW  55
00AF:  RETLW  5E
00B0:  RETLW  7E
00B1:  RETLW  09
00B2:  RETLW  09
00B3:  RETLW  09
00B4:  RETLW  7E
00B5:  RETLW  7F
00B6:  RETLW  49
00B7:  RETLW  49
00B8:  RETLW  49
00B9:  RETLW  36
00BA:  RETLW  3E
00BB:  RETLW  41
00BC:  RETLW  41
00BD:  RETLW  41
00BE:  RETLW  22
00BF:  RETLW  7F
00C0:  RETLW  41
00C1:  RETLW  41
00C2:  RETLW  41
00C3:  RETLW  3E
00C4:  RETLW  7F
00C5:  RETLW  49
00C6:  RETLW  49
00C7:  RETLW  49
00C8:  RETLW  41
00C9:  RETLW  7F
00CA:  RETLW  09
00CB:  RETLW  09
00CC:  RETLW  09
00CD:  RETLW  01
00CE:  RETLW  3E
00CF:  RETLW  41
00D0:  RETLW  41
00D1:  RETLW  49
00D2:  RETLW  3A
00D3:  RETLW  7F
00D4:  RETLW  08
00D5:  RETLW  08
00D6:  RETLW  08
00D7:  RETLW  7F
00D8:  RETLW  00
00D9:  RETLW  41
00DA:  RETLW  7F
00DB:  RETLW  41
00DC:  RETLW  00
00DD:  RETLW  30
00DE:  RETLW  40
00DF:  RETLW  40
00E0:  RETLW  40
00E1:  RETLW  3F
00E2:  RETLW  7F
00E3:  RETLW  08
00E4:  RETLW  14
00E5:  RETLW  22
00E6:  RETLW  41
00E7:  RETLW  7F
00E8:  RETLW  40
00E9:  RETLW  40
00EA:  RETLW  40
00EB:  RETLW  40
00EC:  RETLW  7F
00ED:  RETLW  02
00EE:  RETLW  0C
00EF:  RETLW  02
00F0:  RETLW  7F
00F1:  RETLW  7F
00F2:  RETLW  02
00F3:  RETLW  04
00F4:  RETLW  08
00F5:  RETLW  7F
00F6:  RETLW  3E
00F7:  RETLW  41
00F8:  RETLW  41
00F9:  RETLW  41
00FA:  RETLW  3E
00FB:  RETLW  7F
00FC:  RETLW  09
00FD:  RETLW  09
00FE:  RETLW  09
00FF:  RETLW  06
0100:  RETLW  1E
0101:  RETLW  21
0102:  RETLW  21
0103:  RETLW  21
0104:  RETLW  5E
0105:  RETLW  7F
0106:  RETLW  09
0107:  RETLW  09
0108:  RETLW  09
0109:  RETLW  76
010A:  BSF    0A.0
010B:  BCF    0A.1
010C:  BCF    0A.2
010D:  ADDWF  02,F
010E:  RETLW  26
010F:  RETLW  49
0110:  RETLW  49
0111:  RETLW  49
0112:  RETLW  32
0113:  RETLW  01
0114:  RETLW  01
0115:  RETLW  7F
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  3F
0119:  RETLW  40
011A:  RETLW  40
011B:  RETLW  40
011C:  RETLW  3F
011D:  RETLW  1F
011E:  RETLW  20
011F:  RETLW  40
0120:  RETLW  20
0121:  RETLW  1F
0122:  RETLW  7F
0123:  RETLW  20
0124:  RETLW  10
0125:  RETLW  20
0126:  RETLW  7F
0127:  RETLW  41
0128:  RETLW  22
0129:  RETLW  1C
012A:  RETLW  22
012B:  RETLW  41
012C:  RETLW  07
012D:  RETLW  08
012E:  RETLW  70
012F:  RETLW  08
0130:  RETLW  07
0131:  RETLW  61
0132:  RETLW  51
0133:  RETLW  49
0134:  RETLW  45
0135:  RETLW  43
0136:  RETLW  00
0137:  RETLW  7F
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  02
013C:  RETLW  04
013D:  RETLW  08
013E:  RETLW  10
013F:  RETLW  20
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  41
0143:  RETLW  7F
0144:  RETLW  00
0145:  RETLW  04
0146:  RETLW  02
0147:  RETLW  01
0148:  RETLW  02
0149:  RETLW  04
014A:  RETLW  40
014B:  RETLW  40
014C:  RETLW  40
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  00
0150:  RETLW  01
0151:  RETLW  02
0152:  RETLW  04
0153:  RETLW  00
0154:  RETLW  20
0155:  RETLW  54
0156:  RETLW  54
0157:  RETLW  54
0158:  RETLW  78
0159:  RETLW  7F
015A:  RETLW  44
015B:  RETLW  44
015C:  RETLW  44
015D:  RETLW  38
015E:  RETLW  38
015F:  RETLW  44
0160:  RETLW  44
0161:  RETLW  44
0162:  RETLW  44
0163:  RETLW  38
0164:  RETLW  44
0165:  RETLW  44
0166:  RETLW  44
0167:  RETLW  7F
0168:  RETLW  38
0169:  RETLW  54
016A:  RETLW  54
016B:  RETLW  54
016C:  RETLW  18
016D:  RETLW  04
016E:  RETLW  04
016F:  RETLW  7E
0170:  RETLW  05
0171:  RETLW  05
0172:  RETLW  08
0173:  RETLW  54
0174:  RETLW  54
0175:  RETLW  54
0176:  RETLW  3C
0177:  RETLW  7F
0178:  RETLW  08
0179:  RETLW  04
017A:  RETLW  04
017B:  RETLW  78
017C:  RETLW  00
017D:  RETLW  44
017E:  RETLW  7D
017F:  RETLW  40
0180:  RETLW  00
0181:  RETLW  20
0182:  RETLW  40
0183:  RETLW  44
0184:  RETLW  3D
0185:  RETLW  00
0186:  RETLW  7F
0187:  RETLW  10
0188:  RETLW  28
0189:  RETLW  44
018A:  RETLW  00
018B:  RETLW  00
018C:  RETLW  41
018D:  RETLW  7F
018E:  RETLW  40
018F:  RETLW  00
0190:  RETLW  7C
0191:  RETLW  04
0192:  RETLW  78
0193:  RETLW  04
0194:  RETLW  78
0195:  RETLW  7C
0196:  RETLW  08
0197:  RETLW  04
0198:  RETLW  04
0199:  RETLW  78
019A:  RETLW  38
019B:  RETLW  44
019C:  RETLW  44
019D:  RETLW  44
019E:  RETLW  38
019F:  RETLW  7C
01A0:  RETLW  14
01A1:  RETLW  14
01A2:  RETLW  14
01A3:  RETLW  08
01A4:  RETLW  08
01A5:  RETLW  14
01A6:  RETLW  14
01A7:  RETLW  14
01A8:  RETLW  7C
01A9:  RETLW  00
01AA:  RETLW  7C
01AB:  RETLW  08
01AC:  RETLW  04
01AD:  RETLW  04
01AE:  RETLW  48
01AF:  RETLW  54
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  20
01B3:  RETLW  04
01B4:  RETLW  04
01B5:  RETLW  3F
01B6:  RETLW  44
01B7:  RETLW  44
01B8:  RETLW  3C
01B9:  RETLW  40
01BA:  RETLW  40
01BB:  RETLW  20
01BC:  RETLW  7C
01BD:  RETLW  1C
01BE:  RETLW  20
01BF:  RETLW  40
01C0:  RETLW  20
01C1:  RETLW  1C
01C2:  RETLW  3C
01C3:  RETLW  40
01C4:  RETLW  30
01C5:  RETLW  40
01C6:  RETLW  3C
01C7:  RETLW  44
01C8:  RETLW  28
01C9:  RETLW  10
01CA:  RETLW  28
01CB:  RETLW  44
01CC:  RETLW  0C
01CD:  RETLW  50
01CE:  RETLW  50
01CF:  RETLW  50
01D0:  RETLW  3C
01D1:  RETLW  44
01D2:  RETLW  64
01D3:  RETLW  54
01D4:  RETLW  4C
01D5:  RETLW  44
01D6:  RETLW  00
01D7:  RETLW  08
01D8:  RETLW  36
01D9:  RETLW  41
01DA:  RETLW  41
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  7F
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  41
01E1:  RETLW  41
01E2:  RETLW  36
01E3:  RETLW  08
01E4:  RETLW  00
01E5:  RETLW  02
01E6:  RETLW  01
01E7:  RETLW  02
01E8:  RETLW  04
01E9:  RETLW  02
*
0216:  CLRF   77
0217:  CLRF   78
0218:  BSF    03.5
0219:  MOVF   5E,W
021A:  BCF    03.0
021B:  BTFSC  5F.0
021C:  ADDWF  77,F
021D:  RRF    77,F
021E:  RRF    78,F
021F:  BTFSC  5F.1
0220:  ADDWF  77,F
0221:  RRF    77,F
0222:  RRF    78,F
0223:  BTFSC  5F.2
0224:  ADDWF  77,F
0225:  RRF    77,F
0226:  RRF    78,F
0227:  BTFSC  5F.3
0228:  ADDWF  77,F
0229:  RRF    77,F
022A:  RRF    78,F
022B:  BTFSC  5F.4
022C:  ADDWF  77,F
022D:  RRF    77,F
022E:  RRF    78,F
022F:  BTFSC  5F.5
0230:  ADDWF  77,F
0231:  RRF    77,F
0232:  RRF    78,F
0233:  BTFSC  5F.6
0234:  ADDWF  77,F
0235:  RRF    77,F
0236:  RRF    78,F
0237:  BTFSC  5F.7
0238:  ADDWF  77,F
0239:  RRF    77,F
023A:  RRF    78,F
023B:  BCF    03.5
023C:  RETURN
*
05E5:  CLRF   78
05E6:  CLRF   79
05E7:  CLRF   77
05E8:  CLRF   7A
05E9:  BSF    03.5
05EA:  MOVF   53,W
05EB:  BTFSS  03.2
05EC:  GOTO   5F0
05ED:  MOVF   52,W
05EE:  BTFSC  03.2
05EF:  GOTO   60A
05F0:  MOVLW  10
05F1:  MOVWF  54
05F2:  BCF    03.0
05F3:  RLF    50,F
05F4:  RLF    51,F
05F5:  RLF    77,F
05F6:  RLF    7A,F
05F7:  MOVF   53,W
05F8:  SUBWF  7A,W
05F9:  BTFSS  03.2
05FA:  GOTO   5FD
05FB:  MOVF   52,W
05FC:  SUBWF  77,W
05FD:  BTFSS  03.0
05FE:  GOTO   606
05FF:  MOVF   52,W
0600:  SUBWF  77,F
0601:  BTFSS  03.0
0602:  DECF   7A,F
0603:  MOVF   53,W
0604:  SUBWF  7A,F
0605:  BSF    03.0
0606:  RLF    78,F
0607:  RLF    79,F
0608:  DECFSZ 54,F
0609:  GOTO   5F2
060A:  BCF    03.5
060B:  RETURN
*
0623:  MOVLW  20
0624:  MOVWF  59
0625:  CLRF   55
0626:  CLRF   56
0627:  CLRF   57
0628:  CLRF   58
0629:  MOVF   50,W
062A:  MOVWF  7A
062B:  MOVF   4F,W
062C:  MOVWF  79
062D:  MOVF   4E,W
062E:  MOVWF  78
062F:  MOVF   4D,W
0630:  MOVWF  77
0631:  BCF    03.0
0632:  BTFSS  77.0
0633:  GOTO   642
0634:  MOVF   51,W
0635:  ADDWF  55,F
0636:  MOVF   52,W
0637:  BTFSC  03.0
0638:  INCFSZ 52,W
0639:  ADDWF  56,F
063A:  MOVF   53,W
063B:  BTFSC  03.0
063C:  INCFSZ 53,W
063D:  ADDWF  57,F
063E:  MOVF   54,W
063F:  BTFSC  03.0
0640:  INCFSZ 54,W
0641:  ADDWF  58,F
0642:  RRF    58,F
0643:  RRF    57,F
0644:  RRF    56,F
0645:  RRF    55,F
0646:  RRF    7A,F
0647:  RRF    79,F
0648:  RRF    78,F
0649:  RRF    77,F
064A:  DECFSZ 59,F
064B:  GOTO   631
*
073A:  BSF    03.5
073B:  MOVF   4C,W
073C:  CLRF   78
073D:  SUBWF  4B,W
073E:  BTFSC  03.0
073F:  GOTO   743
0740:  MOVF   4B,W
0741:  MOVWF  77
0742:  GOTO   74F
0743:  CLRF   77
0744:  MOVLW  08
0745:  MOVWF  4D
0746:  RLF    4B,F
0747:  RLF    77,F
0748:  MOVF   4C,W
0749:  SUBWF  77,W
074A:  BTFSC  03.0
074B:  MOVWF  77
074C:  RLF    78,F
074D:  DECFSZ 4D,F
074E:  GOTO   746
074F:  BCF    03.5
0750:  RETURN
*
0A20:  BCF    0A.0
0A21:  BSF    0A.1
0A22:  BCF    0A.2
0A23:  ADDWF  02,F
0A24:  GOTO   0FA
0A25:  GOTO   108
0A26:  GOTO   116
0A27:  GOTO   125
....................  
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=16000000) 
*
04C8:  MOVLW  CC
04C9:  MOVWF  04
04CA:  BCF    03.7
04CB:  MOVF   00,W
04CC:  BTFSC  03.2
04CD:  GOTO   4DC
04CE:  MOVLW  05
04CF:  MOVWF  78
04D0:  CLRF   77
04D1:  DECFSZ 77,F
04D2:  GOTO   4D1
04D3:  DECFSZ 78,F
04D4:  GOTO   4D0
04D5:  MOVLW  2E
04D6:  MOVWF  77
04D7:  DECFSZ 77,F
04D8:  GOTO   4D7
04D9:  GOTO   4DA
04DA:  DECFSZ 00,F
04DB:  GOTO   4CE
04DC:  RETURN
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0818:  BCF    03.5
0819:  CLRF   20
081A:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
060C:  MOVF   25,W
060D:  BSF    03.5
060E:  MOVWF  50
060F:  BCF    03.5
0610:  MOVF   24,W
0611:  BSF    03.5
0612:  MOVWF  4F
0613:  BCF    03.5
0614:  MOVF   23,W
0615:  BSF    03.5
0616:  MOVWF  4E
0617:  BCF    03.5
0618:  MOVF   22,W
0619:  BSF    03.5
061A:  MOVWF  4D
061B:  MOVLW  41
061C:  MOVWF  54
061D:  MOVLW  C6
061E:  MOVWF  53
061F:  MOVLW  4E
0620:  MOVWF  52
0621:  MOVLW  6D
0622:  MOVWF  51
*
064C:  MOVF   7A,W
064D:  MOVWF  50
064E:  MOVF   79,W
064F:  MOVWF  4F
0650:  MOVF   78,W
0651:  MOVWF  4E
0652:  MOVF   77,W
0653:  MOVWF  4D
0654:  MOVLW  39
0655:  ADDWF  4D,W
0656:  BCF    03.5
0657:  MOVWF  22
0658:  BSF    03.5
0659:  MOVF   4E,W
065A:  BCF    03.5
065B:  MOVWF  23
065C:  MOVLW  30
065D:  BTFSC  03.0
065E:  MOVLW  31
065F:  ADDWF  23,F
0660:  BSF    03.5
0661:  MOVF   4F,W
0662:  BCF    03.5
0663:  MOVWF  24
0664:  MOVLW  00
0665:  BTFSC  03.0
0666:  MOVLW  01
0667:  ADDWF  24,F
0668:  BSF    03.5
0669:  MOVF   50,W
066A:  BCF    03.5
066B:  MOVWF  25
066C:  MOVLW  00
066D:  BTFSC  03.0
066E:  MOVLW  01
066F:  ADDWF  25,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0670:  MOVF   24,W
0671:  MOVWF  77
0672:  MOVF   25,W
0673:  MOVWF  78
0674:  CLRF   79
0675:  CLRF   7A
0676:  MOVF   25,W
0677:  BSF    03.5
0678:  MOVWF  4F
0679:  MOVF   77,W
067A:  MOVWF  4E
067B:  MOVF   4F,W
067C:  MOVWF  51
067D:  MOVF   4E,W
067E:  MOVWF  50
067F:  MOVLW  7F
0680:  MOVWF  53
0681:  MOVLW  FF
0682:  MOVWF  52
0683:  BCF    03.5
0684:  CALL   5E5
0685:  MOVF   77,W
0686:  MOVWF  78
0687:  MOVF   7A,W
0688:  MOVWF  79
0689:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <glcd.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
0298:  BCF    26.0
0299:  MOVF   26,W
029A:  BSF    03.5
029B:  MOVWF  07
029C:  BCF    03.5
029D:  BSF    07.0
....................    output_low(GLCD_E); 
029E:  BSF    03.5
029F:  BCF    06.5
02A0:  BCF    03.5
02A1:  BCF    06.5
....................    output_low(GLCD_CS1); 
02A2:  BSF    03.5
02A3:  BCF    06.0
02A4:  BCF    03.5
02A5:  BCF    06.0
....................    output_low(GLCD_CS2); 
02A6:  BSF    03.5
02A7:  BCF    06.1
02A8:  BCF    03.5
02A9:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
02AA:  BSF    03.5
02AB:  BCF    06.2
02AC:  BCF    03.5
02AD:  BCF    06.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
02AE:  MOVLW  30
02AF:  BSF    03.5
02B0:  MOVWF  63
02B1:  MOVLW  C0
02B2:  MOVWF  64
02B3:  BCF    03.5
02B4:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
02B5:  MOVLW  31
02B6:  BSF    03.5
02B7:  MOVWF  63
02B8:  MOVLW  C0
02B9:  MOVWF  64
02BA:  BCF    03.5
02BB:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
02BC:  MOVLW  30
02BD:  BSF    03.5
02BE:  MOVWF  63
02BF:  MOVLW  40
02C0:  MOVWF  64
02C1:  BCF    03.5
02C2:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0x40); 
02C3:  MOVLW  31
02C4:  BSF    03.5
02C5:  MOVWF  63
02C6:  MOVLW  40
02C7:  MOVWF  64
02C8:  BCF    03.5
02C9:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
02CA:  MOVLW  30
02CB:  BSF    03.5
02CC:  MOVWF  63
02CD:  MOVLW  B8
02CE:  MOVWF  64
02CF:  BCF    03.5
02D0:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
02D1:  MOVLW  31
02D2:  BSF    03.5
02D3:  MOVWF  63
02D4:  MOVLW  B8
02D5:  MOVWF  64
02D6:  BCF    03.5
02D7:  CALL   1EA
....................    if(mode == ON) 
02D8:  BSF    03.5
02D9:  DECFSZ 4B,W
02DA:  GOTO   2EA
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
02DB:  MOVLW  30
02DC:  MOVWF  63
02DD:  MOVLW  3F
02DE:  MOVWF  64
02DF:  BCF    03.5
02E0:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
02E1:  MOVLW  31
02E2:  BSF    03.5
02E3:  MOVWF  63
02E4:  MOVLW  3F
02E5:  MOVWF  64
02E6:  BCF    03.5
02E7:  CALL   1EA
....................    } 
02E8:  GOTO   2F7
02E9:  BSF    03.5
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
02EA:  MOVLW  30
02EB:  MOVWF  63
02EC:  MOVLW  3E
02ED:  MOVWF  64
02EE:  BCF    03.5
02EF:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
02F0:  MOVLW  31
02F1:  BSF    03.5
02F2:  MOVWF  63
02F3:  MOVLW  3E
02F4:  MOVWF  64
02F5:  BCF    03.5
02F6:  CALL   1EA
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
02F7:  BSF    03.5
02F8:  CLRF   4C
02F9:  BCF    03.5
02FA:  CALL   23D
02FB:  BSF    0A.3
02FC:  BCF    0A.4
02FD:  GOTO   05C (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
02FE:  MOVLW  30
02FF:  BSF    03.5
0300:  MOVWF  61
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
0301:  MOVF   5D,W
0302:  SUBLW  3F
0303:  BTFSC  03.0
0304:  GOTO   309
....................    { 
....................       x -= 64; 
0305:  MOVLW  40
0306:  SUBWF  5D,F
....................       chip = GLCD_CS2; 
0307:  MOVLW  31
0308:  MOVWF  61
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
0309:  BCF    06.2
030A:  BCF    03.5
030B:  BCF    06.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
030C:  BSF    03.5
030D:  BCF    5D.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
030E:  BSF    5D.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
030F:  MOVF   61,W
0310:  MOVWF  63
0311:  MOVF   5D,W
0312:  MOVWF  64
0313:  BCF    03.5
0314:  CALL   1EA
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
0315:  BSF    03.5
0316:  RRF    5E,W
0317:  MOVWF  77
0318:  RRF    77,F
0319:  RRF    77,F
031A:  MOVLW  1F
031B:  ANDWF  77,F
031C:  MOVF   77,W
031D:  ANDLW  BF
031E:  IORLW  B8
031F:  MOVWF  62
0320:  MOVF   61,W
0321:  MOVWF  63
0322:  MOVF   62,W
0323:  MOVWF  64
0324:  BCF    03.5
0325:  CALL   1EA
....................    output_high(GLCD_DI);                                    // Set for data 
0326:  BSF    03.5
0327:  BCF    06.2
0328:  BCF    03.5
0329:  BSF    06.2
....................    data = glcd_readByte(chip); 
032A:  BSF    03.5
032B:  MOVF   61,W
032C:  MOVWF  62
*
036F:  MOVF   78,W
0370:  MOVWF  60
....................  
....................    if(color == ON) 
0371:  DECFSZ 5F,W
0372:  GOTO   383
....................       bit_set(data, y%8);        // Turn the pixel on 
0373:  MOVF   5E,W
0374:  ANDLW  07
0375:  MOVWF  62
0376:  MOVLW  01
0377:  MOVWF  77
0378:  MOVF   62,W
0379:  MOVWF  78
037A:  BTFSC  03.2
037B:  GOTO   380
037C:  BCF    03.0
037D:  RLF    77,F
037E:  DECFSZ 78,F
037F:  GOTO   37C
0380:  MOVF   77,W
0381:  IORWF  60,F
0382:  GOTO   393
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
0383:  MOVF   5E,W
0384:  ANDLW  07
0385:  MOVWF  62
0386:  MOVLW  01
0387:  MOVWF  77
0388:  MOVF   62,W
0389:  MOVWF  78
038A:  BTFSC  03.2
038B:  GOTO   390
038C:  BCF    03.0
038D:  RLF    77,F
038E:  DECFSZ 78,F
038F:  GOTO   38C
0390:  MOVF   77,W
0391:  XORLW  FF
0392:  ANDWF  60,F
....................    output_low(GLCD_DI);          // Set for instruction 
0393:  BCF    06.2
0394:  BCF    03.5
0395:  BCF    06.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
0396:  BSF    03.5
0397:  MOVF   61,W
0398:  MOVWF  63
0399:  MOVF   5D,W
039A:  MOVWF  64
039B:  BCF    03.5
039C:  CALL   1EA
....................    output_high(GLCD_DI);         // Set for data 
039D:  BSF    03.5
039E:  BCF    06.2
039F:  BCF    03.5
03A0:  BSF    06.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
03A1:  BSF    03.5
03A2:  MOVF   61,W
03A3:  MOVWF  63
03A4:  MOVF   60,W
03A5:  MOVWF  64
03A6:  BCF    03.5
03A7:  CALL   1EA
03A8:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
03A9:  BSF    03.5
03AA:  MOVF   4F,W
03AB:  SUBWF  51,W
03AC:  MOVWF  5D
03AD:  MOVF   5D,W
03AE:  BTFSS  5D.7
03AF:  GOTO   3B2
03B0:  MOVF   5D,W
03B1:  SUBLW  00
03B2:  MOVWF  58
....................    dy = abs((signed int)(y2 - y1)); 
03B3:  MOVF   50,W
03B4:  SUBWF  52,W
03B5:  MOVWF  5D
03B6:  MOVF   5D,W
03B7:  BTFSS  5D.7
03B8:  GOTO   3BB
03B9:  MOVF   5D,W
03BA:  SUBLW  00
03BB:  MOVWF  59
....................    x = x1; 
03BC:  MOVF   4F,W
03BD:  MOVWF  54
....................    y = y1; 
03BE:  MOVF   50,W
03BF:  MOVWF  55
....................  
....................    if(x1 > x2) 
03C0:  MOVF   4F,W
03C1:  SUBWF  51,W
03C2:  BTFSC  03.0
03C3:  GOTO   3C7
....................       addx = -1; 
03C4:  MOVLW  FF
03C5:  MOVWF  56
03C6:  GOTO   3C9
....................    else 
....................       addx = 1; 
03C7:  MOVLW  01
03C8:  MOVWF  56
....................    if(y1 > y2) 
03C9:  MOVF   50,W
03CA:  SUBWF  52,W
03CB:  BTFSC  03.0
03CC:  GOTO   3D0
....................       addy = -1; 
03CD:  MOVLW  FF
03CE:  MOVWF  57
03CF:  GOTO   3D2
....................    else 
....................       addy = 1; 
03D0:  MOVLW  01
03D1:  MOVWF  57
....................  
....................    if(dx >= dy) 
03D2:  MOVF   59,W
03D3:  XORLW  80
03D4:  MOVWF  77
03D5:  MOVF   58,W
03D6:  XORLW  80
03D7:  SUBWF  77,W
03D8:  BTFSC  03.2
03D9:  GOTO   3DC
03DA:  BTFSC  03.0
03DB:  GOTO   434
....................    { 
....................       P = 2*dy - dx; 
03DC:  MOVLW  02
03DD:  MOVWF  5E
03DE:  MOVF   59,W
03DF:  MOVWF  5F
03E0:  BCF    03.5
03E1:  CALL   216
03E2:  BSF    03.5
03E3:  MOVF   58,W
03E4:  SUBWF  78,W
03E5:  CLRF   7A
03E6:  MOVWF  77
03E7:  BTFSC  77.7
03E8:  DECF   7A,F
03E9:  MOVWF  5A
03EA:  MOVF   7A,W
03EB:  MOVWF  5B
....................  
....................       for(i=0; i<=dx; ++i) 
03EC:  CLRF   5C
03ED:  BTFSC  58.7
03EE:  GOTO   433
03EF:  MOVF   5C,W
03F0:  SUBWF  58,W
03F1:  BTFSS  03.0
03F2:  GOTO   433
....................       { 
....................          glcd_pixel(x, y, color); 
03F3:  MOVF   54,W
03F4:  MOVWF  5D
03F5:  MOVF   55,W
03F6:  MOVWF  5E
03F7:  MOVF   53,W
03F8:  MOVWF  5F
03F9:  BCF    03.5
03FA:  CALL   2FE
....................  
....................          if(P < 0) 
03FB:  BSF    03.5
03FC:  BTFSS  5B.7
03FD:  GOTO   412
....................          { 
....................             P += 2*dy; 
03FE:  MOVLW  02
03FF:  MOVWF  5E
0400:  MOVF   59,W
0401:  MOVWF  5F
0402:  BCF    03.5
0403:  CALL   216
0404:  MOVF   78,W
0405:  CLRF   7A
0406:  MOVWF  77
0407:  BTFSC  77.7
0408:  DECF   7A,F
0409:  BSF    03.5
040A:  ADDWF  5A,F
040B:  MOVF   7A,W
040C:  BTFSC  03.0
040D:  INCFSZ 7A,W
040E:  ADDWF  5B,F
....................             x += addx; 
040F:  MOVF   56,W
0410:  ADDWF  54,F
....................          } 
0411:  GOTO   431
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
0412:  MOVLW  02
0413:  MOVWF  5E
0414:  MOVF   59,W
0415:  MOVWF  5F
0416:  BCF    03.5
0417:  CALL   216
0418:  MOVF   78,W
0419:  BSF    03.5
041A:  MOVWF  5D
041B:  MOVLW  02
041C:  MOVWF  5E
041D:  MOVF   58,W
041E:  MOVWF  5F
041F:  BCF    03.5
0420:  CALL   216
0421:  MOVF   78,W
0422:  BSF    03.5
0423:  SUBWF  5D,W
0424:  CLRF   7A
0425:  MOVWF  77
0426:  BTFSC  77.7
0427:  DECF   7A,F
0428:  ADDWF  5A,F
0429:  MOVF   7A,W
042A:  BTFSC  03.0
042B:  INCFSZ 7A,W
042C:  ADDWF  5B,F
....................             x += addx; 
042D:  MOVF   56,W
042E:  ADDWF  54,F
....................             y += addy; 
042F:  MOVF   57,W
0430:  ADDWF  55,F
....................          } 
0431:  INCF   5C,F
0432:  GOTO   3ED
....................       } 
....................    } 
0433:  GOTO   48B
....................    else 
....................    { 
....................       P = 2*dx - dy; 
0434:  MOVLW  02
0435:  MOVWF  5E
0436:  MOVF   58,W
0437:  MOVWF  5F
0438:  BCF    03.5
0439:  CALL   216
043A:  BSF    03.5
043B:  MOVF   59,W
043C:  SUBWF  78,W
043D:  CLRF   7A
043E:  MOVWF  77
043F:  BTFSC  77.7
0440:  DECF   7A,F
0441:  MOVWF  5A
0442:  MOVF   7A,W
0443:  MOVWF  5B
....................  
....................       for(i=0; i<=dy; ++i) 
0444:  CLRF   5C
0445:  BTFSC  59.7
0446:  GOTO   48B
0447:  MOVF   5C,W
0448:  SUBWF  59,W
0449:  BTFSS  03.0
044A:  GOTO   48B
....................       { 
....................          glcd_pixel(x, y, color); 
044B:  MOVF   54,W
044C:  MOVWF  5D
044D:  MOVF   55,W
044E:  MOVWF  5E
044F:  MOVF   53,W
0450:  MOVWF  5F
0451:  BCF    03.5
0452:  CALL   2FE
....................  
....................          if(P < 0) 
0453:  BSF    03.5
0454:  BTFSS  5B.7
0455:  GOTO   46A
....................          { 
....................             P += 2*dx; 
0456:  MOVLW  02
0457:  MOVWF  5E
0458:  MOVF   58,W
0459:  MOVWF  5F
045A:  BCF    03.5
045B:  CALL   216
045C:  MOVF   78,W
045D:  CLRF   7A
045E:  MOVWF  77
045F:  BTFSC  77.7
0460:  DECF   7A,F
0461:  BSF    03.5
0462:  ADDWF  5A,F
0463:  MOVF   7A,W
0464:  BTFSC  03.0
0465:  INCFSZ 7A,W
0466:  ADDWF  5B,F
....................             y += addy; 
0467:  MOVF   57,W
0468:  ADDWF  55,F
....................          } 
0469:  GOTO   489
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
046A:  MOVLW  02
046B:  MOVWF  5E
046C:  MOVF   58,W
046D:  MOVWF  5F
046E:  BCF    03.5
046F:  CALL   216
0470:  MOVF   78,W
0471:  BSF    03.5
0472:  MOVWF  5D
0473:  MOVLW  02
0474:  MOVWF  5E
0475:  MOVF   59,W
0476:  MOVWF  5F
0477:  BCF    03.5
0478:  CALL   216
0479:  MOVF   78,W
047A:  BSF    03.5
047B:  SUBWF  5D,W
047C:  CLRF   7A
047D:  MOVWF  77
047E:  BTFSC  77.7
047F:  DECF   7A,F
0480:  ADDWF  5A,F
0481:  MOVF   7A,W
0482:  BTFSC  03.0
0483:  INCFSZ 7A,W
0484:  ADDWF  5B,F
....................             x += addx; 
0485:  MOVF   56,W
0486:  ADDWF  54,F
....................             y += addy; 
0487:  MOVF   57,W
0488:  ADDWF  55,F
....................          } 
0489:  INCF   5C,F
048A:  GOTO   445
....................       } 
....................    } 
048B:  BCF    03.5
048C:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
*
04DD:  BSF    03.5
04DE:  CLRF   51
04DF:  MOVF   51,W
04E0:  ADDWF  4D,W
04E1:  MOVWF  04
04E2:  BCF    03.7
04E3:  BTFSC  4E.0
04E4:  BSF    03.7
04E5:  MOVF   00,F
04E6:  BTFSC  03.2
04E7:  GOTO   5B2
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
04E8:  MOVF   51,W
04E9:  ADDWF  4D,W
04EA:  MOVWF  04
04EB:  BCF    03.7
04EC:  BTFSC  4E.0
04ED:  BSF    03.7
04EE:  MOVF   00,W
04EF:  SUBLW  52
04F0:  BTFSS  03.0
04F1:  GOTO   516
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
04F2:  MOVF   51,W
04F3:  ADDWF  4D,W
04F4:  MOVWF  04
04F5:  BCF    03.7
04F6:  BTFSC  4E.0
04F7:  BSF    03.7
04F8:  MOVLW  20
04F9:  SUBWF  00,W
04FA:  MOVWF  5C
04FB:  MOVWF  5E
04FC:  MOVLW  05
04FD:  MOVWF  5F
04FE:  BCF    03.5
04FF:  CALL   216
0500:  MOVF   78,W
0501:  BSF    03.5
0502:  MOVWF  5B
0503:  MOVWF  78
0504:  MOVLW  05
0505:  MOVWF  77
0506:  MOVLW  D6
0507:  MOVWF  04
0508:  BCF    03.7
0509:  MOVF   78,W
050A:  BCF    03.5
050B:  CALL   004
050C:  MOVWF  00
050D:  INCF   78,F
050E:  INCF   04,F
050F:  DECFSZ 77,F
0510:  GOTO   512
0511:  GOTO   514
0512:  BSF    03.5
0513:  GOTO   509
0514:  GOTO   54A
0515:  BSF    03.5
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
0516:  MOVF   51,W
0517:  ADDWF  4D,W
0518:  MOVWF  04
0519:  BCF    03.7
051A:  BTFSC  4E.0
051B:  BSF    03.7
051C:  MOVF   00,W
051D:  SUBLW  7E
051E:  BTFSS  03.0
051F:  GOTO   544
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
0520:  MOVF   51,W
0521:  ADDWF  4D,W
0522:  MOVWF  04
0523:  BCF    03.7
0524:  BTFSC  4E.0
0525:  BSF    03.7
0526:  MOVLW  53
0527:  SUBWF  00,W
0528:  MOVWF  5C
0529:  MOVWF  5E
052A:  MOVLW  05
052B:  MOVWF  5F
052C:  BCF    03.5
052D:  CALL   216
052E:  MOVF   78,W
052F:  BSF    03.5
0530:  MOVWF  5B
0531:  MOVWF  78
0532:  MOVLW  05
0533:  MOVWF  77
0534:  MOVLW  D6
0535:  MOVWF  04
0536:  BCF    03.7
0537:  MOVF   78,W
0538:  BCF    03.5
0539:  CALL   10A
053A:  MOVWF  00
053B:  INCF   78,F
053C:  INCF   04,F
053D:  DECFSZ 77,F
053E:  GOTO   540
053F:  GOTO   542
0540:  BSF    03.5
0541:  GOTO   537
0542:  GOTO   54A
0543:  BSF    03.5
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
0544:  CLRF   56
0545:  CLRF   57
0546:  CLRF   58
0547:  CLRF   59
0548:  CLRF   5A
0549:  BCF    03.5
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
054A:  MOVLW  05
054B:  BSF    03.5
054C:  MOVWF  5E
054D:  MOVF   4F,W
054E:  MOVWF  5F
054F:  BCF    03.5
0550:  CALL   216
0551:  MOVF   78,W
0552:  BSF    03.5
0553:  ADDWF  4B,W
0554:  SUBLW  7F
0555:  BTFSC  03.0
0556:  GOTO   562
....................       { 
....................          x = 0;                           // Set x at far left position 
0557:  CLRF   4B
....................          y += 7*size + 1;                 // Set y at next position down 
0558:  MOVLW  07
0559:  MOVWF  5E
055A:  MOVF   4F,W
055B:  MOVWF  5F
055C:  BCF    03.5
055D:  CALL   216
055E:  MOVLW  01
055F:  ADDWF  78,W
0560:  BSF    03.5
0561:  ADDWF  4C,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0562:  CLRF   52
0563:  MOVF   52,W
0564:  SUBLW  04
0565:  BTFSS  03.0
0566:  GOTO   5AF
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
0567:  CLRF   53
0568:  MOVLW  07
0569:  MOVWF  5E
056A:  MOVF   4F,W
056B:  MOVWF  5F
056C:  BCF    03.5
056D:  CALL   216
056E:  MOVF   78,W
056F:  BSF    03.5
0570:  SUBWF  53,W
0571:  BTFSC  03.0
0572:  GOTO   5AB
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
0573:  MOVLW  D6
0574:  ADDWF  52,W
0575:  MOVWF  04
0576:  BCF    03.7
0577:  MOVF   00,W
0578:  MOVWF  5B
0579:  MOVWF  77
057A:  MOVF   53,W
057B:  MOVWF  78
057C:  BTFSC  03.2
057D:  GOTO   582
057E:  BCF    03.0
057F:  RRF    77,F
0580:  DECFSZ 78,F
0581:  GOTO   57E
0582:  BTFSS  77.0
0583:  GOTO   5A9
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
0584:  CLRF   54
0585:  MOVF   4F,W
0586:  SUBWF  54,W
0587:  BTFSC  03.0
0588:  GOTO   5A9
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
0589:  CLRF   55
058A:  MOVF   4F,W
058B:  SUBWF  55,W
058C:  BTFSC  03.0
058D:  GOTO   5A7
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
058E:  MOVF   55,W
058F:  ADDWF  4B,W
0590:  MOVWF  5B
0591:  MOVF   53,W
0592:  MOVWF  5E
0593:  MOVF   4F,W
0594:  MOVWF  5F
0595:  BCF    03.5
0596:  CALL   216
0597:  MOVF   78,W
0598:  BSF    03.5
0599:  ADDWF  4C,W
059A:  ADDWF  54,W
059B:  MOVWF  5C
059C:  MOVF   5B,W
059D:  MOVWF  5D
059E:  MOVF   5C,W
059F:  MOVWF  5E
05A0:  MOVF   50,W
05A1:  MOVWF  5F
05A2:  BCF    03.5
05A3:  CALL   2FE
05A4:  BSF    03.5
05A5:  INCF   55,F
05A6:  GOTO   58A
....................                   } 
05A7:  INCF   54,F
05A8:  GOTO   585
....................                } 
....................             } 
05A9:  INCF   53,F
05AA:  GOTO   568
....................          } 
05AB:  INCF   52,F
05AC:  MOVF   4F,W
05AD:  ADDWF  4B,F
05AE:  GOTO   563
....................       } 
05AF:  INCF   51,F
05B0:  INCF   4B,F
05B1:  GOTO   4DF
....................    } 
05B2:  BCF    03.5
05B3:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
023D:  BSF    03.5
023E:  CLRF   4D
023F:  MOVF   4D,W
0240:  SUBLW  07
0241:  BTFSS  03.0
0242:  GOTO   296
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
0243:  BCF    06.2
0244:  BCF    03.5
0245:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0246:  MOVLW  30
0247:  BSF    03.5
0248:  MOVWF  63
0249:  MOVLW  40
024A:  MOVWF  64
024B:  BCF    03.5
024C:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
024D:  MOVLW  31
024E:  BSF    03.5
024F:  MOVWF  63
0250:  MOVLW  40
0251:  MOVWF  64
0252:  BCF    03.5
0253:  CALL   1EA
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
0254:  BSF    03.5
0255:  MOVF   4D,W
0256:  IORLW  B8
0257:  MOVWF  4F
0258:  MOVLW  30
0259:  MOVWF  63
025A:  MOVF   4F,W
025B:  MOVWF  64
025C:  BCF    03.5
025D:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
025E:  BSF    03.5
025F:  MOVF   4D,W
0260:  IORLW  B8
0261:  MOVWF  4F
0262:  MOVLW  31
0263:  MOVWF  63
0264:  MOVF   4F,W
0265:  MOVWF  64
0266:  BCF    03.5
0267:  CALL   1EA
....................       output_high(GLCD_DI);                     // Set for data 
0268:  BSF    03.5
0269:  BCF    06.2
026A:  BCF    03.5
026B:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
026C:  BSF    03.5
026D:  CLRF   4E
026E:  MOVF   4E,W
026F:  SUBLW  3F
0270:  BTFSS  03.0
0271:  GOTO   294
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0272:  MOVLW  FF
0273:  MOVWF  5E
0274:  MOVF   4C,W
0275:  MOVWF  5F
0276:  BCF    03.5
0277:  CALL   216
0278:  MOVF   78,W
0279:  BSF    03.5
027A:  MOVWF  4F
027B:  MOVLW  30
027C:  MOVWF  63
027D:  MOVF   4F,W
027E:  MOVWF  64
027F:  BCF    03.5
0280:  CALL   1EA
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
0281:  MOVLW  FF
0282:  BSF    03.5
0283:  MOVWF  5E
0284:  MOVF   4C,W
0285:  MOVWF  5F
0286:  BCF    03.5
0287:  CALL   216
0288:  MOVF   78,W
0289:  BSF    03.5
028A:  MOVWF  4F
028B:  MOVLW  31
028C:  MOVWF  63
028D:  MOVF   4F,W
028E:  MOVWF  64
028F:  BCF    03.5
0290:  CALL   1EA
0291:  BSF    03.5
0292:  INCF   4E,F
0293:  GOTO   26E
....................       } 
0294:  INCF   4D,F
0295:  GOTO   23F
....................    } 
0296:  BCF    03.5
0297:  RETURN
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
01EA:  BSF    03.5
01EB:  MOVF   63,W
01EC:  SUBLW  30
01ED:  BTFSS  03.2
01EE:  GOTO   1F4
....................       output_high(GLCD_CS1); 
01EF:  BCF    06.0
01F0:  BCF    03.5
01F1:  BSF    06.0
01F2:  GOTO   1F7
01F3:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS2); 
01F4:  BCF    06.1
01F5:  BCF    03.5
01F6:  BSF    06.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
01F7:  BSF    03.5
01F8:  BCF    06.4
01F9:  BCF    03.5
01FA:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
01FB:  BSF    03.5
01FC:  CLRF   08
01FD:  MOVF   64,W
01FE:  BCF    03.5
01FF:  MOVWF  08
....................    output_high(GLCD_E);       // Pulse the enable pin 
0200:  BSF    03.5
0201:  BCF    06.5
0202:  BCF    03.5
0203:  BSF    06.5
....................    delay_us(2); 
0204:  MOVLW  02
0205:  MOVWF  77
0206:  DECFSZ 77,F
0207:  GOTO   206
0208:  NOP
....................    output_low(GLCD_E); 
0209:  BSF    03.5
020A:  BCF    06.5
020B:  BCF    03.5
020C:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
020D:  BSF    03.5
020E:  BCF    06.0
020F:  BCF    03.5
0210:  BCF    06.0
....................    output_low(GLCD_CS2); 
0211:  BSF    03.5
0212:  BCF    06.1
0213:  BCF    03.5
0214:  BCF    06.1
0215:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
032D:  MOVF   62,W
032E:  SUBLW  30
032F:  BTFSS  03.2
0330:  GOTO   336
....................       output_high(GLCD_CS1); 
0331:  BCF    06.0
0332:  BCF    03.5
0333:  BSF    06.0
0334:  GOTO   339
0335:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS2); 
0336:  BCF    06.1
0337:  BCF    03.5
0338:  BSF    06.1
....................  
....................    input_d();                 // Set port d to input 
0339:  MOVLW  FF
033A:  BSF    03.5
033B:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
033C:  BCF    06.4
033D:  BCF    03.5
033E:  BSF    06.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
033F:  BSF    03.5
0340:  BCF    06.5
0341:  BCF    03.5
0342:  BSF    06.5
....................    delay_us(2); 
0343:  MOVLW  02
0344:  MOVWF  77
0345:  DECFSZ 77,F
0346:  GOTO   345
0347:  NOP
....................    output_low(GLCD_E); 
0348:  BSF    03.5
0349:  BCF    06.5
034A:  BCF    03.5
034B:  BCF    06.5
....................    delay_us(2); 
034C:  MOVLW  02
034D:  MOVWF  77
034E:  DECFSZ 77,F
034F:  GOTO   34E
0350:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
0351:  BSF    03.5
0352:  BCF    06.5
0353:  BCF    03.5
0354:  BSF    06.5
....................    delay_us(2); 
0355:  MOVLW  02
0356:  MOVWF  77
0357:  DECFSZ 77,F
0358:  GOTO   357
0359:  NOP
....................    data = input_d();          // Get the data from the display's output register 
035A:  MOVLW  FF
035B:  BSF    03.5
035C:  MOVWF  08
035D:  BCF    03.5
035E:  MOVF   08,W
035F:  BSF    03.5
0360:  MOVWF  63
....................    output_low(GLCD_E); 
0361:  BCF    06.5
0362:  BCF    03.5
0363:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0364:  BSF    03.5
0365:  BCF    06.0
0366:  BCF    03.5
0367:  BCF    06.0
....................    output_low(GLCD_CS2); 
0368:  BSF    03.5
0369:  BCF    06.1
036A:  BCF    03.5
036B:  BCF    06.1
....................    return data;               // Return the read data 
036C:  BSF    03.5
036D:  MOVF   63,W
036E:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define uchar unsigned char 
....................  
.................... #define GRID_SIZE     6 
.................... #define GRID_COLS     10 
.................... #define GRID_ROWS     10 
.................... #define GRID_ORIGIN_X 0 
.................... #define GRID_ORIGIN_Y 0 
....................  
.................... uchar SNAKE[40][2]; 
.................... uchar dir = 2; 
.................... uchar food[2], LENGTH_SNAKE = 3; 
.................... uchar posX = 1, posY = 2; 
.................... uchar score = 0; 
.................... uchar best_score = 0; 
.................... int grow = 0; // ?? Yem yendiyse bu 1 olur, kuyruk silinmez 
....................  
.................... char score_txt[11] = "Score: 00"; 
*
081B:  MOVLW  53
081C:  BSF    03.5
081D:  MOVWF  25
081E:  MOVLW  63
081F:  MOVWF  26
0820:  MOVLW  6F
0821:  MOVWF  27
0822:  MOVLW  72
0823:  MOVWF  28
0824:  MOVLW  65
0825:  MOVWF  29
0826:  MOVLW  3A
0827:  MOVWF  2A
0828:  MOVLW  20
0829:  MOVWF  2B
082A:  MOVLW  30
082B:  MOVWF  2C
082C:  MOVWF  2D
082D:  CLRF   2E
.................... char best_score_txt[10] = "Best: 00"; 
082E:  MOVLW  42
082F:  MOVWF  30
0830:  MOVLW  65
0831:  MOVWF  31
0832:  MOVLW  73
0833:  MOVWF  32
0834:  MOVLW  74
0835:  MOVWF  33
0836:  MOVLW  3A
0837:  MOVWF  34
0838:  MOVLW  20
0839:  MOVWF  35
083A:  MOVLW  30
083B:  MOVWF  36
083C:  MOVWF  37
083D:  CLRF   38
.................... char gayover[14] = "GAME OVER !!!"; 
083E:  MOVLW  47
083F:  MOVWF  3A
0840:  MOVLW  41
0841:  MOVWF  3B
0842:  MOVLW  4D
0843:  MOVWF  3C
0844:  MOVLW  45
0845:  MOVWF  3D
0846:  MOVLW  20
0847:  MOVWF  3E
0848:  MOVLW  4F
0849:  MOVWF  3F
084A:  MOVLW  56
084B:  MOVWF  40
084C:  MOVLW  45
084D:  MOVWF  41
084E:  MOVLW  52
084F:  MOVWF  42
0850:  MOVLW  20
0851:  MOVWF  43
0852:  MOVLW  21
0853:  MOVWF  44
0854:  MOVWF  45
0855:  MOVWF  46
0856:  CLRF   47
.................... uchar i; 
....................  
.................... void drawGrid() { 
....................    for (uchar c = 0; c <= GRID_COLS; c++) { 
*
048D:  BSF    03.5
048E:  CLRF   4B
048F:  MOVF   4B,W
0490:  SUBLW  0A
0491:  BTFSS  03.0
0492:  GOTO   4AA
....................       uchar x = GRID_ORIGIN_X + c * GRID_SIZE; 
0493:  MOVF   4B,W
0494:  MOVWF  5E
0495:  MOVLW  06
0496:  MOVWF  5F
0497:  BCF    03.5
0498:  CALL   216
0499:  MOVF   78,W
049A:  BSF    03.5
049B:  MOVWF  4C
....................       glcd_line(x, GRID_ORIGIN_Y, x, GRID_ORIGIN_Y + GRID_ROWS * GRID_SIZE, 1); 
049C:  MOVF   4C,W
049D:  MOVWF  4F
049E:  CLRF   50
049F:  MOVF   4C,W
04A0:  MOVWF  51
04A1:  MOVLW  3C
04A2:  MOVWF  52
04A3:  MOVLW  01
04A4:  MOVWF  53
04A5:  BCF    03.5
04A6:  CALL   3A9
04A7:  BSF    03.5
04A8:  INCF   4B,F
04A9:  GOTO   48F
....................    } 
....................    for (uchar r = 0; r <= GRID_ROWS; r++) { 
04AA:  CLRF   4D
04AB:  MOVF   4D,W
04AC:  SUBLW  0A
04AD:  BTFSS  03.0
04AE:  GOTO   4C6
....................       uchar y = GRID_ORIGIN_Y + r * GRID_SIZE; 
04AF:  MOVF   4D,W
04B0:  MOVWF  5E
04B1:  MOVLW  06
04B2:  MOVWF  5F
04B3:  BCF    03.5
04B4:  CALL   216
04B5:  MOVF   78,W
04B6:  BSF    03.5
04B7:  MOVWF  4E
....................       glcd_line(GRID_ORIGIN_X, y, GRID_ORIGIN_X + GRID_COLS * GRID_SIZE, y, 1); 
04B8:  CLRF   4F
04B9:  MOVF   4E,W
04BA:  MOVWF  50
04BB:  MOVLW  3C
04BC:  MOVWF  51
04BD:  MOVF   4E,W
04BE:  MOVWF  52
04BF:  MOVLW  01
04C0:  MOVWF  53
04C1:  BCF    03.5
04C2:  CALL   3A9
04C3:  BSF    03.5
04C4:  INCF   4D,F
04C5:  GOTO   4AB
....................    } 
04C6:  BCF    03.5
04C7:  RETURN
.................... } 
....................  
.................... void fillCell(uchar gx, uchar gy, int1 color) { 
*
068A:  BSF    03.5
068B:  MOVF   4D,W
068C:  MOVWF  5E
068D:  MOVLW  06
068E:  MOVWF  5F
068F:  BCF    03.5
0690:  CALL   216
0691:  MOVLW  01
0692:  ADDWF  78,W
0693:  BSF    03.5
0694:  MOVWF  50
0695:  MOVF   4E,W
0696:  MOVWF  5E
0697:  MOVLW  06
0698:  MOVWF  5F
0699:  BCF    03.5
069A:  CALL   216
069B:  MOVLW  01
069C:  ADDWF  78,W
069D:  BSF    03.5
069E:  MOVWF  51
....................    uchar px = GRID_ORIGIN_X + gx * GRID_SIZE + 1; 
....................    uchar py = GRID_ORIGIN_Y + gy * GRID_SIZE + 1; 
....................    for (uchar dx = 0; dx < GRID_SIZE - 1; dx++) 
069F:  CLRF   52
06A0:  MOVF   52,W
06A1:  SUBLW  04
06A2:  BTFSS  03.0
06A3:  GOTO   6BC
....................       for (uchar dy = 0; dy < GRID_SIZE - 1; dy++) 
06A4:  CLRF   53
06A5:  MOVF   53,W
06A6:  SUBLW  04
06A7:  BTFSS  03.0
06A8:  GOTO   6BA
....................          glcd_pixel(px + dx, py + dy, color); 
06A9:  MOVF   52,W
06AA:  ADDWF  50,W
06AB:  MOVWF  54
06AC:  MOVF   53,W
06AD:  ADDWF  51,W
06AE:  MOVWF  55
06AF:  MOVF   54,W
06B0:  MOVWF  5D
06B1:  MOVF   55,W
06B2:  MOVWF  5E
06B3:  MOVF   4F,W
06B4:  MOVWF  5F
06B5:  BCF    03.5
06B6:  CALL   2FE
06B7:  BSF    03.5
06B8:  INCF   53,F
06B9:  GOTO   6A5
06BA:  INCF   52,F
06BB:  GOTO   6A0
06BC:  BCF    03.5
06BD:  RETURN
.................... } 
....................  
.................... void clearScoreArea() { 
....................    for (uchar x = 65; x < 125; x++) { 
*
05B4:  MOVLW  41
05B5:  BSF    03.5
05B6:  MOVWF  4B
05B7:  MOVF   4B,W
05B8:  SUBLW  7C
05B9:  BTFSS  03.0
05BA:  GOTO   5CC
....................       for (uchar y = 0; y < 20; y++) { 
05BB:  CLRF   4C
05BC:  MOVF   4C,W
05BD:  SUBLW  13
05BE:  BTFSS  03.0
05BF:  GOTO   5CA
....................          glcd_pixel(x, y, 0); 
05C0:  MOVF   4B,W
05C1:  MOVWF  5D
05C2:  MOVF   4C,W
05C3:  MOVWF  5E
05C4:  CLRF   5F
05C5:  BCF    03.5
05C6:  CALL   2FE
05C7:  BSF    03.5
05C8:  INCF   4C,F
05C9:  GOTO   5BC
....................       } 
05CA:  INCF   4B,F
05CB:  GOTO   5B7
....................    } 
.................... } 
....................  
.................... void writeScore() { 
....................    clearScoreArea(); 
....................    glcd_text57(65, 0, score_txt, 1, 1); 
05CC:  MOVLW  41
05CD:  MOVWF  4B
05CE:  CLRF   4C
05CF:  CLRF   4E
05D0:  MOVLW  A5
05D1:  MOVWF  4D
05D2:  MOVLW  01
05D3:  MOVWF  4F
05D4:  MOVWF  50
05D5:  BCF    03.5
05D6:  CALL   4DD
....................    glcd_text57(65, 10, best_score_txt, 1, 1); 
05D7:  MOVLW  41
05D8:  BSF    03.5
05D9:  MOVWF  4B
05DA:  MOVLW  0A
05DB:  MOVWF  4C
05DC:  CLRF   4E
05DD:  MOVLW  B0
05DE:  MOVWF  4D
05DF:  MOVLW  01
05E0:  MOVWF  4F
05E1:  MOVWF  50
05E2:  BCF    03.5
05E3:  CALL   4DD
05E4:  RETURN
.................... } 
....................  
.................... void criar_comida() { 
*
06BE:  BSF    03.5
06BF:  CLRF   4B
....................    uchar valid = 0; 
....................    while (!valid) { 
06C0:  MOVF   4B,F
06C1:  BTFSS  03.2
06C2:  GOTO   706
....................       food[0] = rand() % GRID_COLS; 
06C3:  BCF    03.5
06C4:  CALL   60C
06C5:  MOVF   79,W
06C6:  BSF    03.5
06C7:  MOVWF  4E
06C8:  MOVF   78,W
06C9:  MOVWF  4D
06CA:  MOVF   4E,W
06CB:  MOVWF  51
06CC:  MOVF   4D,W
06CD:  MOVWF  50
06CE:  CLRF   53
06CF:  MOVLW  0A
06D0:  MOVWF  52
06D1:  BCF    03.5
06D2:  CALL   5E5
06D3:  MOVF   77,W
06D4:  MOVWF  7C
....................       food[1] = rand() % GRID_ROWS; 
06D5:  CALL   60C
06D6:  MOVF   79,W
06D7:  BSF    03.5
06D8:  MOVWF  4E
06D9:  MOVF   78,W
06DA:  MOVWF  4D
06DB:  MOVF   4E,W
06DC:  MOVWF  51
06DD:  MOVF   4D,W
06DE:  MOVWF  50
06DF:  CLRF   53
06E0:  MOVLW  0A
06E1:  MOVWF  52
06E2:  BCF    03.5
06E3:  CALL   5E5
06E4:  MOVF   77,W
06E5:  MOVWF  7D
....................       valid = 1; 
06E6:  MOVLW  01
06E7:  BSF    03.5
06E8:  MOVWF  4B
....................       for (uchar j = 0; j < LENGTH_SNAKE; j++) { 
06E9:  CLRF   4C
06EA:  MOVF   7E,W
06EB:  SUBWF  4C,W
06EC:  BTFSC  03.0
06ED:  GOTO   705
....................          if (SNAKE[j][0] == food[0] && SNAKE[j][1] == food[1]) { 
06EE:  BCF    03.0
06EF:  RLF    4C,W
06F0:  ADDLW  27
06F1:  MOVWF  04
06F2:  BCF    03.7
06F3:  MOVF   7C,W
06F4:  SUBWF  00,W
06F5:  BTFSS  03.2
06F6:  GOTO   703
06F7:  BCF    03.0
06F8:  RLF    4C,W
06F9:  ADDLW  01
06FA:  ADDLW  27
06FB:  MOVWF  04
06FC:  BCF    03.7
06FD:  MOVF   7D,W
06FE:  SUBWF  00,W
06FF:  BTFSS  03.2
0700:  GOTO   703
....................             valid = 0; 
0701:  CLRF   4B
....................             break; 
0702:  GOTO   705
....................          } 
0703:  INCF   4C,F
0704:  GOTO   6EA
....................       } 
0705:  GOTO   6C0
....................    } 
....................    fillCell(food[0], food[1], 1); 
0706:  MOVF   7C,W
0707:  MOVWF  4D
0708:  MOVF   7D,W
0709:  MOVWF  4E
070A:  MOVLW  01
070B:  MOVWF  4F
070C:  BCF    03.5
070D:  CALL   68A
070E:  RETURN
.................... } 
....................  
.................... void gameover() { 
....................    LENGTH_SNAKE = 3; 
070F:  MOVLW  03
0710:  MOVWF  7E
....................    posX = 1; 
0711:  MOVLW  01
0712:  BSF    03.5
0713:  MOVWF  20
....................    posY = 2; 
0714:  MOVLW  02
0715:  MOVWF  21
....................    score = 0; 
0716:  CLRF   22
....................    grow = 0; 
0717:  CLRF   24
....................    score_txt[7] = score_txt[8] = '0'; 
0718:  MOVLW  30
0719:  MOVWF  2D
071A:  MOVWF  2C
....................    dir = 2; 
071B:  MOVLW  02
071C:  MOVWF  7B
....................    glcd_fillScreen(0); 
071D:  CLRF   4C
071E:  BCF    03.5
071F:  CALL   23D
....................    drawGrid(); 
0720:  CALL   48D
....................    glcd_text57(25, 60, gayover, 1, 1); 
0721:  MOVLW  19
0722:  BSF    03.5
0723:  MOVWF  4B
0724:  MOVLW  3C
0725:  MOVWF  4C
0726:  CLRF   4E
0727:  MOVLW  BA
0728:  MOVWF  4D
0729:  MOVLW  01
072A:  MOVWF  4F
072B:  MOVWF  50
072C:  BCF    03.5
072D:  CALL   4DD
....................    delay_ms(1000); 
072E:  MOVLW  04
072F:  BSF    03.5
0730:  MOVWF  4B
0731:  MOVLW  FA
0732:  MOVWF  4C
0733:  BCF    03.5
0734:  CALL   4C8
0735:  BSF    03.5
0736:  DECFSZ 4B,F
0737:  GOTO   731
0738:  BCF    03.5
0739:  RETURN
.................... } 
....................  
.................... void main() { 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  FF
0804:  MOVWF  26
0805:  MOVLW  02
0806:  MOVWF  7B
0807:  MOVLW  03
0808:  MOVWF  7E
0809:  MOVLW  01
080A:  BSF    03.5
080B:  MOVWF  20
080C:  MOVLW  02
080D:  MOVWF  21
080E:  CLRF   22
080F:  CLRF   23
0810:  CLRF   24
0811:  BSF    1F.0
0812:  BSF    1F.1
0813:  BSF    1F.2
0814:  BCF    1F.3
0815:  MOVLW  07
0816:  MOVWF  1C
0817:  BCF    03.7
....................    glcd_init(ON); 
*
0857:  MOVLW  01
0858:  MOVWF  4B
0859:  BCF    0A.3
085A:  BCF    03.5
085B:  GOTO   298
085C:  BSF    0A.3
....................    glcd_fillScreen(0); 
085D:  BSF    03.5
085E:  CLRF   4C
085F:  BCF    0A.3
0860:  BCF    03.5
0861:  CALL   23D
0862:  BSF    0A.3
....................    drawGrid(); 
0863:  BCF    0A.3
0864:  CALL   48D
0865:  BSF    0A.3
....................    delay_ms(500); 
0866:  MOVLW  02
0867:  BSF    03.5
0868:  MOVWF  4B
0869:  MOVLW  FA
086A:  MOVWF  4C
086B:  BCF    0A.3
086C:  BCF    03.5
086D:  CALL   4C8
086E:  BSF    0A.3
086F:  BSF    03.5
0870:  DECFSZ 4B,F
0871:  GOTO   069
....................  
.................... Start: 
....................    glcd_fillScreen(0); 
0872:  CLRF   4C
0873:  BCF    0A.3
0874:  BCF    03.5
0875:  CALL   23D
0876:  BSF    0A.3
....................    drawGrid(); 
0877:  BCF    0A.3
0878:  CALL   48D
0879:  BSF    0A.3
....................    writeScore(); 
087A:  BCF    0A.3
087B:  CALL   5B4
087C:  BSF    0A.3
....................    criar_comida(); 
087D:  BCF    0A.3
087E:  CALL   6BE
087F:  BSF    0A.3
....................  
....................    for (i = 0; i < LENGTH_SNAKE; i++) { 
0880:  BSF    03.5
0881:  CLRF   48
0882:  MOVF   7E,W
0883:  SUBWF  48,W
0884:  BTFSC  03.0
0885:  GOTO   0B6
....................       SNAKE[i][0] = posX - (LENGTH_SNAKE - 1 - i); 
0886:  BCF    03.0
0887:  RLF    48,W
0888:  ADDLW  27
0889:  MOVWF  04
088A:  BCF    03.7
088B:  MOVLW  01
088C:  SUBWF  7E,W
088D:  MOVWF  78
088E:  MOVF   48,W
088F:  SUBWF  78,W
0890:  SUBWF  20,W
0891:  MOVWF  00
....................       SNAKE[i][1] = posY; 
0892:  BCF    03.0
0893:  RLF    48,W
0894:  ADDLW  01
0895:  ADDLW  27
0896:  MOVWF  04
0897:  BCF    03.7
0898:  MOVF   21,W
0899:  MOVWF  00
....................       fillCell(SNAKE[i][0], SNAKE[i][1], 1); 
089A:  BCF    03.0
089B:  RLF    48,W
089C:  ADDLW  27
089D:  MOVWF  04
089E:  BCF    03.7
089F:  MOVF   00,W
08A0:  MOVWF  4B
08A1:  BCF    03.0
08A2:  RLF    48,W
08A3:  ADDLW  01
08A4:  ADDLW  27
08A5:  MOVWF  04
08A6:  BCF    03.7
08A7:  MOVF   00,W
08A8:  MOVWF  4C
08A9:  MOVF   4B,W
08AA:  MOVWF  4D
08AB:  MOVF   4C,W
08AC:  MOVWF  4E
08AD:  MOVLW  01
08AE:  MOVWF  4F
08AF:  BCF    0A.3
08B0:  BCF    03.5
08B1:  CALL   68A
08B2:  BSF    0A.3
08B3:  BSF    03.5
08B4:  INCF   48,F
08B5:  GOTO   082
....................    } 
....................  
....................    while (TRUE) { 
....................       if (input(PIN_C3) && dir != 0) dir = 3; 
08B6:  BCF    03.5
08B7:  BSF    26.3
08B8:  MOVF   26,W
08B9:  BSF    03.5
08BA:  MOVWF  07
08BB:  BCF    03.5
08BC:  BTFSS  07.3
08BD:  GOTO   0C3
08BE:  MOVF   7B,F
08BF:  BTFSC  03.2
08C0:  GOTO   0C3
08C1:  MOVLW  03
08C2:  MOVWF  7B
....................       if (input(PIN_C2) && dir != 1) dir = 2; 
08C3:  BSF    26.2
08C4:  MOVF   26,W
08C5:  BSF    03.5
08C6:  MOVWF  07
08C7:  BCF    03.5
08C8:  BTFSS  07.2
08C9:  GOTO   0CF
08CA:  DECFSZ 7B,W
08CB:  GOTO   0CD
08CC:  GOTO   0CF
08CD:  MOVLW  02
08CE:  MOVWF  7B
....................       if (input(PIN_C1) && dir != 2) dir = 1; 
08CF:  BSF    26.1
08D0:  MOVF   26,W
08D1:  BSF    03.5
08D2:  MOVWF  07
08D3:  BCF    03.5
08D4:  BTFSS  07.1
08D5:  GOTO   0DC
08D6:  MOVF   7B,W
08D7:  SUBLW  02
08D8:  BTFSC  03.2
08D9:  GOTO   0DC
08DA:  MOVLW  01
08DB:  MOVWF  7B
....................       if (input(PIN_C4) && dir != 3) dir = 0; 
08DC:  BSF    26.4
08DD:  MOVF   26,W
08DE:  BSF    03.5
08DF:  MOVWF  07
08E0:  BCF    03.5
08E1:  BTFSS  07.4
08E2:  GOTO   0E7
08E3:  MOVF   7B,W
08E4:  SUBLW  03
08E5:  BTFSS  03.2
08E6:  CLRF   7B
....................       if (input(PIN_C5)) { gameover(); goto Start; } 
08E7:  BSF    26.5
08E8:  MOVF   26,W
08E9:  BSF    03.5
08EA:  MOVWF  07
08EB:  BCF    03.5
08EC:  BTFSS  07.5
08ED:  GOTO   0F4
08EE:  BCF    0A.3
08EF:  CALL   70F
08F0:  BSF    0A.3
08F1:  BSF    03.5
08F2:  GOTO   072
08F3:  BCF    03.5
....................  
....................       switch(dir) { 
08F4:  MOVF   7B,W
08F5:  ADDLW  FC
08F6:  BTFSC  03.0
08F7:  GOTO   133
08F8:  ADDLW  04
08F9:  GOTO   220
....................          case 0: if (posX == 0) { gameover(); goto Start; } else posX--; break; 
08FA:  BSF    03.5
08FB:  MOVF   20,F
08FC:  BTFSS  03.2
08FD:  GOTO   105
08FE:  BCF    0A.3
08FF:  BCF    03.5
0900:  CALL   70F
0901:  BSF    0A.3
0902:  BSF    03.5
0903:  GOTO   072
0904:  GOTO   106
0905:  DECF   20,F
0906:  BCF    03.5
0907:  GOTO   133
....................          case 1: if (posY == 0) { gameover(); goto Start; } else posY--; break; 
0908:  BSF    03.5
0909:  MOVF   21,F
090A:  BTFSS  03.2
090B:  GOTO   113
090C:  BCF    0A.3
090D:  BCF    03.5
090E:  CALL   70F
090F:  BSF    0A.3
0910:  BSF    03.5
0911:  GOTO   072
0912:  GOTO   114
0913:  DECF   21,F
0914:  BCF    03.5
0915:  GOTO   133
....................          case 2: if (posY == GRID_ROWS - 1) { gameover(); goto Start; } else posY++; break; 
0916:  BSF    03.5
0917:  MOVF   21,W
0918:  SUBLW  09
0919:  BTFSS  03.2
091A:  GOTO   122
091B:  BCF    0A.3
091C:  BCF    03.5
091D:  CALL   70F
091E:  BSF    0A.3
091F:  BSF    03.5
0920:  GOTO   072
0921:  GOTO   123
0922:  INCF   21,F
0923:  BCF    03.5
0924:  GOTO   133
....................          case 3: if (posX == GRID_COLS - 1) { gameover(); goto Start; } else posX++; break; 
0925:  BSF    03.5
0926:  MOVF   20,W
0927:  SUBLW  09
0928:  BTFSS  03.2
0929:  GOTO   131
092A:  BCF    0A.3
092B:  BCF    03.5
092C:  CALL   70F
092D:  BSF    0A.3
092E:  BSF    03.5
092F:  GOTO   072
0930:  GOTO   132
0931:  INCF   20,F
0932:  BCF    03.5
....................       } 
....................  
....................       uchar tailX = SNAKE[0][0], tailY = SNAKE[0][1]; 
0933:  MOVF   27,W
0934:  BSF    03.5
0935:  MOVWF  49
0936:  BCF    03.5
0937:  MOVF   28,W
0938:  BSF    03.5
0939:  MOVWF  4A
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
093A:  CLRF   48
093B:  MOVLW  01
093C:  SUBWF  7E,W
093D:  SUBWF  48,W
093E:  BTFSC  03.0
093F:  GOTO   176
....................          SNAKE[i][0] = SNAKE[i + 1][0]; 
0940:  BCF    03.0
0941:  RLF    48,W
0942:  ADDLW  27
0943:  MOVWF  4B
0944:  CLRF   4C
0945:  BTFSC  03.0
0946:  INCF   4C,F
0947:  MOVLW  01
0948:  ADDWF  48,W
0949:  MOVWF  77
094A:  BCF    03.0
094B:  RLF    77,F
094C:  MOVF   77,W
094D:  ADDLW  27
094E:  MOVWF  04
094F:  BCF    03.7
0950:  MOVF   00,W
0951:  MOVWF  4D
0952:  MOVF   4B,W
0953:  MOVWF  04
0954:  BCF    03.7
0955:  BTFSC  4C.0
0956:  BSF    03.7
0957:  MOVF   4D,W
0958:  MOVWF  00
....................          SNAKE[i][1] = SNAKE[i + 1][1]; 
0959:  BCF    03.0
095A:  RLF    48,W
095B:  ADDLW  01
095C:  ADDLW  27
095D:  MOVWF  4B
095E:  CLRF   4C
095F:  BTFSC  03.0
0960:  INCF   4C,F
0961:  MOVLW  01
0962:  ADDWF  48,W
0963:  MOVWF  77
0964:  BCF    03.0
0965:  RLF    77,F
0966:  MOVF   77,W
0967:  ADDLW  01
0968:  ADDLW  27
0969:  MOVWF  04
096A:  BCF    03.7
096B:  MOVF   00,W
096C:  MOVWF  4D
096D:  MOVF   4B,W
096E:  MOVWF  04
096F:  BCF    03.7
0970:  BTFSC  4C.0
0971:  BSF    03.7
0972:  MOVF   4D,W
0973:  MOVWF  00
0974:  INCF   48,F
0975:  GOTO   13B
....................       } 
....................       SNAKE[LENGTH_SNAKE - 1][0] = posX; 
0976:  MOVLW  01
0977:  SUBWF  7E,W
0978:  MOVWF  77
0979:  BCF    03.0
097A:  RLF    77,F
097B:  MOVF   77,W
097C:  ADDLW  27
097D:  MOVWF  04
097E:  BCF    03.7
097F:  MOVF   20,W
0980:  MOVWF  00
....................       SNAKE[LENGTH_SNAKE - 1][1] = posY; 
0981:  MOVLW  01
0982:  SUBWF  7E,W
0983:  MOVWF  77
0984:  BCF    03.0
0985:  RLF    77,F
0986:  MOVF   77,W
0987:  ADDLW  01
0988:  ADDLW  27
0989:  MOVWF  04
098A:  BCF    03.7
098B:  MOVF   21,W
098C:  MOVWF  00
....................  
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
098D:  CLRF   48
098E:  MOVLW  01
098F:  SUBWF  7E,W
0990:  SUBWF  48,W
0991:  BTFSC  03.0
0992:  GOTO   1AE
....................          if (SNAKE[i][0] == posX && SNAKE[i][1] == posY) { 
0993:  BCF    03.0
0994:  RLF    48,W
0995:  ADDLW  27
0996:  MOVWF  04
0997:  BCF    03.7
0998:  MOVF   20,W
0999:  SUBWF  00,W
099A:  BTFSS  03.2
099B:  GOTO   1AC
099C:  BCF    03.0
099D:  RLF    48,W
099E:  ADDLW  01
099F:  ADDLW  27
09A0:  MOVWF  04
09A1:  BCF    03.7
09A2:  MOVF   21,W
09A3:  SUBWF  00,W
09A4:  BTFSS  03.2
09A5:  GOTO   1AC
....................             gameover(); goto Start; 
09A6:  BCF    0A.3
09A7:  BCF    03.5
09A8:  CALL   70F
09A9:  BSF    0A.3
09AA:  BSF    03.5
09AB:  GOTO   072
....................          } 
09AC:  INCF   48,F
09AD:  GOTO   18E
....................       } 
....................  
....................       fillCell(posX, posY, 1); 
09AE:  MOVF   20,W
09AF:  MOVWF  4D
09B0:  MOVF   21,W
09B1:  MOVWF  4E
09B2:  MOVLW  01
09B3:  MOVWF  4F
09B4:  BCF    0A.3
09B5:  BCF    03.5
09B6:  CALL   68A
09B7:  BSF    0A.3
....................  
....................       // Kuyruu sil ama sadece byme yaplmyorsa 
....................       if (grow > 0) { 
09B8:  BSF    03.5
09B9:  MOVF   24,F
09BA:  BTFSC  03.2
09BB:  GOTO   1BE
....................          grow--; // uzad, bu admda kuyruk silme 
09BC:  DECF   24,F
....................       } else { 
09BD:  GOTO   1C8
....................          fillCell(tailX, tailY, 0); // kuyruk silinir 
09BE:  MOVF   49,W
09BF:  MOVWF  4D
09C0:  MOVF   4A,W
09C1:  MOVWF  4E
09C2:  CLRF   4F
09C3:  BCF    0A.3
09C4:  BCF    03.5
09C5:  CALL   68A
09C6:  BSF    0A.3
09C7:  BSF    03.5
....................       } 
....................  
....................       if (posX == food[0] && posY == food[1]) { 
09C8:  MOVF   7C,W
09C9:  SUBWF  20,W
09CA:  BTFSS  03.2
09CB:  GOTO   213
09CC:  MOVF   7D,W
09CD:  SUBWF  21,W
09CE:  BTFSS  03.2
09CF:  GOTO   213
....................          LENGTH_SNAKE++; 
09D0:  INCF   7E,F
....................          grow++;  // bir sonraki admda kuyruk silinmeyecek 
09D1:  INCF   24,F
....................          criar_comida(); 
09D2:  BCF    0A.3
09D3:  BCF    03.5
09D4:  CALL   6BE
09D5:  BSF    0A.3
....................          score++; 
09D6:  BSF    03.5
09D7:  INCF   22,F
....................          score_txt[7] = '0' + (score / 10); 
09D8:  MOVF   22,W
09D9:  MOVWF  4B
09DA:  MOVLW  0A
09DB:  MOVWF  4C
09DC:  BCF    0A.3
09DD:  BCF    03.5
09DE:  CALL   73A
09DF:  BSF    0A.3
09E0:  MOVF   78,W
09E1:  ADDLW  30
09E2:  BSF    03.5
09E3:  MOVWF  2C
....................          score_txt[8] = '0' + (score % 10); 
09E4:  MOVF   22,W
09E5:  MOVWF  4B
09E6:  MOVLW  0A
09E7:  MOVWF  4C
09E8:  BCF    0A.3
09E9:  BCF    03.5
09EA:  CALL   73A
09EB:  BSF    0A.3
09EC:  MOVF   77,W
09ED:  ADDLW  30
09EE:  BSF    03.5
09EF:  MOVWF  2D
....................  
....................          if (score > best_score) { 
09F0:  MOVF   22,W
09F1:  SUBWF  23,W
09F2:  BTFSC  03.0
09F3:  GOTO   20E
....................             best_score = score; 
09F4:  MOVF   22,W
09F5:  MOVWF  23
....................             best_score_txt[7] = '0' + (best_score / 10); 
09F6:  MOVF   23,W
09F7:  MOVWF  4B
09F8:  MOVLW  0A
09F9:  MOVWF  4C
09FA:  BCF    0A.3
09FB:  BCF    03.5
09FC:  CALL   73A
09FD:  BSF    0A.3
09FE:  MOVF   78,W
09FF:  ADDLW  30
0A00:  BSF    03.5
0A01:  MOVWF  37
....................             best_score_txt[8] = '0' + (best_score % 10); 
0A02:  MOVF   23,W
0A03:  MOVWF  4B
0A04:  MOVLW  0A
0A05:  MOVWF  4C
0A06:  BCF    0A.3
0A07:  BCF    03.5
0A08:  CALL   73A
0A09:  BSF    0A.3
0A0A:  MOVF   77,W
0A0B:  ADDLW  30
0A0C:  BSF    03.5
0A0D:  MOVWF  38
....................          } 
....................  
....................          writeScore(); 
0A0E:  BCF    0A.3
0A0F:  BCF    03.5
0A10:  CALL   5B4
0A11:  BSF    0A.3
0A12:  BSF    03.5
....................       } 
....................  
....................       delay_ms(600); 
0A13:  MOVLW  03
0A14:  MOVWF  4B
0A15:  MOVLW  C8
0A16:  MOVWF  4C
0A17:  BCF    0A.3
0A18:  BCF    03.5
0A19:  CALL   4C8
0A1A:  BSF    0A.3
0A1B:  BSF    03.5
0A1C:  DECFSZ 4B,F
0A1D:  GOTO   215
0A1E:  GOTO   0B6
....................    } 
.................... } 
....................  
0A1F:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
