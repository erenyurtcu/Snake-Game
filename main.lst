CCS PCM C Compiler, Version 5.025, 5967               01-Haz-25 23:36

               Filename:   C:\Users\Eren\Documents\CCS C Projects\snake_project\main.lst

               ROM used:   3969 words (48%)
                           Largest free fragment is 2048
               RAM used:   200 (54%) at main() level
                           269 (73%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   392
0003:  NOP
.................... #include <16F877A.h> // microcontroller definition for PIC16F877A 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDLW  0B
0008:  BTFSC  03.0
0009:  INCF   0A,F
000A:  MOVWF  02
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  5F
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  03
0017:  RETLW  00
0018:  RETLW  03
0019:  RETLW  00
001A:  RETLW  14
001B:  RETLW  3E
001C:  RETLW  14
001D:  RETLW  3E
001E:  RETLW  14
001F:  RETLW  24
0020:  RETLW  2A
0021:  RETLW  7F
0022:  RETLW  2A
0023:  RETLW  12
0024:  RETLW  43
0025:  RETLW  33
0026:  RETLW  08
0027:  RETLW  66
0028:  RETLW  61
0029:  RETLW  36
002A:  RETLW  49
002B:  RETLW  55
002C:  RETLW  22
002D:  RETLW  50
002E:  RETLW  00
002F:  RETLW  05
0030:  RETLW  03
0031:  RETLW  00
0032:  RETLW  00
0033:  RETLW  00
0034:  RETLW  1C
0035:  RETLW  22
0036:  RETLW  41
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  41
003A:  RETLW  22
003B:  RETLW  1C
003C:  RETLW  00
003D:  RETLW  14
003E:  RETLW  08
003F:  RETLW  3E
0040:  RETLW  08
0041:  RETLW  14
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  3E
0045:  RETLW  08
0046:  RETLW  08
0047:  RETLW  00
0048:  RETLW  50
0049:  RETLW  30
004A:  RETLW  00
004B:  RETLW  00
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  08
004F:  RETLW  08
0050:  RETLW  08
0051:  RETLW  00
0052:  RETLW  60
0053:  RETLW  60
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  20
0057:  RETLW  10
0058:  RETLW  08
0059:  RETLW  04
005A:  RETLW  02
005B:  RETLW  3E
005C:  RETLW  51
005D:  RETLW  49
005E:  RETLW  45
005F:  RETLW  3E
0060:  RETLW  04
0061:  RETLW  02
0062:  RETLW  7F
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  61
0067:  RETLW  51
0068:  RETLW  49
0069:  RETLW  46
006A:  RETLW  22
006B:  RETLW  41
006C:  RETLW  49
006D:  RETLW  49
006E:  RETLW  36
006F:  RETLW  18
0070:  RETLW  14
0071:  RETLW  12
0072:  RETLW  7F
0073:  RETLW  10
0074:  RETLW  27
0075:  RETLW  45
0076:  RETLW  45
0077:  RETLW  45
0078:  RETLW  39
0079:  RETLW  3E
007A:  RETLW  49
007B:  RETLW  49
007C:  RETLW  49
007D:  RETLW  32
007E:  RETLW  01
007F:  RETLW  01
0080:  RETLW  71
0081:  RETLW  09
0082:  RETLW  07
0083:  RETLW  36
0084:  RETLW  49
0085:  RETLW  49
0086:  RETLW  49
0087:  RETLW  36
0088:  RETLW  26
0089:  RETLW  49
008A:  RETLW  49
008B:  RETLW  49
008C:  RETLW  3E
008D:  RETLW  00
008E:  RETLW  36
008F:  RETLW  36
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  56
0094:  RETLW  36
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  08
0098:  RETLW  14
0099:  RETLW  22
009A:  RETLW  41
009B:  RETLW  00
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  14
009F:  RETLW  14
00A0:  RETLW  14
00A1:  RETLW  00
00A2:  RETLW  41
00A3:  RETLW  22
00A4:  RETLW  14
00A5:  RETLW  08
00A6:  RETLW  02
00A7:  RETLW  01
00A8:  RETLW  51
00A9:  RETLW  09
00AA:  RETLW  06
00AB:  RETLW  3E
00AC:  RETLW  41
00AD:  RETLW  59
00AE:  RETLW  55
00AF:  RETLW  5E
00B0:  RETLW  7E
00B1:  RETLW  09
00B2:  RETLW  09
00B3:  RETLW  09
00B4:  RETLW  7E
00B5:  RETLW  7F
00B6:  RETLW  49
00B7:  RETLW  49
00B8:  RETLW  49
00B9:  RETLW  36
00BA:  RETLW  3E
00BB:  RETLW  41
00BC:  RETLW  41
00BD:  RETLW  41
00BE:  RETLW  22
00BF:  RETLW  7F
00C0:  RETLW  41
00C1:  RETLW  41
00C2:  RETLW  41
00C3:  RETLW  3E
00C4:  RETLW  7F
00C5:  RETLW  49
00C6:  RETLW  49
00C7:  RETLW  49
00C8:  RETLW  41
00C9:  RETLW  7F
00CA:  RETLW  09
00CB:  RETLW  09
00CC:  RETLW  09
00CD:  RETLW  01
00CE:  RETLW  3E
00CF:  RETLW  41
00D0:  RETLW  41
00D1:  RETLW  49
00D2:  RETLW  3A
00D3:  RETLW  7F
00D4:  RETLW  08
00D5:  RETLW  08
00D6:  RETLW  08
00D7:  RETLW  7F
00D8:  RETLW  00
00D9:  RETLW  41
00DA:  RETLW  7F
00DB:  RETLW  41
00DC:  RETLW  00
00DD:  RETLW  30
00DE:  RETLW  40
00DF:  RETLW  40
00E0:  RETLW  40
00E1:  RETLW  3F
00E2:  RETLW  7F
00E3:  RETLW  08
00E4:  RETLW  14
00E5:  RETLW  22
00E6:  RETLW  41
00E7:  RETLW  7F
00E8:  RETLW  40
00E9:  RETLW  40
00EA:  RETLW  40
00EB:  RETLW  40
00EC:  RETLW  7F
00ED:  RETLW  02
00EE:  RETLW  0C
00EF:  RETLW  02
00F0:  RETLW  7F
00F1:  RETLW  7F
00F2:  RETLW  02
00F3:  RETLW  04
00F4:  RETLW  08
00F5:  RETLW  7F
00F6:  RETLW  3E
00F7:  RETLW  41
00F8:  RETLW  41
00F9:  RETLW  41
00FA:  RETLW  3E
00FB:  RETLW  7F
00FC:  RETLW  09
00FD:  RETLW  09
00FE:  RETLW  09
00FF:  RETLW  06
0100:  RETLW  1E
0101:  RETLW  21
0102:  RETLW  21
0103:  RETLW  21
0104:  RETLW  5E
0105:  RETLW  7F
0106:  RETLW  09
0107:  RETLW  09
0108:  RETLW  09
0109:  RETLW  76
010A:  BSF    0A.0
010B:  BCF    0A.1
010C:  BCF    0A.2
010D:  ADDWF  02,F
010E:  RETLW  26
010F:  RETLW  49
0110:  RETLW  49
0111:  RETLW  49
0112:  RETLW  32
0113:  RETLW  01
0114:  RETLW  01
0115:  RETLW  7F
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  3F
0119:  RETLW  40
011A:  RETLW  40
011B:  RETLW  40
011C:  RETLW  3F
011D:  RETLW  1F
011E:  RETLW  20
011F:  RETLW  40
0120:  RETLW  20
0121:  RETLW  1F
0122:  RETLW  7F
0123:  RETLW  20
0124:  RETLW  10
0125:  RETLW  20
0126:  RETLW  7F
0127:  RETLW  41
0128:  RETLW  22
0129:  RETLW  1C
012A:  RETLW  22
012B:  RETLW  41
012C:  RETLW  07
012D:  RETLW  08
012E:  RETLW  70
012F:  RETLW  08
0130:  RETLW  07
0131:  RETLW  61
0132:  RETLW  51
0133:  RETLW  49
0134:  RETLW  45
0135:  RETLW  43
0136:  RETLW  00
0137:  RETLW  7F
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  02
013C:  RETLW  04
013D:  RETLW  08
013E:  RETLW  10
013F:  RETLW  20
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  41
0143:  RETLW  7F
0144:  RETLW  00
0145:  RETLW  04
0146:  RETLW  02
0147:  RETLW  01
0148:  RETLW  02
0149:  RETLW  04
014A:  RETLW  40
014B:  RETLW  40
014C:  RETLW  40
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  00
0150:  RETLW  01
0151:  RETLW  02
0152:  RETLW  04
0153:  RETLW  00
0154:  RETLW  20
0155:  RETLW  54
0156:  RETLW  54
0157:  RETLW  54
0158:  RETLW  78
0159:  RETLW  7F
015A:  RETLW  44
015B:  RETLW  44
015C:  RETLW  44
015D:  RETLW  38
015E:  RETLW  38
015F:  RETLW  44
0160:  RETLW  44
0161:  RETLW  44
0162:  RETLW  44
0163:  RETLW  38
0164:  RETLW  44
0165:  RETLW  44
0166:  RETLW  44
0167:  RETLW  7F
0168:  RETLW  38
0169:  RETLW  54
016A:  RETLW  54
016B:  RETLW  54
016C:  RETLW  18
016D:  RETLW  04
016E:  RETLW  04
016F:  RETLW  7E
0170:  RETLW  05
0171:  RETLW  05
0172:  RETLW  08
0173:  RETLW  54
0174:  RETLW  54
0175:  RETLW  54
0176:  RETLW  3C
0177:  RETLW  7F
0178:  RETLW  08
0179:  RETLW  04
017A:  RETLW  04
017B:  RETLW  78
017C:  RETLW  00
017D:  RETLW  44
017E:  RETLW  7D
017F:  RETLW  40
0180:  RETLW  00
0181:  RETLW  20
0182:  RETLW  40
0183:  RETLW  44
0184:  RETLW  3D
0185:  RETLW  00
0186:  RETLW  7F
0187:  RETLW  10
0188:  RETLW  28
0189:  RETLW  44
018A:  RETLW  00
018B:  RETLW  00
018C:  RETLW  41
018D:  RETLW  7F
018E:  RETLW  40
018F:  RETLW  00
0190:  RETLW  7C
0191:  RETLW  04
0192:  RETLW  78
0193:  RETLW  04
0194:  RETLW  78
0195:  RETLW  7C
0196:  RETLW  08
0197:  RETLW  04
0198:  RETLW  04
0199:  RETLW  78
019A:  RETLW  38
019B:  RETLW  44
019C:  RETLW  44
019D:  RETLW  44
019E:  RETLW  38
019F:  RETLW  7C
01A0:  RETLW  14
01A1:  RETLW  14
01A2:  RETLW  14
01A3:  RETLW  08
01A4:  RETLW  08
01A5:  RETLW  14
01A6:  RETLW  14
01A7:  RETLW  14
01A8:  RETLW  7C
01A9:  RETLW  00
01AA:  RETLW  7C
01AB:  RETLW  08
01AC:  RETLW  04
01AD:  RETLW  04
01AE:  RETLW  48
01AF:  RETLW  54
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  20
01B3:  RETLW  04
01B4:  RETLW  04
01B5:  RETLW  3F
01B6:  RETLW  44
01B7:  RETLW  44
01B8:  RETLW  3C
01B9:  RETLW  40
01BA:  RETLW  40
01BB:  RETLW  20
01BC:  RETLW  7C
01BD:  RETLW  1C
01BE:  RETLW  20
01BF:  RETLW  40
01C0:  RETLW  20
01C1:  RETLW  1C
01C2:  RETLW  3C
01C3:  RETLW  40
01C4:  RETLW  30
01C5:  RETLW  40
01C6:  RETLW  3C
01C7:  RETLW  44
01C8:  RETLW  28
01C9:  RETLW  10
01CA:  RETLW  28
01CB:  RETLW  44
01CC:  RETLW  0C
01CD:  RETLW  50
01CE:  RETLW  50
01CF:  RETLW  50
01D0:  RETLW  3C
01D1:  RETLW  44
01D2:  RETLW  64
01D3:  RETLW  54
01D4:  RETLW  4C
01D5:  RETLW  44
01D6:  RETLW  00
01D7:  RETLW  08
01D8:  RETLW  36
01D9:  RETLW  41
01DA:  RETLW  41
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  7F
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  41
01E1:  RETLW  41
01E2:  RETLW  36
01E3:  RETLW  08
01E4:  RETLW  00
01E5:  RETLW  02
01E6:  RETLW  01
01E7:  RETLW  02
01E8:  RETLW  04
01E9:  RETLW  02
01EA:  BSF    0A.0
01EB:  BCF    0A.1
01EC:  BCF    0A.2
01ED:  ADDWF  02,F
01EE:  RETLW  3C
01EF:  RETLW  20
01F0:  RETLW  45
01F1:  RETLW  41
01F2:  RETLW  53
01F3:  RETLW  59
01F4:  RETLW  20
01F5:  RETLW  3E
01F6:  RETLW  00
01F7:  BSF    0A.0
01F8:  BCF    0A.1
01F9:  BCF    0A.2
01FA:  ADDLW  FE
01FB:  BTFSC  03.0
01FC:  INCF   0A,F
01FD:  MOVWF  02
01FE:  RETLW  3C
01FF:  RETLW  20
0200:  RETLW  4D
0201:  RETLW  45
0202:  RETLW  44
0203:  RETLW  49
0204:  RETLW  55
0205:  RETLW  4D
0206:  RETLW  20
0207:  RETLW  3E
0208:  RETLW  00
0209:  BCF    0A.0
020A:  BSF    0A.1
020B:  BCF    0A.2
020C:  ADDWF  02,F
020D:  RETLW  3C
020E:  RETLW  20
020F:  RETLW  48
0210:  RETLW  41
0211:  RETLW  52
0212:  RETLW  44
0213:  RETLW  20
0214:  RETLW  3E
0215:  RETLW  00
*
0248:  CLRF   77
0249:  CLRF   78
024A:  BSF    03.5
024B:  BSF    03.6
024C:  MOVF   12,W
024D:  BCF    03.0
024E:  BTFSC  13.0
024F:  ADDWF  77,F
0250:  RRF    77,F
0251:  RRF    78,F
0252:  BTFSC  13.1
0253:  ADDWF  77,F
0254:  RRF    77,F
0255:  RRF    78,F
0256:  BTFSC  13.2
0257:  ADDWF  77,F
0258:  RRF    77,F
0259:  RRF    78,F
025A:  BTFSC  13.3
025B:  ADDWF  77,F
025C:  RRF    77,F
025D:  RRF    78,F
025E:  BTFSC  13.4
025F:  ADDWF  77,F
0260:  RRF    77,F
0261:  RRF    78,F
0262:  BTFSC  13.5
0263:  ADDWF  77,F
0264:  RRF    77,F
0265:  RRF    78,F
0266:  BTFSC  13.6
0267:  ADDWF  77,F
0268:  RRF    77,F
0269:  RRF    78,F
026A:  BTFSC  13.7
026B:  ADDWF  77,F
026C:  RRF    77,F
026D:  RRF    78,F
026E:  BCF    03.5
026F:  BCF    03.6
0270:  RETURN
*
064B:  MOVLW  10
064C:  BSF    03.6
064D:  MOVWF  56
064E:  CLRF   77
064F:  CLRF   7A
0650:  RRF    53,F
0651:  RRF    52,F
0652:  BTFSS  03.0
0653:  GOTO   65A
0654:  MOVF   54,W
0655:  ADDWF  77,F
0656:  BTFSC  03.0
0657:  INCF   7A,F
0658:  MOVF   55,W
0659:  ADDWF  7A,F
065A:  RRF    7A,F
065B:  RRF    77,F
065C:  RRF    79,F
065D:  RRF    78,F
065E:  DECFSZ 56,F
065F:  GOTO   650
0660:  BCF    03.6
0661:  RETURN
0662:  CLRF   78
0663:  CLRF   79
0664:  CLRF   77
0665:  CLRF   7A
0666:  BSF    03.6
0667:  MOVF   57,W
0668:  BTFSS  03.2
0669:  GOTO   66D
066A:  MOVF   56,W
066B:  BTFSC  03.2
066C:  GOTO   687
066D:  MOVLW  10
066E:  MOVWF  58
066F:  BCF    03.0
0670:  RLF    54,F
0671:  RLF    55,F
0672:  RLF    77,F
0673:  RLF    7A,F
0674:  MOVF   57,W
0675:  SUBWF  7A,W
0676:  BTFSS  03.2
0677:  GOTO   67A
0678:  MOVF   56,W
0679:  SUBWF  77,W
067A:  BTFSS  03.0
067B:  GOTO   683
067C:  MOVF   56,W
067D:  SUBWF  77,F
067E:  BTFSS  03.0
067F:  DECF   7A,F
0680:  MOVF   57,W
0681:  SUBWF  7A,F
0682:  BSF    03.0
0683:  RLF    78,F
0684:  RLF    79,F
0685:  DECFSZ 58,F
0686:  GOTO   66F
0687:  BCF    03.6
0688:  RETURN
*
0977:  MOVLW  20
0978:  MOVWF  43
0979:  CLRF   3F
097A:  CLRF   40
097B:  CLRF   41
097C:  CLRF   42
097D:  MOVF   3A,W
097E:  MOVWF  7A
097F:  MOVF   39,W
0980:  MOVWF  79
0981:  MOVF   38,W
0982:  MOVWF  78
0983:  MOVF   37,W
0984:  MOVWF  77
0985:  BCF    03.0
0986:  BTFSS  77.0
0987:  GOTO   196
0988:  MOVF   3B,W
0989:  ADDWF  3F,F
098A:  MOVF   3C,W
098B:  BTFSC  03.0
098C:  INCFSZ 3C,W
098D:  ADDWF  40,F
098E:  MOVF   3D,W
098F:  BTFSC  03.0
0990:  INCFSZ 3D,W
0991:  ADDWF  41,F
0992:  MOVF   3E,W
0993:  BTFSC  03.0
0994:  INCFSZ 3E,W
0995:  ADDWF  42,F
0996:  RRF    42,F
0997:  RRF    41,F
0998:  RRF    40,F
0999:  RRF    3F,F
099A:  RRF    7A,F
099B:  RRF    79,F
099C:  RRF    78,F
099D:  RRF    77,F
099E:  DECFSZ 43,F
099F:  GOTO   185
*
0B7B:  BSF    03.6
0B7C:  MOVF   36,W
0B7D:  CLRF   78
0B7E:  SUBWF  35,W
0B7F:  BTFSC  03.0
0B80:  GOTO   384
0B81:  MOVF   35,W
0B82:  MOVWF  77
0B83:  GOTO   390
0B84:  CLRF   77
0B85:  MOVLW  08
0B86:  MOVWF  37
0B87:  RLF    35,F
0B88:  RLF    77,F
0B89:  MOVF   36,W
0B8A:  SUBWF  77,W
0B8B:  BTFSC  03.0
0B8C:  MOVWF  77
0B8D:  RLF    78,F
0B8E:  DECFSZ 37,F
0B8F:  GOTO   387
0B90:  BCF    03.6
0B91:  RETURN
*
0F8B:  BSF    0A.0
0F8C:  BSF    0A.1
0F8D:  BSF    0A.2
0F8E:  ADDWF  02,F
0F8F:  GOTO   4D9
0F90:  GOTO   4E5
0F91:  GOTO   4F1
0F92:  GOTO   4FE
....................  
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP // high speed oscillator, no reset, no code protection, no low-voltage programming 
.................... #use delay(clock=16000000) // sets clock frequency to 16 MHz 
*
0364:  MOVLW  52
0365:  MOVWF  04
0366:  BSF    03.7
0367:  MOVF   00,W
0368:  BTFSC  03.2
0369:  GOTO   378
036A:  MOVLW  05
036B:  MOVWF  78
036C:  CLRF   77
036D:  DECFSZ 77,F
036E:  GOTO   36D
036F:  DECFSZ 78,F
0370:  GOTO   36C
0371:  MOVLW  2E
0372:  MOVWF  77
0373:  DECFSZ 77,F
0374:  GOTO   373
0375:  GOTO   376
0376:  DECFSZ 00,F
0377:  GOTO   36A
0378:  RETURN
.................... #include <stdlib.h> // standard library for random number functions (rand()) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0BAA:  BCF    03.5
0BAB:  CLRF   20
0BAC:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0610:  MOVF   5E,W
0611:  MOVWF  60
0612:  MOVF   5D,W
0613:  MOVWF  5F
0614:  MOVF   60,W
0615:  MOVWF  7A
0616:  MOVF   5F,W
0617:  MOVWF  04
0618:  BCF    03.7
0619:  BTFSC  7A.0
061A:  BSF    03.7
061B:  MOVF   00,F
061C:  BTFSC  03.2
061D:  GOTO   622
061E:  INCF   5F,F
061F:  BTFSC  03.2
0620:  INCF   60,F
0621:  GOTO   614
....................    return(sc - s); 
0622:  MOVF   5D,W
0623:  SUBWF  5F,W
0624:  MOVWF  77
0625:  MOVF   60,W
0626:  MOVWF  7A
0627:  MOVF   5E,W
0628:  BTFSS  03.0
0629:  INCFSZ 5E,W
062A:  SUBWF  7A,F
062B:  MOVF   77,W
062C:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
0960:  MOVF   25,W
0961:  BSF    03.6
0962:  MOVWF  3A
0963:  BCF    03.6
0964:  MOVF   24,W
0965:  BSF    03.6
0966:  MOVWF  39
0967:  BCF    03.6
0968:  MOVF   23,W
0969:  BSF    03.6
096A:  MOVWF  38
096B:  BCF    03.6
096C:  MOVF   22,W
096D:  BSF    03.6
096E:  MOVWF  37
096F:  MOVLW  41
0970:  MOVWF  3E
0971:  MOVLW  C6
0972:  MOVWF  3D
0973:  MOVLW  4E
0974:  MOVWF  3C
0975:  MOVLW  6D
0976:  MOVWF  3B
*
09A0:  MOVF   7A,W
09A1:  MOVWF  3A
09A2:  MOVF   79,W
09A3:  MOVWF  39
09A4:  MOVF   78,W
09A5:  MOVWF  38
09A6:  MOVF   77,W
09A7:  MOVWF  37
09A8:  MOVLW  39
09A9:  ADDWF  37,W
09AA:  BCF    03.6
09AB:  MOVWF  22
09AC:  BSF    03.6
09AD:  MOVF   38,W
09AE:  BCF    03.6
09AF:  MOVWF  23
09B0:  MOVLW  30
09B1:  BTFSC  03.0
09B2:  MOVLW  31
09B3:  ADDWF  23,F
09B4:  BSF    03.6
09B5:  MOVF   39,W
09B6:  BCF    03.6
09B7:  MOVWF  24
09B8:  MOVLW  00
09B9:  BTFSC  03.0
09BA:  MOVLW  01
09BB:  ADDWF  24,F
09BC:  BSF    03.6
09BD:  MOVF   3A,W
09BE:  BCF    03.6
09BF:  MOVWF  25
09C0:  MOVLW  00
09C1:  BTFSC  03.0
09C2:  MOVLW  01
09C3:  ADDWF  25,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
09C4:  MOVF   24,W
09C5:  MOVWF  77
09C6:  MOVF   25,W
09C7:  MOVWF  78
09C8:  CLRF   79
09C9:  CLRF   7A
09CA:  MOVF   25,W
09CB:  BSF    03.6
09CC:  MOVWF  39
09CD:  MOVF   77,W
09CE:  MOVWF  38
09CF:  MOVF   39,W
09D0:  MOVWF  55
09D1:  MOVF   38,W
09D2:  MOVWF  54
09D3:  MOVLW  7F
09D4:  MOVWF  57
09D5:  MOVLW  FF
09D6:  MOVWF  56
09D7:  BCF    0A.3
09D8:  BCF    03.6
09D9:  CALL   662
09DA:  BSF    0A.3
09DB:  MOVF   77,W
09DC:  MOVWF  78
09DD:  MOVF   7A,W
09DE:  MOVWF  79
09DF:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <glcd.c> // glcd driver for graphics operations 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
02EA:  BCF    26.0
02EB:  MOVF   26,W
02EC:  BSF    03.5
02ED:  MOVWF  07
02EE:  BCF    03.5
02EF:  BSF    07.0
....................    output_low(GLCD_E); 
02F0:  BSF    03.5
02F1:  BCF    06.5
02F2:  BCF    03.5
02F3:  BCF    06.5
....................    output_low(GLCD_CS1); 
02F4:  BSF    03.5
02F5:  BCF    06.0
02F6:  BCF    03.5
02F7:  BCF    06.0
....................    output_low(GLCD_CS2); 
02F8:  BSF    03.5
02F9:  BCF    06.1
02FA:  BCF    03.5
02FB:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
02FC:  BSF    03.5
02FD:  BCF    06.2
02FE:  BCF    03.5
02FF:  BCF    06.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
0300:  MOVLW  30
0301:  BSF    03.5
0302:  BSF    03.6
0303:  MOVWF  18
0304:  MOVLW  C0
0305:  MOVWF  19
0306:  BCF    03.5
0307:  BCF    03.6
0308:  CALL   216
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
0309:  MOVLW  31
030A:  BSF    03.5
030B:  BSF    03.6
030C:  MOVWF  18
030D:  MOVLW  C0
030E:  MOVWF  19
030F:  BCF    03.5
0310:  BCF    03.6
0311:  CALL   216
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
0312:  MOVLW  30
0313:  BSF    03.5
0314:  BSF    03.6
0315:  MOVWF  18
0316:  MOVLW  40
0317:  MOVWF  19
0318:  BCF    03.5
0319:  BCF    03.6
031A:  CALL   216
....................    glcd_writeByte(GLCD_CS2, 0x40); 
031B:  MOVLW  31
031C:  BSF    03.5
031D:  BSF    03.6
031E:  MOVWF  18
031F:  MOVLW  40
0320:  MOVWF  19
0321:  BCF    03.5
0322:  BCF    03.6
0323:  CALL   216
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
0324:  MOVLW  30
0325:  BSF    03.5
0326:  BSF    03.6
0327:  MOVWF  18
0328:  MOVLW  B8
0329:  MOVWF  19
032A:  BCF    03.5
032B:  BCF    03.6
032C:  CALL   216
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
032D:  MOVLW  31
032E:  BSF    03.5
032F:  BSF    03.6
0330:  MOVWF  18
0331:  MOVLW  B8
0332:  MOVWF  19
0333:  BCF    03.5
0334:  BCF    03.6
0335:  CALL   216
....................    if(mode == ON) 
0336:  BSF    03.6
0337:  DECFSZ 35,W
0338:  GOTO   34C
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
0339:  MOVLW  30
033A:  BSF    03.5
033B:  MOVWF  18
033C:  MOVLW  3F
033D:  MOVWF  19
033E:  BCF    03.5
033F:  BCF    03.6
0340:  CALL   216
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
0341:  MOVLW  31
0342:  BSF    03.5
0343:  BSF    03.6
0344:  MOVWF  18
0345:  MOVLW  3F
0346:  MOVWF  19
0347:  BCF    03.5
0348:  BCF    03.6
0349:  CALL   216
....................    } 
034A:  GOTO   35D
034B:  BSF    03.6
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
034C:  MOVLW  30
034D:  BSF    03.5
034E:  MOVWF  18
034F:  MOVLW  3E
0350:  MOVWF  19
0351:  BCF    03.5
0352:  BCF    03.6
0353:  CALL   216
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
0354:  MOVLW  31
0355:  BSF    03.5
0356:  BSF    03.6
0357:  MOVWF  18
0358:  MOVLW  3E
0359:  MOVWF  19
035A:  BCF    03.5
035B:  BCF    03.6
035C:  CALL   216
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
035D:  BSF    03.6
035E:  CLRF   49
035F:  BCF    03.6
0360:  CALL   271
0361:  BSF    0A.3
0362:  BCF    0A.4
0363:  GOTO   405 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
*
0379:  MOVLW  30
037A:  BSF    03.5
037B:  BSF    03.6
037C:  MOVWF  16
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
037D:  MOVF   12,W
037E:  SUBLW  3F
037F:  BTFSC  03.0
0380:  GOTO   385
....................    { 
....................       x -= 64; 
0381:  MOVLW  40
0382:  SUBWF  12,F
....................       chip = GLCD_CS2; 
0383:  MOVLW  31
0384:  MOVWF  16
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
0385:  BCF    03.6
0386:  BCF    06.2
0387:  BCF    03.5
0388:  BCF    06.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
0389:  BSF    03.5
038A:  BSF    03.6
038B:  BCF    12.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
038C:  BSF    12.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
038D:  MOVF   16,W
038E:  MOVWF  18
038F:  MOVF   12,W
0390:  MOVWF  19
0391:  BCF    03.5
0392:  BCF    03.6
0393:  CALL   216
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
0394:  BSF    03.5
0395:  BSF    03.6
0396:  RRF    13,W
0397:  MOVWF  77
0398:  RRF    77,F
0399:  RRF    77,F
039A:  MOVLW  1F
039B:  ANDWF  77,F
039C:  MOVF   77,W
039D:  ANDLW  BF
039E:  IORLW  B8
039F:  MOVWF  17
03A0:  MOVF   16,W
03A1:  MOVWF  18
03A2:  MOVF   17,W
03A3:  MOVWF  19
03A4:  BCF    03.5
03A5:  BCF    03.6
03A6:  CALL   216
....................    output_high(GLCD_DI);                                    // Set for data 
03A7:  BSF    03.5
03A8:  BCF    06.2
03A9:  BCF    03.5
03AA:  BSF    06.2
....................    data = glcd_readByte(chip); 
03AB:  BSF    03.5
03AC:  BSF    03.6
03AD:  MOVF   16,W
03AE:  MOVWF  17
*
03F7:  MOVF   78,W
03F8:  MOVWF  15
....................  
....................    if(color == ON) 
03F9:  DECFSZ 14,W
03FA:  GOTO   40B
....................       bit_set(data, y%8);        // Turn the pixel on 
03FB:  MOVF   13,W
03FC:  ANDLW  07
03FD:  MOVWF  17
03FE:  MOVLW  01
03FF:  MOVWF  77
0400:  MOVF   17,W
0401:  MOVWF  78
0402:  BTFSC  03.2
0403:  GOTO   408
0404:  BCF    03.0
0405:  RLF    77,F
0406:  DECFSZ 78,F
0407:  GOTO   404
0408:  MOVF   77,W
0409:  IORWF  15,F
040A:  GOTO   41B
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
040B:  MOVF   13,W
040C:  ANDLW  07
040D:  MOVWF  17
040E:  MOVLW  01
040F:  MOVWF  77
0410:  MOVF   17,W
0411:  MOVWF  78
0412:  BTFSC  03.2
0413:  GOTO   418
0414:  BCF    03.0
0415:  RLF    77,F
0416:  DECFSZ 78,F
0417:  GOTO   414
0418:  MOVF   77,W
0419:  XORLW  FF
041A:  ANDWF  15,F
....................    output_low(GLCD_DI);          // Set for instruction 
041B:  BCF    03.6
041C:  BCF    06.2
041D:  BCF    03.5
041E:  BCF    06.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
041F:  BSF    03.5
0420:  BSF    03.6
0421:  MOVF   16,W
0422:  MOVWF  18
0423:  MOVF   12,W
0424:  MOVWF  19
0425:  BCF    03.5
0426:  BCF    03.6
0427:  CALL   216
....................    output_high(GLCD_DI);         // Set for data 
0428:  BSF    03.5
0429:  BCF    06.2
042A:  BCF    03.5
042B:  BSF    06.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
042C:  BSF    03.5
042D:  BSF    03.6
042E:  MOVF   16,W
042F:  MOVWF  18
0430:  MOVF   15,W
0431:  MOVWF  19
0432:  BCF    03.5
0433:  BCF    03.6
0434:  CALL   216
0435:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
*
0800:  BSF    03.6
0801:  MOVF   39,W
0802:  SUBWF  3B,W
0803:  MOVWF  47
0804:  MOVF   47,W
0805:  BTFSS  47.7
0806:  GOTO   009
0807:  MOVF   47,W
0808:  SUBLW  00
0809:  MOVWF  42
....................    dy = abs((signed int)(y2 - y1)); 
080A:  MOVF   3A,W
080B:  SUBWF  3C,W
080C:  MOVWF  47
080D:  MOVF   47,W
080E:  BTFSS  47.7
080F:  GOTO   012
0810:  MOVF   47,W
0811:  SUBLW  00
0812:  MOVWF  43
....................    x = x1; 
0813:  MOVF   39,W
0814:  MOVWF  3E
....................    y = y1; 
0815:  MOVF   3A,W
0816:  MOVWF  3F
....................  
....................    if(x1 > x2) 
0817:  MOVF   39,W
0818:  SUBWF  3B,W
0819:  BTFSC  03.0
081A:  GOTO   01E
....................       addx = -1; 
081B:  MOVLW  FF
081C:  MOVWF  40
081D:  GOTO   020
....................    else 
....................       addx = 1; 
081E:  MOVLW  01
081F:  MOVWF  40
....................    if(y1 > y2) 
0820:  MOVF   3A,W
0821:  SUBWF  3C,W
0822:  BTFSC  03.0
0823:  GOTO   027
....................       addy = -1; 
0824:  MOVLW  FF
0825:  MOVWF  41
0826:  GOTO   029
....................    else 
....................       addy = 1; 
0827:  MOVLW  01
0828:  MOVWF  41
....................  
....................    if(dx >= dy) 
0829:  MOVF   43,W
082A:  XORLW  80
082B:  MOVWF  77
082C:  MOVF   42,W
082D:  XORLW  80
082E:  SUBWF  77,W
082F:  BTFSC  03.2
0830:  GOTO   033
0831:  BTFSC  03.0
0832:  GOTO   0AB
....................    { 
....................       P = 2*dy - dx; 
0833:  MOVLW  02
0834:  BSF    03.5
0835:  MOVWF  12
0836:  BCF    03.5
0837:  MOVF   43,W
0838:  BSF    03.5
0839:  MOVWF  13
083A:  BCF    0A.3
083B:  BCF    03.5
083C:  BCF    03.6
083D:  CALL   248
083E:  BSF    0A.3
083F:  BSF    03.6
0840:  MOVF   42,W
0841:  SUBWF  78,W
0842:  CLRF   7A
0843:  MOVWF  77
0844:  BTFSC  77.7
0845:  DECF   7A,F
0846:  MOVWF  44
0847:  MOVF   7A,W
0848:  MOVWF  45
....................  
....................       for(i=0; i<=dx; ++i) 
0849:  CLRF   46
084A:  BTFSC  42.7
084B:  GOTO   0AA
084C:  MOVF   46,W
084D:  SUBWF  42,W
084E:  BTFSS  03.0
084F:  GOTO   0AA
....................       { 
....................          glcd_pixel(x, y, color); 
0850:  MOVF   3E,W
0851:  BSF    03.5
0852:  MOVWF  12
0853:  BCF    03.5
0854:  MOVF   3F,W
0855:  BSF    03.5
0856:  MOVWF  13
0857:  BCF    03.5
0858:  MOVF   3D,W
0859:  BSF    03.5
085A:  MOVWF  14
085B:  BCF    0A.3
085C:  BCF    03.5
085D:  BCF    03.6
085E:  CALL   379
085F:  BSF    0A.3
....................  
....................          if(P < 0) 
0860:  BSF    03.6
0861:  BTFSS  45.7
0862:  GOTO   07D
....................          { 
....................             P += 2*dy; 
0863:  MOVLW  02
0864:  BSF    03.5
0865:  MOVWF  12
0866:  BCF    03.5
0867:  MOVF   43,W
0868:  BSF    03.5
0869:  MOVWF  13
086A:  BCF    0A.3
086B:  BCF    03.5
086C:  BCF    03.6
086D:  CALL   248
086E:  BSF    0A.3
086F:  MOVF   78,W
0870:  CLRF   7A
0871:  MOVWF  77
0872:  BTFSC  77.7
0873:  DECF   7A,F
0874:  BSF    03.6
0875:  ADDWF  44,F
0876:  MOVF   7A,W
0877:  BTFSC  03.0
0878:  INCFSZ 7A,W
0879:  ADDWF  45,F
....................             x += addx; 
087A:  MOVF   40,W
087B:  ADDWF  3E,F
....................          } 
087C:  GOTO   0A8
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
087D:  MOVLW  02
087E:  BSF    03.5
087F:  MOVWF  12
0880:  BCF    03.5
0881:  MOVF   43,W
0882:  BSF    03.5
0883:  MOVWF  13
0884:  BCF    0A.3
0885:  BCF    03.5
0886:  BCF    03.6
0887:  CALL   248
0888:  BSF    0A.3
0889:  MOVF   78,W
088A:  BSF    03.6
088B:  MOVWF  47
088C:  MOVLW  02
088D:  BSF    03.5
088E:  MOVWF  12
088F:  BCF    03.5
0890:  MOVF   42,W
0891:  BSF    03.5
0892:  MOVWF  13
0893:  BCF    0A.3
0894:  BCF    03.5
0895:  BCF    03.6
0896:  CALL   248
0897:  BSF    0A.3
0898:  MOVF   78,W
0899:  BSF    03.6
089A:  SUBWF  47,W
089B:  CLRF   7A
089C:  MOVWF  77
089D:  BTFSC  77.7
089E:  DECF   7A,F
089F:  ADDWF  44,F
08A0:  MOVF   7A,W
08A1:  BTFSC  03.0
08A2:  INCFSZ 7A,W
08A3:  ADDWF  45,F
....................             x += addx; 
08A4:  MOVF   40,W
08A5:  ADDWF  3E,F
....................             y += addy; 
08A6:  MOVF   41,W
08A7:  ADDWF  3F,F
....................          } 
08A8:  INCF   46,F
08A9:  GOTO   04A
....................       } 
....................    } 
08AA:  GOTO   122
....................    else 
....................    { 
....................       P = 2*dx - dy; 
08AB:  MOVLW  02
08AC:  BSF    03.5
08AD:  MOVWF  12
08AE:  BCF    03.5
08AF:  MOVF   42,W
08B0:  BSF    03.5
08B1:  MOVWF  13
08B2:  BCF    0A.3
08B3:  BCF    03.5
08B4:  BCF    03.6
08B5:  CALL   248
08B6:  BSF    0A.3
08B7:  BSF    03.6
08B8:  MOVF   43,W
08B9:  SUBWF  78,W
08BA:  CLRF   7A
08BB:  MOVWF  77
08BC:  BTFSC  77.7
08BD:  DECF   7A,F
08BE:  MOVWF  44
08BF:  MOVF   7A,W
08C0:  MOVWF  45
....................  
....................       for(i=0; i<=dy; ++i) 
08C1:  CLRF   46
08C2:  BTFSC  43.7
08C3:  GOTO   122
08C4:  MOVF   46,W
08C5:  SUBWF  43,W
08C6:  BTFSS  03.0
08C7:  GOTO   122
....................       { 
....................          glcd_pixel(x, y, color); 
08C8:  MOVF   3E,W
08C9:  BSF    03.5
08CA:  MOVWF  12
08CB:  BCF    03.5
08CC:  MOVF   3F,W
08CD:  BSF    03.5
08CE:  MOVWF  13
08CF:  BCF    03.5
08D0:  MOVF   3D,W
08D1:  BSF    03.5
08D2:  MOVWF  14
08D3:  BCF    0A.3
08D4:  BCF    03.5
08D5:  BCF    03.6
08D6:  CALL   379
08D7:  BSF    0A.3
....................  
....................          if(P < 0) 
08D8:  BSF    03.6
08D9:  BTFSS  45.7
08DA:  GOTO   0F5
....................          { 
....................             P += 2*dx; 
08DB:  MOVLW  02
08DC:  BSF    03.5
08DD:  MOVWF  12
08DE:  BCF    03.5
08DF:  MOVF   42,W
08E0:  BSF    03.5
08E1:  MOVWF  13
08E2:  BCF    0A.3
08E3:  BCF    03.5
08E4:  BCF    03.6
08E5:  CALL   248
08E6:  BSF    0A.3
08E7:  MOVF   78,W
08E8:  CLRF   7A
08E9:  MOVWF  77
08EA:  BTFSC  77.7
08EB:  DECF   7A,F
08EC:  BSF    03.6
08ED:  ADDWF  44,F
08EE:  MOVF   7A,W
08EF:  BTFSC  03.0
08F0:  INCFSZ 7A,W
08F1:  ADDWF  45,F
....................             y += addy; 
08F2:  MOVF   41,W
08F3:  ADDWF  3F,F
....................          } 
08F4:  GOTO   120
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
08F5:  MOVLW  02
08F6:  BSF    03.5
08F7:  MOVWF  12
08F8:  BCF    03.5
08F9:  MOVF   42,W
08FA:  BSF    03.5
08FB:  MOVWF  13
08FC:  BCF    0A.3
08FD:  BCF    03.5
08FE:  BCF    03.6
08FF:  CALL   248
0900:  BSF    0A.3
0901:  MOVF   78,W
0902:  BSF    03.6
0903:  MOVWF  47
0904:  MOVLW  02
0905:  BSF    03.5
0906:  MOVWF  12
0907:  BCF    03.5
0908:  MOVF   43,W
0909:  BSF    03.5
090A:  MOVWF  13
090B:  BCF    0A.3
090C:  BCF    03.5
090D:  BCF    03.6
090E:  CALL   248
090F:  BSF    0A.3
0910:  MOVF   78,W
0911:  BSF    03.6
0912:  SUBWF  47,W
0913:  CLRF   7A
0914:  MOVWF  77
0915:  BTFSC  77.7
0916:  DECF   7A,F
0917:  ADDWF  44,F
0918:  MOVF   7A,W
0919:  BTFSC  03.0
091A:  INCFSZ 7A,W
091B:  ADDWF  45,F
....................             x += addx; 
091C:  MOVF   40,W
091D:  ADDWF  3E,F
....................             y += addy; 
091E:  MOVF   41,W
091F:  ADDWF  3F,F
....................          } 
0920:  INCF   46,F
0921:  GOTO   0C2
....................       } 
....................    } 
0922:  BCF    03.6
0923:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
*
0436:  BSF    03.6
0437:  CLRF   63
0438:  MOVF   63,W
0439:  ADDWF  5F,W
043A:  MOVWF  04
043B:  BCF    03.7
043C:  BTFSC  60.0
043D:  BSF    03.7
043E:  MOVF   00,F
043F:  BTFSC  03.2
0440:  GOTO   52D
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
0441:  MOVF   63,W
0442:  ADDWF  5F,W
0443:  MOVWF  04
0444:  BCF    03.7
0445:  BTFSC  60.0
0446:  BSF    03.7
0447:  MOVF   00,W
0448:  SUBLW  52
0449:  BTFSS  03.0
044A:  GOTO   474
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
044B:  MOVF   63,W
044C:  ADDWF  5F,W
044D:  MOVWF  04
044E:  BCF    03.7
044F:  BTFSC  60.0
0450:  BSF    03.7
0451:  MOVLW  20
0452:  SUBWF  00,W
0453:  BSF    03.5
0454:  MOVWF  11
0455:  MOVWF  12
0456:  MOVLW  05
0457:  MOVWF  13
0458:  BCF    03.5
0459:  BCF    03.6
045A:  CALL   248
045B:  MOVF   78,W
045C:  BSF    03.5
045D:  BSF    03.6
045E:  MOVWF  10
045F:  MOVWF  78
0460:  MOVLW  05
0461:  MOVWF  77
0462:  MOVLW  68
0463:  MOVWF  04
0464:  BSF    03.7
0465:  MOVF   78,W
0466:  BCF    03.5
0467:  BCF    03.6
0468:  CALL   004
0469:  MOVWF  00
046A:  INCF   78,F
046B:  INCF   04,F
046C:  DECFSZ 77,F
046D:  GOTO   46F
046E:  GOTO   472
046F:  BSF    03.5
0470:  BSF    03.6
0471:  GOTO   465
0472:  GOTO   4AD
0473:  BSF    03.6
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
0474:  MOVF   63,W
0475:  ADDWF  5F,W
0476:  MOVWF  04
0477:  BCF    03.7
0478:  BTFSC  60.0
0479:  BSF    03.7
047A:  MOVF   00,W
047B:  SUBLW  7E
047C:  BTFSS  03.0
047D:  GOTO   4A7
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
047E:  MOVF   63,W
047F:  ADDWF  5F,W
0480:  MOVWF  04
0481:  BCF    03.7
0482:  BTFSC  60.0
0483:  BSF    03.7
0484:  MOVLW  53
0485:  SUBWF  00,W
0486:  BSF    03.5
0487:  MOVWF  11
0488:  MOVWF  12
0489:  MOVLW  05
048A:  MOVWF  13
048B:  BCF    03.5
048C:  BCF    03.6
048D:  CALL   248
048E:  MOVF   78,W
048F:  BSF    03.5
0490:  BSF    03.6
0491:  MOVWF  10
0492:  MOVWF  78
0493:  MOVLW  05
0494:  MOVWF  77
0495:  MOVLW  68
0496:  MOVWF  04
0497:  BSF    03.7
0498:  MOVF   78,W
0499:  BCF    03.5
049A:  BCF    03.6
049B:  CALL   10A
049C:  MOVWF  00
049D:  INCF   78,F
049E:  INCF   04,F
049F:  DECFSZ 77,F
04A0:  GOTO   4A2
04A1:  GOTO   4A5
04A2:  BSF    03.5
04A3:  BSF    03.6
04A4:  GOTO   498
04A5:  GOTO   4AD
04A6:  BSF    03.6
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
04A7:  CLRF   68
04A8:  CLRF   69
04A9:  CLRF   6A
04AA:  CLRF   6B
04AB:  CLRF   6C
04AC:  BCF    03.6
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
04AD:  MOVLW  05
04AE:  BSF    03.5
04AF:  BSF    03.6
04B0:  MOVWF  12
04B1:  BCF    03.5
04B2:  MOVF   61,W
04B3:  BSF    03.5
04B4:  MOVWF  13
04B5:  BCF    03.5
04B6:  BCF    03.6
04B7:  CALL   248
04B8:  MOVF   78,W
04B9:  BSF    03.6
04BA:  ADDWF  5D,W
04BB:  SUBLW  7F
04BC:  BTFSC  03.0
04BD:  GOTO   4CD
....................       { 
....................          x = 0;                           // Set x at far left position 
04BE:  CLRF   5D
....................          y += 7*size + 1;                 // Set y at next position down 
04BF:  MOVLW  07
04C0:  BSF    03.5
04C1:  MOVWF  12
04C2:  BCF    03.5
04C3:  MOVF   61,W
04C4:  BSF    03.5
04C5:  MOVWF  13
04C6:  BCF    03.5
04C7:  BCF    03.6
04C8:  CALL   248
04C9:  MOVLW  01
04CA:  ADDWF  78,W
04CB:  BSF    03.6
04CC:  ADDWF  5E,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
04CD:  CLRF   64
04CE:  MOVF   64,W
04CF:  SUBLW  04
04D0:  BTFSS  03.0
04D1:  GOTO   52A
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
04D2:  CLRF   65
04D3:  MOVLW  07
04D4:  BSF    03.5
04D5:  MOVWF  12
04D6:  BCF    03.5
04D7:  MOVF   61,W
04D8:  BSF    03.5
04D9:  MOVWF  13
04DA:  BCF    03.5
04DB:  BCF    03.6
04DC:  CALL   248
04DD:  MOVF   78,W
04DE:  BSF    03.6
04DF:  SUBWF  65,W
04E0:  BTFSC  03.0
04E1:  GOTO   526
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
04E2:  MOVLW  68
04E3:  ADDWF  64,W
04E4:  MOVWF  04
04E5:  BSF    03.7
04E6:  MOVF   00,W
04E7:  BSF    03.5
04E8:  MOVWF  10
04E9:  MOVWF  77
04EA:  BCF    03.5
04EB:  MOVF   65,W
04EC:  MOVWF  78
04ED:  BTFSC  03.2
04EE:  GOTO   4F3
04EF:  BCF    03.0
04F0:  RRF    77,F
04F1:  DECFSZ 78,F
04F2:  GOTO   4EF
04F3:  BTFSS  77.0
04F4:  GOTO   524
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
04F5:  CLRF   66
04F6:  MOVF   61,W
04F7:  SUBWF  66,W
04F8:  BTFSC  03.0
04F9:  GOTO   524
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
04FA:  CLRF   67
04FB:  MOVF   61,W
04FC:  SUBWF  67,W
04FD:  BTFSC  03.0
04FE:  GOTO   522
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
04FF:  MOVF   67,W
0500:  ADDWF  5D,W
0501:  BSF    03.5
0502:  MOVWF  10
0503:  BCF    03.5
0504:  MOVF   65,W
0505:  BSF    03.5
0506:  MOVWF  12
0507:  BCF    03.5
0508:  MOVF   61,W
0509:  BSF    03.5
050A:  MOVWF  13
050B:  BCF    03.5
050C:  BCF    03.6
050D:  CALL   248
050E:  MOVF   78,W
050F:  BSF    03.6
0510:  ADDWF  5E,W
0511:  ADDWF  66,W
0512:  BSF    03.5
0513:  MOVWF  11
0514:  MOVF   10,W
0515:  MOVWF  12
0516:  MOVF   11,W
0517:  MOVWF  13
0518:  BCF    03.5
0519:  MOVF   62,W
051A:  BSF    03.5
051B:  MOVWF  14
051C:  BCF    03.5
051D:  BCF    03.6
051E:  CALL   379
051F:  BSF    03.6
0520:  INCF   67,F
0521:  GOTO   4FB
....................                   } 
0522:  INCF   66,F
0523:  GOTO   4F6
....................                } 
....................             } 
0524:  INCF   65,F
0525:  GOTO   4D3
....................          } 
0526:  INCF   64,F
0527:  MOVF   61,W
0528:  ADDWF  5D,F
0529:  GOTO   4CE
....................       } 
052A:  INCF   63,F
052B:  INCF   5D,F
052C:  GOTO   438
....................    } 
052D:  BCF    03.6
052E:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0271:  BSF    03.6
0272:  CLRF   4A
0273:  MOVF   4A,W
0274:  SUBLW  07
0275:  BTFSS  03.0
0276:  GOTO   2E8
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
0277:  BSF    03.5
0278:  BCF    03.6
0279:  BCF    06.2
027A:  BCF    03.5
027B:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
027C:  MOVLW  30
027D:  BSF    03.5
027E:  BSF    03.6
027F:  MOVWF  18
0280:  MOVLW  40
0281:  MOVWF  19
0282:  BCF    03.5
0283:  BCF    03.6
0284:  CALL   216
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
0285:  MOVLW  31
0286:  BSF    03.5
0287:  BSF    03.6
0288:  MOVWF  18
0289:  MOVLW  40
028A:  MOVWF  19
028B:  BCF    03.5
028C:  BCF    03.6
028D:  CALL   216
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
028E:  BSF    03.6
028F:  MOVF   4A,W
0290:  IORLW  B8
0291:  MOVWF  4C
0292:  MOVLW  30
0293:  BSF    03.5
0294:  MOVWF  18
0295:  BCF    03.5
0296:  MOVF   4C,W
0297:  BSF    03.5
0298:  MOVWF  19
0299:  BCF    03.5
029A:  BCF    03.6
029B:  CALL   216
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
029C:  BSF    03.6
029D:  MOVF   4A,W
029E:  IORLW  B8
029F:  MOVWF  4C
02A0:  MOVLW  31
02A1:  BSF    03.5
02A2:  MOVWF  18
02A3:  BCF    03.5
02A4:  MOVF   4C,W
02A5:  BSF    03.5
02A6:  MOVWF  19
02A7:  BCF    03.5
02A8:  BCF    03.6
02A9:  CALL   216
....................       output_high(GLCD_DI);                     // Set for data 
02AA:  BSF    03.5
02AB:  BCF    06.2
02AC:  BCF    03.5
02AD:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
02AE:  BSF    03.6
02AF:  CLRF   4B
02B0:  MOVF   4B,W
02B1:  SUBLW  3F
02B2:  BTFSS  03.0
02B3:  GOTO   2E6
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
02B4:  MOVLW  FF
02B5:  BSF    03.5
02B6:  MOVWF  12
02B7:  BCF    03.5
02B8:  MOVF   49,W
02B9:  BSF    03.5
02BA:  MOVWF  13
02BB:  BCF    03.5
02BC:  BCF    03.6
02BD:  CALL   248
02BE:  MOVF   78,W
02BF:  BSF    03.6
02C0:  MOVWF  4C
02C1:  MOVLW  30
02C2:  BSF    03.5
02C3:  MOVWF  18
02C4:  BCF    03.5
02C5:  MOVF   4C,W
02C6:  BSF    03.5
02C7:  MOVWF  19
02C8:  BCF    03.5
02C9:  BCF    03.6
02CA:  CALL   216
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
02CB:  MOVLW  FF
02CC:  BSF    03.5
02CD:  BSF    03.6
02CE:  MOVWF  12
02CF:  BCF    03.5
02D0:  MOVF   49,W
02D1:  BSF    03.5
02D2:  MOVWF  13
02D3:  BCF    03.5
02D4:  BCF    03.6
02D5:  CALL   248
02D6:  MOVF   78,W
02D7:  BSF    03.6
02D8:  MOVWF  4C
02D9:  MOVLW  31
02DA:  BSF    03.5
02DB:  MOVWF  18
02DC:  BCF    03.5
02DD:  MOVF   4C,W
02DE:  BSF    03.5
02DF:  MOVWF  19
02E0:  BCF    03.5
02E1:  BCF    03.6
02E2:  CALL   216
02E3:  BSF    03.6
02E4:  INCF   4B,F
02E5:  GOTO   2B0
....................       } 
02E6:  INCF   4A,F
02E7:  GOTO   273
....................    } 
02E8:  BCF    03.6
02E9:  RETURN
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
0216:  BSF    03.5
0217:  BSF    03.6
0218:  MOVF   18,W
0219:  SUBLW  30
021A:  BTFSS  03.2
021B:  GOTO   223
....................       output_high(GLCD_CS1); 
021C:  BCF    03.6
021D:  BCF    06.0
021E:  BCF    03.5
021F:  BSF    06.0
0220:  GOTO   227
0221:  BSF    03.5
0222:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS2); 
0223:  BCF    03.6
0224:  BCF    06.1
0225:  BCF    03.5
0226:  BSF    06.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
0227:  BSF    03.5
0228:  BCF    06.4
0229:  BCF    03.5
022A:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
022B:  BSF    03.5
022C:  CLRF   08
022D:  BSF    03.6
022E:  MOVF   19,W
022F:  BCF    03.5
0230:  BCF    03.6
0231:  MOVWF  08
....................    output_high(GLCD_E);       // Pulse the enable pin 
0232:  BSF    03.5
0233:  BCF    06.5
0234:  BCF    03.5
0235:  BSF    06.5
....................    delay_us(2); 
0236:  MOVLW  02
0237:  MOVWF  77
0238:  DECFSZ 77,F
0239:  GOTO   238
023A:  NOP
....................    output_low(GLCD_E); 
023B:  BSF    03.5
023C:  BCF    06.5
023D:  BCF    03.5
023E:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
023F:  BSF    03.5
0240:  BCF    06.0
0241:  BCF    03.5
0242:  BCF    06.0
....................    output_low(GLCD_CS2); 
0243:  BSF    03.5
0244:  BCF    06.1
0245:  BCF    03.5
0246:  BCF    06.1
0247:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
03AF:  MOVF   17,W
03B0:  SUBLW  30
03B1:  BTFSS  03.2
03B2:  GOTO   3BA
....................       output_high(GLCD_CS1); 
03B3:  BCF    03.6
03B4:  BCF    06.0
03B5:  BCF    03.5
03B6:  BSF    06.0
03B7:  GOTO   3BE
03B8:  BSF    03.5
03B9:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS2); 
03BA:  BCF    03.6
03BB:  BCF    06.1
03BC:  BCF    03.5
03BD:  BSF    06.1
....................  
....................    input_d();                 // Set port d to input 
03BE:  MOVLW  FF
03BF:  BSF    03.5
03C0:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
03C1:  BCF    06.4
03C2:  BCF    03.5
03C3:  BSF    06.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
03C4:  BSF    03.5
03C5:  BCF    06.5
03C6:  BCF    03.5
03C7:  BSF    06.5
....................    delay_us(2); 
03C8:  MOVLW  02
03C9:  MOVWF  77
03CA:  DECFSZ 77,F
03CB:  GOTO   3CA
03CC:  NOP
....................    output_low(GLCD_E); 
03CD:  BSF    03.5
03CE:  BCF    06.5
03CF:  BCF    03.5
03D0:  BCF    06.5
....................    delay_us(2); 
03D1:  MOVLW  02
03D2:  MOVWF  77
03D3:  DECFSZ 77,F
03D4:  GOTO   3D3
03D5:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
03D6:  BSF    03.5
03D7:  BCF    06.5
03D8:  BCF    03.5
03D9:  BSF    06.5
....................    delay_us(2); 
03DA:  MOVLW  02
03DB:  MOVWF  77
03DC:  DECFSZ 77,F
03DD:  GOTO   3DC
03DE:  NOP
....................    data = input_d();          // Get the data from the display's output register 
03DF:  MOVLW  FF
03E0:  BSF    03.5
03E1:  MOVWF  08
03E2:  BCF    03.5
03E3:  MOVF   08,W
03E4:  BSF    03.5
03E5:  BSF    03.6
03E6:  MOVWF  18
....................    output_low(GLCD_E); 
03E7:  BCF    03.6
03E8:  BCF    06.5
03E9:  BCF    03.5
03EA:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
03EB:  BSF    03.5
03EC:  BCF    06.0
03ED:  BCF    03.5
03EE:  BCF    06.0
....................    output_low(GLCD_CS2); 
03EF:  BSF    03.5
03F0:  BCF    06.1
03F1:  BCF    03.5
03F2:  BCF    06.1
....................    return data;               // Return the read data 
03F3:  BSF    03.5
03F4:  BSF    03.6
03F5:  MOVF   18,W
03F6:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #include <stdio.h> // standard I/O for string formatting (sprintf) 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #define uchar unsigned char // alias for unsigned char 
.................... #define GRID_SIZE       6  // size of each grid cell (6x6 pixels) 
.................... #define GRID_COLS      10  // number of columns in the grid 
.................... #define GRID_ROWS      10  // number of rows in the grid 
.................... #define GRID_ORIGIN_X   0  // x starting position of the grid 
.................... #define GRID_ORIGIN_Y   0  // y starting position of the grid 
.................... #define BUZZER_PIN   PIN_B3 // buzzer connected to pin RB3 
....................  
.................... /// buzzer part 
.................... void buzzer_beep(int duration_ms) { // makes the buzzer beep for given time in ms 
*
0689:  BSF    03.6
068A:  CLRF   53
068B:  MOVF   4F,W
068C:  MOVWF  52
068D:  MOVLW  03
068E:  MOVWF  55
068F:  MOVLW  E8
0690:  MOVWF  54
0691:  BCF    03.6
0692:  CALL   64B
0693:  MOVF   79,W
0694:  BSF    03.6
0695:  MOVWF  53
0696:  MOVF   78,W
0697:  MOVWF  52
0698:  MOVF   53,W
0699:  MOVWF  55
069A:  MOVF   52,W
069B:  MOVWF  54
069C:  MOVLW  07
069D:  MOVWF  57
069E:  MOVLW  D0
069F:  MOVWF  56
06A0:  BCF    03.6
06A1:  CALL   662
06A2:  MOVF   78,W
06A3:  BSF    03.6
06A4:  MOVWF  50
....................     int cycles = duration_ms * 1000L / 2000; // calculates number of on/off cycles (each 2ms = one square wave cycle) 
....................     for (int i = 0; i < cycles; i++) { // repeat for calculated number of cycles 
06A5:  CLRF   51
06A6:  MOVF   50,W
06A7:  SUBWF  51,W
06A8:  BTFSC  03.0
06A9:  GOTO   6C0
....................         output_low(BUZZER_PIN);     // turn buzzer on (active-low) 
06AA:  BSF    03.5
06AB:  BCF    03.6
06AC:  BCF    06.3
06AD:  BCF    03.5
06AE:  BCF    06.3
....................         delay_us(1000);             // wait 1 ms (half cycle) 
06AF:  MOVLW  01
06B0:  BSF    03.6
06B1:  MOVWF  52
06B2:  BCF    03.6
06B3:  CALL   364
....................         output_high(BUZZER_PIN);    // turn buzzer off 
06B4:  BSF    03.5
06B5:  BCF    06.3
06B6:  BCF    03.5
06B7:  BSF    06.3
....................         delay_us(1000);             // wait 1 ms (half cycle) 
06B8:  MOVLW  01
06B9:  BSF    03.6
06BA:  MOVWF  52
06BB:  BCF    03.6
06BC:  CALL   364
06BD:  BSF    03.6
06BE:  INCF   51,F
06BF:  GOTO   6A6
....................         // 1 ms on + 1 ms off = 2 ms full cycle -- creates ~500 Hz square wave 
....................     } 
....................     output_high(BUZZER_PIN); // ensure buzzer is off at the end 
06C0:  BSF    03.5
06C1:  BCF    03.6
06C2:  BCF    06.3
06C3:  BCF    03.5
06C4:  BSF    06.3
06C5:  RETURN
.................... } 
....................  
.................... void short_beep() { // plays a short beep 
....................     buzzer_beep(100); // beep for 100 ms 
06C6:  MOVLW  64
06C7:  BSF    03.6
06C8:  MOVWF  4F
06C9:  BCF    03.6
06CA:  CALL   689
06CB:  RETURN
.................... } 
....................  
.................... void error_beep() { // plays error beep pattern 
....................     buzzer_beep(1000); // beep 1 sec 
*
07CF:  MOVLW  E8
07D0:  BSF    03.6
07D1:  MOVWF  4F
07D2:  BCF    03.6
07D3:  CALL   689
....................     delay_ms(200);     // short pause 
07D4:  MOVLW  C8
07D5:  BSF    03.6
07D6:  MOVWF  52
07D7:  BCF    03.6
07D8:  CALL   364
....................     buzzer_beep(1000); // beep 1 sec 
07D9:  MOVLW  E8
07DA:  BSF    03.6
07DB:  MOVWF  4F
07DC:  BCF    03.6
07DD:  CALL   689
....................     delay_ms(200);     // short pause 
07DE:  MOVLW  C8
07DF:  BSF    03.6
07E0:  MOVWF  52
07E1:  BCF    03.6
07E2:  CALL   364
....................     buzzer_beep(700);  // beep 0.7 sec 
07E3:  MOVLW  BC
07E4:  BSF    03.6
07E5:  MOVWF  4F
07E6:  BCF    03.6
07E7:  CALL   689
....................     delay_ms(200);     // short pause 
07E8:  MOVLW  C8
07E9:  BSF    03.6
07EA:  MOVWF  52
07EB:  BCF    03.6
07EC:  CALL   364
07ED:  RETURN
.................... } 
....................  
....................  
....................  
.................... void win_melody() { 
....................     int notes[] = {100, 150, 100, 150, 100, 150, 100, 150, 150, 100, 150, 100}; // beep durations (ms) 
*
0AEB:  MOVLW  64
0AEC:  BSF    03.6
0AED:  MOVWF  35
0AEE:  MOVLW  96
0AEF:  MOVWF  36
0AF0:  MOVLW  64
0AF1:  MOVWF  37
0AF2:  MOVLW  96
0AF3:  MOVWF  38
0AF4:  MOVLW  64
0AF5:  MOVWF  39
0AF6:  MOVLW  96
0AF7:  MOVWF  3A
0AF8:  MOVLW  64
0AF9:  MOVWF  3B
0AFA:  MOVLW  96
0AFB:  MOVWF  3C
0AFC:  MOVWF  3D
0AFD:  MOVLW  64
0AFE:  MOVWF  3E
0AFF:  MOVLW  96
0B00:  MOVWF  3F
0B01:  MOVLW  64
0B02:  MOVWF  40
....................     int gaps[]  = {50, 100, 130, 50, 100, 50, 130, 100, 50, 130, 100, 0};       // pause durations (ms) 
0B03:  MOVLW  32
0B04:  MOVWF  41
0B05:  MOVLW  64
0B06:  MOVWF  42
0B07:  MOVLW  82
0B08:  MOVWF  43
0B09:  MOVLW  32
0B0A:  MOVWF  44
0B0B:  MOVLW  64
0B0C:  MOVWF  45
0B0D:  MOVLW  32
0B0E:  MOVWF  46
0B0F:  MOVLW  82
0B10:  MOVWF  47
0B11:  MOVLW  64
0B12:  MOVWF  48
0B13:  MOVLW  32
0B14:  MOVWF  49
0B15:  MOVLW  82
0B16:  MOVWF  4A
0B17:  MOVLW  64
0B18:  MOVWF  4B
0B19:  CLRF   4C
....................  
....................     for (int i = 0; i < 12; i++) { 
0B1A:  CLRF   4D
0B1B:  MOVF   4D,W
0B1C:  SUBLW  0B
0B1D:  BTFSS  03.0
0B1E:  GOTO   339
....................         buzzer_beep(notes[i]);   // play beep 
0B1F:  MOVLW  35
0B20:  ADDWF  4D,W
0B21:  MOVWF  04
0B22:  BSF    03.7
0B23:  MOVF   00,W
0B24:  MOVWF  4E
0B25:  MOVWF  4F
0B26:  BCF    0A.3
0B27:  BCF    03.6
0B28:  CALL   689
0B29:  BSF    0A.3
....................         delay_ms(gaps[i]);       // wait between beeps 
0B2A:  MOVLW  41
0B2B:  BSF    03.6
0B2C:  ADDWF  4D,W
0B2D:  MOVWF  04
0B2E:  BSF    03.7
0B2F:  MOVF   00,W
0B30:  MOVWF  4E
0B31:  MOVWF  52
0B32:  BCF    0A.3
0B33:  BCF    03.6
0B34:  CALL   364
0B35:  BSF    0A.3
0B36:  BSF    03.6
0B37:  INCF   4D,F
0B38:  GOTO   31B
....................     } 
0B39:  BCF    03.6
0B3A:  RETURN
.................... } 
....................  
....................  
.................... uchar snakeX[32]; // x positions of segments 031 
.................... uchar snakeY[32]; // y positions of segments 031 
.................... uchar snakeX2[32]; // x positions of segments 3263 
.................... uchar snakeY2[32]; // y positions of segments 3263 
....................  
.................... #define getX(i) ((i < 32) ? snakeX[i] : snakeX2[(i)-32]) // get x of segment i (uses snakeX for 031, snakeX2 for 3263) 
.................... #define getY(i) ((i < 32) ? snakeY[i] : snakeY2[(i)-32]) // get y of segment i (splits into 2 arrays to support up to 64 segments) 
.................... #define setX(i,val) ((i < 32) ? (snakeX[i]=(val)) : (snakeX2[(i)-32]=(val))) // set x of segment i (split arrays avoid index overflow) 
.................... #define setY(i,val) ((i < 32) ? (snakeY[i]=(val)) : (snakeY2[(i)-32]=(val))) // set y of segment i (32+ segments handled by second array) 
....................  
.................... uchar dir = 2; // snake direction (0: left, 1: up, 2: down, 3: right) 
.................... uchar food[2], LENGTH_SNAKE = 64; // food[x, y] and snake length 
.................... uchar posX = 0, posY = 2; // current head position 
.................... uchar score = 0; // current score 
.................... uchar best_score = 0; // best score 
.................... char score_txt[11] = "Score: 00"; // score string for display 
*
0BAD:  MOVLW  53
0BAE:  BSF    03.5
0BAF:  MOVWF  60
0BB0:  MOVLW  63
0BB1:  MOVWF  61
0BB2:  MOVLW  6F
0BB3:  MOVWF  62
0BB4:  MOVLW  72
0BB5:  MOVWF  63
0BB6:  MOVLW  65
0BB7:  MOVWF  64
0BB8:  MOVLW  3A
0BB9:  MOVWF  65
0BBA:  MOVLW  20
0BBB:  MOVWF  66
0BBC:  MOVLW  30
0BBD:  MOVWF  67
0BBE:  MOVWF  68
0BBF:  CLRF   69
.................... char best_score_txt[10] = "Best: 00"; // best score string 
0BC0:  MOVLW  42
0BC1:  BCF    03.5
0BC2:  BSF    03.6
0BC3:  MOVWF  10
0BC4:  MOVLW  65
0BC5:  MOVWF  11
0BC6:  MOVLW  73
0BC7:  MOVWF  12
0BC8:  MOVLW  74
0BC9:  MOVWF  13
0BCA:  MOVLW  3A
0BCB:  MOVWF  14
0BCC:  MOVLW  20
0BCD:  MOVWF  15
0BCE:  MOVLW  30
0BCF:  MOVWF  16
0BD0:  MOVWF  17
0BD1:  CLRF   18
.................... char gameover_msg[14] = "GAMEOVER !!!"; // game over text 
0BD2:  MOVLW  47
0BD3:  MOVWF  1A
0BD4:  MOVLW  41
0BD5:  MOVWF  1B
0BD6:  MOVLW  4D
0BD7:  MOVWF  1C
0BD8:  MOVLW  45
0BD9:  MOVWF  1D
0BDA:  MOVLW  4F
0BDB:  MOVWF  1E
0BDC:  MOVLW  56
0BDD:  MOVWF  1F
0BDE:  MOVLW  45
0BDF:  MOVWF  20
0BE0:  MOVLW  52
0BE1:  MOVWF  21
0BE2:  MOVLW  20
0BE3:  MOVWF  22
0BE4:  MOVLW  21
0BE5:  MOVWF  23
0BE6:  MOVWF  24
0BE7:  MOVWF  25
0BE8:  CLRF   26
.................... char win_msg[] = "YOU WON!"; // win message 
0BE9:  MOVLW  59
0BEA:  MOVWF  28
0BEB:  MOVLW  4F
0BEC:  MOVWF  29
0BED:  MOVLW  55
0BEE:  MOVWF  2A
0BEF:  MOVLW  20
0BF0:  MOVWF  2B
0BF1:  MOVLW  57
0BF2:  MOVWF  2C
0BF3:  MOVLW  4F
0BF4:  MOVWF  2D
0BF5:  MOVLW  4E
0BF6:  MOVWF  2E
0BF7:  MOVLW  21
0BF8:  MOVWF  2F
0BF9:  CLRF   30
.................... uchar i; // loop counter 
....................  
.................... int1 isFirstStart = 1; // flag for first game start 
.................... uchar difficulty_index = 0; // 0: easy, 1: medium, 2: hard 
....................  
.................... struct { 
....................     unsigned delay_time : 2; // 2-bit speed setting 
.................... } gameSettings; // game settings struct 
....................  
.................... // glcd part 
.................... void fillCell(signed int gx, signed int gy, int1 color) { // fills a grid cell at (gx, gy) with given color 
....................     if (gx < 0 || gx >= GRID_COLS || gy < 0 || gy >= GRID_ROWS) return; // skip if outside grid 
*
09E0:  BSF    03.6
09E1:  BTFSC  37.7
09E2:  GOTO   1F0
09E3:  BTFSC  37.7
09E4:  GOTO   1E9
09E5:  MOVF   37,W
09E6:  SUBLW  09
09E7:  BTFSS  03.0
09E8:  GOTO   1F0
09E9:  BTFSC  38.7
09EA:  GOTO   1F0
09EB:  BTFSC  38.7
09EC:  GOTO   1F1
09ED:  MOVF   38,W
09EE:  SUBLW  09
09EF:  BTFSS  03.0
09F0:  GOTO   232
....................     uchar px = GRID_ORIGIN_X + gx * GRID_SIZE + 1; // x pixel start position inside cell 
....................     uchar py = GRID_ORIGIN_Y + gy * GRID_SIZE + 1; // y pixel start position inside cell 
09F1:  MOVF   37,W
09F2:  BSF    03.5
09F3:  MOVWF  12
09F4:  MOVLW  06
09F5:  MOVWF  13
09F6:  BCF    0A.3
09F7:  BCF    03.5
09F8:  BCF    03.6
09F9:  CALL   248
09FA:  BSF    0A.3
09FB:  MOVLW  01
09FC:  ADDWF  78,W
09FD:  BSF    03.6
09FE:  MOVWF  3A
09FF:  MOVF   38,W
0A00:  BSF    03.5
0A01:  MOVWF  12
0A02:  MOVLW  06
0A03:  MOVWF  13
0A04:  BCF    0A.3
0A05:  BCF    03.5
0A06:  BCF    03.6
0A07:  CALL   248
0A08:  BSF    0A.3
0A09:  MOVLW  01
0A0A:  ADDWF  78,W
0A0B:  BSF    03.6
0A0C:  MOVWF  3B
....................     for (uchar dx = 0; dx < GRID_SIZE - 1; dx++)       // loop through cell width 
0A0D:  CLRF   3C
0A0E:  MOVF   3C,W
0A0F:  SUBLW  04
0A10:  BTFSS  03.0
0A11:  GOTO   232
....................       for (uchar dy = 0; dy < GRID_SIZE - 1; dy++)     // loop through cell height 
0A12:  CLRF   3D
0A13:  MOVF   3D,W
0A14:  SUBLW  04
0A15:  BTFSS  03.0
0A16:  GOTO   230
....................           glcd_pixel(px + dx, py + dy, color);         // draw each pixel inside cell 
0A17:  MOVF   3C,W
0A18:  ADDWF  3A,W
0A19:  MOVWF  3E
0A1A:  MOVF   3D,W
0A1B:  ADDWF  3B,W
0A1C:  MOVWF  3F
0A1D:  MOVF   3E,W
0A1E:  BSF    03.5
0A1F:  MOVWF  12
0A20:  BCF    03.5
0A21:  MOVF   3F,W
0A22:  BSF    03.5
0A23:  MOVWF  13
0A24:  BCF    03.5
0A25:  MOVF   39,W
0A26:  BSF    03.5
0A27:  MOVWF  14
0A28:  BCF    0A.3
0A29:  BCF    03.5
0A2A:  BCF    03.6
0A2B:  CALL   379
0A2C:  BSF    0A.3
0A2D:  BSF    03.6
0A2E:  INCF   3D,F
0A2F:  GOTO   213
0A30:  INCF   3C,F
0A31:  GOTO   20E
0A32:  BCF    03.6
0A33:  RETURN
.................... } 
....................  
.................... void screenWipeDown() { // fills screen line by line from top to bottom 
....................     for (uchar y = 0; y < 64; y++) { // loop through rows (64 lines) 
*
0582:  BSF    03.6
0583:  CLRF   35
0584:  MOVF   35,W
0585:  SUBLW  3F
0586:  BTFSS  03.0
0587:  GOTO   5A3
....................       for (uchar x = 0; x < 128; x++) { // loop through columns (128 pixels wide) 
0588:  CLRF   36
0589:  MOVF   36,W
058A:  SUBLW  7F
058B:  BTFSS  03.0
058C:  GOTO   59C
....................           glcd_pixel(x, y, 1); // turn on pixel at (x, y) 
058D:  MOVF   36,W
058E:  BSF    03.5
058F:  MOVWF  12
0590:  BCF    03.5
0591:  MOVF   35,W
0592:  BSF    03.5
0593:  MOVWF  13
0594:  MOVLW  01
0595:  MOVWF  14
0596:  BCF    03.5
0597:  BCF    03.6
0598:  CALL   379
0599:  BSF    03.6
059A:  INCF   36,F
059B:  GOTO   589
....................       } 
....................       delay_ms(5); // delay for wipe animation effect 
059C:  MOVLW  05
059D:  MOVWF  52
059E:  BCF    03.6
059F:  CALL   364
05A0:  BSF    03.6
05A1:  INCF   35,F
05A2:  GOTO   584
....................     } 
05A3:  BCF    03.6
05A4:  RETURN
.................... } 
....................  
.................... void drawGrid() { // draws vertical and horizontal grid lines 
....................     for (uchar c = 0; c <= GRID_COLS; c++) { // vertical lines 
*
078C:  BSF    03.6
078D:  CLRF   35
078E:  MOVF   35,W
078F:  SUBLW  0A
0790:  BTFSS  03.0
0791:  GOTO   7AD
....................       uchar x = GRID_ORIGIN_X + c * GRID_SIZE; // x coordinate of line 
0792:  MOVF   35,W
0793:  BSF    03.5
0794:  MOVWF  12
0795:  MOVLW  06
0796:  MOVWF  13
0797:  BCF    03.5
0798:  BCF    03.6
0799:  CALL   248
079A:  MOVF   78,W
079B:  BSF    03.6
079C:  MOVWF  36
....................       glcd_line(x, GRID_ORIGIN_Y, x, GRID_ORIGIN_Y + GRID_ROWS * GRID_SIZE, 1); 
079D:  MOVF   36,W
079E:  MOVWF  39
079F:  CLRF   3A
07A0:  MOVF   36,W
07A1:  MOVWF  3B
07A2:  MOVLW  3C
07A3:  MOVWF  3C
07A4:  MOVLW  01
07A5:  MOVWF  3D
07A6:  BSF    0A.3
07A7:  BCF    03.6
07A8:  CALL   000
07A9:  BCF    0A.3
07AA:  BSF    03.6
07AB:  INCF   35,F
07AC:  GOTO   78E
....................     } 
....................     for (uchar r = 0; r <= GRID_ROWS; r++) { // horizontal lines 
07AD:  CLRF   37
07AE:  MOVF   37,W
07AF:  SUBLW  0A
07B0:  BTFSS  03.0
07B1:  GOTO   7CD
....................       uchar y = GRID_ORIGIN_Y + r * GRID_SIZE; // y coordinate of line 
07B2:  MOVF   37,W
07B3:  BSF    03.5
07B4:  MOVWF  12
07B5:  MOVLW  06
07B6:  MOVWF  13
07B7:  BCF    03.5
07B8:  BCF    03.6
07B9:  CALL   248
07BA:  MOVF   78,W
07BB:  BSF    03.6
07BC:  MOVWF  38
....................       glcd_line(GRID_ORIGIN_X, y, GRID_ORIGIN_X + GRID_COLS * GRID_SIZE, y, 1); 
07BD:  CLRF   39
07BE:  MOVF   38,W
07BF:  MOVWF  3A
07C0:  MOVLW  3C
07C1:  MOVWF  3B
07C2:  MOVF   38,W
07C3:  MOVWF  3C
07C4:  MOVLW  01
07C5:  MOVWF  3D
07C6:  BSF    0A.3
07C7:  BCF    03.6
07C8:  CALL   000
07C9:  BCF    0A.3
07CA:  BSF    03.6
07CB:  INCF   37,F
07CC:  GOTO   7AE
....................     } 
07CD:  BCF    03.6
07CE:  RETURN
.................... } 
....................  
.................... void clearScoreArea() { // clears the area where score is shown 
....................     for (uchar x = 65; x < 125; x++) { 
*
0924:  MOVLW  41
0925:  BSF    03.6
0926:  MOVWF  35
0927:  MOVF   35,W
0928:  SUBLW  7C
0929:  BTFSS  03.0
092A:  GOTO   142
....................       for (uchar y = 0; y < 20; y++) { 
092B:  CLRF   36
092C:  MOVF   36,W
092D:  SUBLW  13
092E:  BTFSS  03.0
092F:  GOTO   140
....................           glcd_pixel(x, y, 0); // turn off pixel at (x, y) 
0930:  MOVF   35,W
0931:  BSF    03.5
0932:  MOVWF  12
0933:  BCF    03.5
0934:  MOVF   36,W
0935:  BSF    03.5
0936:  MOVWF  13
0937:  CLRF   14
0938:  BCF    0A.3
0939:  BCF    03.5
093A:  BCF    03.6
093B:  CALL   379
093C:  BSF    0A.3
093D:  BSF    03.6
093E:  INCF   36,F
093F:  GOTO   12C
....................       } 
0940:  INCF   35,F
0941:  GOTO   127
....................     } 
.................... } 
....................  
.................... void writeScore() { // displays current and best score on screen 
....................     clearScoreArea(); // clear old score 
....................     glcd_text57(65, 0, score_txt, 1, 1); // draw current score 
0942:  MOVLW  41
0943:  MOVWF  5D
0944:  CLRF   5E
0945:  CLRF   60
0946:  MOVLW  E0
0947:  MOVWF  5F
0948:  MOVLW  01
0949:  MOVWF  61
094A:  MOVWF  62
094B:  BCF    0A.3
094C:  BCF    03.6
094D:  CALL   436
094E:  BSF    0A.3
....................     glcd_text57(65, 10, best_score_txt, 1, 1); // draw best score 
094F:  MOVLW  41
0950:  BSF    03.6
0951:  MOVWF  5D
0952:  MOVLW  0A
0953:  MOVWF  5E
0954:  MOVLW  01
0955:  MOVWF  60
0956:  MOVLW  10
0957:  MOVWF  5F
0958:  MOVLW  01
0959:  MOVWF  61
095A:  MOVWF  62
095B:  BCF    0A.3
095C:  BCF    03.6
095D:  CALL   436
095E:  BSF    0A.3
095F:  RETURN
.................... } 
....................  
.................... void generateFood() { // randomly places food at an empty cell 
*
0A34:  BSF    03.6
0A35:  CLRF   35
....................     uchar valid = 0; 
....................     while (!valid) { 
0A36:  MOVF   35,F
0A37:  BTFSS  03.2
0A38:  GOTO   29B
....................       food[0] = rand() % GRID_COLS; // random x 
0A39:  BCF    03.6
0A3A:  CALL   160
0A3B:  MOVF   79,W
0A3C:  BSF    03.6
0A3D:  MOVWF  38
0A3E:  MOVF   78,W
0A3F:  MOVWF  37
0A40:  MOVF   38,W
0A41:  MOVWF  55
0A42:  MOVF   37,W
0A43:  MOVWF  54
0A44:  CLRF   57
0A45:  MOVLW  0A
0A46:  MOVWF  56
0A47:  BCF    0A.3
0A48:  BCF    03.6
0A49:  CALL   662
0A4A:  BSF    0A.3
0A4B:  MOVF   77,W
0A4C:  MOVWF  68
....................       food[1] = rand() % GRID_ROWS; // random y 
0A4D:  CALL   160
0A4E:  MOVF   79,W
0A4F:  BSF    03.6
0A50:  MOVWF  38
0A51:  MOVF   78,W
0A52:  MOVWF  37
0A53:  MOVF   38,W
0A54:  MOVWF  55
0A55:  MOVF   37,W
0A56:  MOVWF  54
0A57:  CLRF   57
0A58:  MOVLW  0A
0A59:  MOVWF  56
0A5A:  BCF    0A.3
0A5B:  BCF    03.6
0A5C:  CALL   662
0A5D:  BSF    0A.3
0A5E:  MOVF   77,W
0A5F:  MOVWF  69
....................       valid = 1; // assume valid 
0A60:  MOVLW  01
0A61:  BSF    03.6
0A62:  MOVWF  35
....................       for (uchar j = 0; j < LENGTH_SNAKE; j++) { 
0A63:  CLRF   36
0A64:  BCF    03.6
0A65:  MOVF   6A,W
0A66:  BSF    03.6
0A67:  SUBWF  36,W
0A68:  BTFSC  03.0
0A69:  GOTO   29A
....................           if (getX(j) == food[0] && getY(j) == food[1]) { // check overlap 
0A6A:  MOVF   36,W
0A6B:  SUBLW  1F
0A6C:  BTFSS  03.0
0A6D:  GOTO   274
0A6E:  MOVLW  27
0A6F:  ADDWF  36,W
0A70:  MOVWF  04
0A71:  BCF    03.7
0A72:  MOVF   00,W
0A73:  GOTO   27A
0A74:  MOVLW  20
0A75:  SUBWF  36,W
0A76:  ADDLW  A0
0A77:  MOVWF  04
0A78:  BCF    03.7
0A79:  MOVF   00,W
0A7A:  BCF    03.6
0A7B:  SUBWF  68,W
0A7C:  BTFSS  03.2
0A7D:  GOTO   297
0A7E:  BSF    03.6
0A7F:  MOVF   36,W
0A80:  SUBLW  1F
0A81:  BTFSS  03.0
0A82:  GOTO   289
0A83:  MOVLW  47
0A84:  ADDWF  36,W
0A85:  MOVWF  04
0A86:  BCF    03.7
0A87:  MOVF   00,W
0A88:  GOTO   28F
0A89:  MOVLW  20
0A8A:  SUBWF  36,W
0A8B:  ADDLW  C0
0A8C:  MOVWF  04
0A8D:  BCF    03.7
0A8E:  MOVF   00,W
0A8F:  BCF    03.6
0A90:  SUBWF  69,W
0A91:  BTFSS  03.2
0A92:  GOTO   297
....................               valid = 0; // invalid if overlaps 
0A93:  BSF    03.6
0A94:  CLRF   35
....................               break; 
0A95:  GOTO   29A
0A96:  BCF    03.6
....................           } 
0A97:  BSF    03.6
0A98:  INCF   36,F
0A99:  GOTO   264
....................       } 
0A9A:  GOTO   236
....................     } 
....................     fillCell(food[0], food[1], 1); // draw food on screen 
0A9B:  BCF    03.6
0A9C:  MOVF   68,W
0A9D:  BSF    03.6
0A9E:  MOVWF  37
0A9F:  BCF    03.6
0AA0:  MOVF   69,W
0AA1:  BSF    03.6
0AA2:  MOVWF  38
0AA3:  MOVLW  01
0AA4:  MOVWF  39
0AA5:  BCF    03.6
0AA6:  CALL   1E0
0AA7:  RETURN
.................... } 
....................  
.................... void gameover() { // handles game over state 
....................     error_beep(); // play error sound 
0AA8:  BCF    0A.3
0AA9:  CALL   7CF
0AAA:  BSF    0A.3
....................     error_beep(); // play error sound 
0AAB:  BCF    0A.3
0AAC:  CALL   7CF
0AAD:  BSF    0A.3
....................     LENGTH_SNAKE = 5; // reset length 
0AAE:  MOVLW  05
0AAF:  MOVWF  6A
....................     posX = 0; posY = 2; // reset head position 
0AB0:  CLRF   6B
0AB1:  MOVLW  02
0AB2:  MOVWF  6C
....................     score = 0; // reset score 
0AB3:  CLRF   6D
....................     score_txt[7] = '0'; score_txt[8] = '0'; // reset score text 
0AB4:  MOVLW  30
0AB5:  BSF    03.5
0AB6:  MOVWF  67
0AB7:  MOVWF  68
....................     dir = 2; // reset direction to down 
0AB8:  MOVLW  02
0AB9:  BCF    03.5
0ABA:  MOVWF  67
....................  
....................     glcd_fillScreen(0); // clear screen 
0ABB:  BSF    03.6
0ABC:  CLRF   49
0ABD:  BCF    0A.3
0ABE:  BCF    03.6
0ABF:  CALL   271
0AC0:  BSF    0A.3
....................     glcd_text57(25, 30, gameover_msg, 1, 1); // show "game over" 5x7 
0AC1:  MOVLW  19
0AC2:  BSF    03.6
0AC3:  MOVWF  5D
0AC4:  MOVLW  1E
0AC5:  MOVWF  5E
0AC6:  MOVLW  01
0AC7:  MOVWF  60
0AC8:  MOVLW  1A
0AC9:  MOVWF  5F
0ACA:  MOVLW  01
0ACB:  MOVWF  61
0ACC:  MOVWF  62
0ACD:  BCF    0A.3
0ACE:  BCF    03.6
0ACF:  CALL   436
0AD0:  BSF    0A.3
....................     delay_ms(1500); // wait for display 
0AD1:  MOVLW  06
0AD2:  BSF    03.6
0AD3:  MOVWF  35
0AD4:  MOVLW  FA
0AD5:  MOVWF  52
0AD6:  BCF    0A.3
0AD7:  BCF    03.6
0AD8:  CALL   364
0AD9:  BSF    0A.3
0ADA:  BSF    03.6
0ADB:  DECFSZ 35,F
0ADC:  GOTO   2D4
....................     screenWipeDown(); // wipe animation 
0ADD:  BCF    0A.3
0ADE:  BCF    03.6
0ADF:  CALL   582
0AE0:  BSF    0A.3
....................     glcd_fillScreen(0); // clear screen again 
0AE1:  BSF    03.6
0AE2:  CLRF   49
0AE3:  BCF    0A.3
0AE4:  BCF    03.6
0AE5:  CALL   271
0AE6:  BSF    0A.3
....................     drawGrid(); // redraw grid 
0AE7:  BCF    0A.3
0AE8:  CALL   78C
0AE9:  BSF    0A.3
0AEA:  RETURN
.................... } 
....................  
.................... void winScreen() { // handles win state when snake is full 
....................     win_melody(); // play win sound 
*
0B3B:  CALL   2EB
....................     win_melody(); // play win sound 
0B3C:  CALL   2EB
....................     glcd_fillScreen(0); // clear screen 
0B3D:  BSF    03.6
0B3E:  CLRF   49
0B3F:  BCF    0A.3
0B40:  BCF    03.6
0B41:  CALL   271
0B42:  BSF    0A.3
....................     glcd_text57(35, 35, win_msg, 1, 1); // show win message 
0B43:  MOVLW  23
0B44:  BSF    03.6
0B45:  MOVWF  5D
0B46:  MOVWF  5E
0B47:  MOVLW  01
0B48:  MOVWF  60
0B49:  MOVLW  28
0B4A:  MOVWF  5F
0B4B:  MOVLW  01
0B4C:  MOVWF  61
0B4D:  MOVWF  62
0B4E:  BCF    0A.3
0B4F:  BCF    03.6
0B50:  CALL   436
0B51:  BSF    0A.3
....................     delay_ms(2500); // wait for display 
0B52:  MOVLW  0A
0B53:  BSF    03.6
0B54:  MOVWF  35
0B55:  MOVLW  FA
0B56:  MOVWF  52
0B57:  BCF    0A.3
0B58:  BCF    03.6
0B59:  CALL   364
0B5A:  BSF    0A.3
0B5B:  BSF    03.6
0B5C:  DECFSZ 35,F
0B5D:  GOTO   355
....................     screenWipeDown(); // wipe animation 
0B5E:  BCF    0A.3
0B5F:  BCF    03.6
0B60:  CALL   582
0B61:  BSF    0A.3
....................     glcd_fillScreen(0); // clear screen again 
0B62:  BSF    03.6
0B63:  CLRF   49
0B64:  BCF    0A.3
0B65:  BCF    03.6
0B66:  CALL   271
0B67:  BSF    0A.3
....................     drawGrid(); // redraw grid 
0B68:  BCF    0A.3
0B69:  CALL   78C
0B6A:  BSF    0A.3
....................     LENGTH_SNAKE = 5; posX = 0; posY = 2; // reset game state 
0B6B:  MOVLW  05
0B6C:  MOVWF  6A
0B6D:  CLRF   6B
0B6E:  MOVLW  02
0B6F:  MOVWF  6C
....................     score = 0; score_txt[7] = '0'; score_txt[8] = '0'; 
0B70:  CLRF   6D
0B71:  MOVLW  30
0B72:  BSF    03.5
0B73:  MOVWF  67
0B74:  MOVWF  68
....................     dir = 2; 
0B75:  MOVLW  02
0B76:  BCF    03.5
0B77:  MOVWF  67
0B78:  BSF    0A.3
0B79:  BCF    0A.4
0B7A:  GOTO   659 (RETURN)
.................... } 
....................  
.................... void showSplashScreen() { // shows game title at start 
....................     char serpenti_txt[] = "SERPENTI"; 
*
052F:  MOVLW  53
0530:  BSF    03.6
0531:  MOVWF  35
0532:  MOVLW  45
0533:  MOVWF  36
0534:  MOVLW  52
0535:  MOVWF  37
0536:  MOVLW  50
0537:  MOVWF  38
0538:  MOVLW  45
0539:  MOVWF  39
053A:  MOVLW  4E
053B:  MOVWF  3A
053C:  MOVLW  54
053D:  MOVWF  3B
053E:  MOVLW  49
053F:  MOVWF  3C
0540:  CLRF   3D
....................     char snakegame_txt[] = "SNAKE GAME"; 
0541:  MOVLW  53
0542:  MOVWF  3E
0543:  MOVLW  4E
0544:  MOVWF  3F
0545:  MOVLW  41
0546:  MOVWF  40
0547:  MOVLW  4B
0548:  MOVWF  41
0549:  MOVLW  45
054A:  MOVWF  42
054B:  MOVLW  20
054C:  MOVWF  43
054D:  MOVLW  47
054E:  MOVWF  44
054F:  MOVLW  41
0550:  MOVWF  45
0551:  MOVLW  4D
0552:  MOVWF  46
0553:  MOVLW  45
0554:  MOVWF  47
0555:  CLRF   48
....................     glcd_fillScreen(0); // clear screen 
0556:  CLRF   49
0557:  BCF    03.6
0558:  CALL   271
....................     glcd_text57(40, 22, serpenti_txt, 1, 1); // show title 
0559:  MOVLW  28
055A:  BSF    03.6
055B:  MOVWF  5D
055C:  MOVLW  16
055D:  MOVWF  5E
055E:  MOVLW  01
055F:  MOVWF  60
0560:  MOVLW  35
0561:  MOVWF  5F
0562:  MOVLW  01
0563:  MOVWF  61
0564:  MOVWF  62
0565:  BCF    03.6
0566:  CALL   436
....................     glcd_text57(34, 34, snakegame_txt, 1, 1); // show subtitle 
0567:  MOVLW  22
0568:  BSF    03.6
0569:  MOVWF  5D
056A:  MOVWF  5E
056B:  MOVLW  01
056C:  MOVWF  60
056D:  MOVLW  3E
056E:  MOVWF  5F
056F:  MOVLW  01
0570:  MOVWF  61
0571:  MOVWF  62
0572:  BCF    03.6
0573:  CALL   436
....................     delay_ms(2000); // wait before starting 
0574:  MOVLW  08
0575:  BSF    03.6
0576:  MOVWF  49
0577:  MOVLW  FA
0578:  MOVWF  52
0579:  BCF    03.6
057A:  CALL   364
057B:  BSF    03.6
057C:  DECFSZ 49,F
057D:  GOTO   577
057E:  BCF    03.6
057F:  BSF    0A.3
0580:  BCF    0A.4
0581:  GOTO   41D (RETURN)
.................... } 
....................  
.................... void displayDifficulty(uchar index) { // draws the difficulty text based on index 
....................     char difficultyText[16]; // buffer for difficulty label 
....................  
....................     for (uchar x = 0; x < 128; x++) { // clear horizontal range 
*
05A5:  BSF    03.6
05A6:  CLRF   59
05A7:  MOVF   59,W
05A8:  SUBLW  7F
05A9:  BTFSS  03.0
05AA:  GOTO   5C1
....................       for (uchar y = 30; y < 43; y++) { // clear vertical range 
05AB:  MOVLW  1E
05AC:  MOVWF  5A
05AD:  MOVF   5A,W
05AE:  SUBLW  2A
05AF:  BTFSS  03.0
05B0:  GOTO   5BF
....................           glcd_pixel(x, y, 0); // turn off pixel to erase previous text 
05B1:  MOVF   59,W
05B2:  BSF    03.5
05B3:  MOVWF  12
05B4:  BCF    03.5
05B5:  MOVF   5A,W
05B6:  BSF    03.5
05B7:  MOVWF  13
05B8:  CLRF   14
05B9:  BCF    03.5
05BA:  BCF    03.6
05BB:  CALL   379
05BC:  BSF    03.6
05BD:  INCF   5A,F
05BE:  GOTO   5AD
....................       } 
05BF:  INCF   59,F
05C0:  GOTO   5A7
....................     } 
....................  
....................     switch(index) { // set label by difficulty index 
05C1:  MOVF   48,W
05C2:  XORLW  00
05C3:  BCF    03.6
05C4:  BTFSC  03.2
05C5:  GOTO   5CD
05C6:  XORLW  01
05C7:  BTFSC  03.2
05C8:  GOTO   5E2
05C9:  XORLW  03
05CA:  BTFSC  03.2
05CB:  GOTO   5F7
05CC:  GOTO   60B
....................       case 0: strcpy(difficultyText, "< EASY >"); break; // easy mode 
05CD:  BSF    03.6
05CE:  CLRF   5D
05CF:  CLRF   5E
05D0:  MOVLW  49
05D1:  MOVWF  04
05D2:  BSF    03.7
05D3:  MOVF   5D,W
05D4:  ADDWF  04,F
05D5:  MOVF   5E,W
05D6:  BCF    03.6
05D7:  CALL   1EA
05D8:  MOVWF  00
05D9:  IORLW  00
05DA:  BTFSC  03.2
05DB:  GOTO   5E1
05DC:  BSF    03.6
05DD:  INCF   5E,F
05DE:  INCF   5D,F
05DF:  GOTO   5D0
05E0:  BCF    03.6
05E1:  GOTO   60B
....................       case 1: strcpy(difficultyText, "< MEDIUM >"); break; // medium mode 
05E2:  BSF    03.6
05E3:  CLRF   5D
05E4:  CLRF   5E
05E5:  MOVLW  49
05E6:  MOVWF  04
05E7:  BSF    03.7
05E8:  MOVF   5D,W
05E9:  ADDWF  04,F
05EA:  MOVF   5E,W
05EB:  BCF    03.6
05EC:  CALL   1F7
05ED:  MOVWF  00
05EE:  IORLW  00
05EF:  BTFSC  03.2
05F0:  GOTO   5F6
05F1:  BSF    03.6
05F2:  INCF   5E,F
05F3:  INCF   5D,F
05F4:  GOTO   5E5
05F5:  BCF    03.6
05F6:  GOTO   60B
....................       case 2: strcpy(difficultyText, "< HARD >"); break; // hard mode 
05F7:  BSF    03.6
05F8:  CLRF   5D
05F9:  CLRF   5E
05FA:  MOVLW  49
05FB:  MOVWF  04
05FC:  BSF    03.7
05FD:  MOVF   5D,W
05FE:  ADDWF  04,F
05FF:  MOVF   5E,W
0600:  BCF    03.6
0601:  CALL   209
0602:  MOVWF  00
0603:  IORLW  00
0604:  BTFSC  03.2
0605:  GOTO   60B
0606:  BSF    03.6
0607:  INCF   5E,F
0608:  INCF   5D,F
0609:  GOTO   5FA
060A:  BCF    03.6
....................     } 
....................  
....................     int text_length = strlen(difficultyText); // count characters 
....................     int pos_x = (128 - (text_length * 6)) / 2; // center text (6 px per char) 
060B:  MOVLW  01
060C:  BSF    03.6
060D:  MOVWF  5E
060E:  MOVLW  49
060F:  MOVWF  5D
*
062D:  MOVF   78,W
062E:  MOVWF  5B
062F:  BSF    03.5
0630:  MOVWF  12
0631:  MOVLW  06
0632:  MOVWF  13
0633:  BCF    03.5
0634:  BCF    03.6
0635:  CALL   248
0636:  MOVF   78,W
0637:  SUBLW  80
0638:  MOVWF  77
0639:  BCF    03.0
063A:  RRF    77,W
063B:  BSF    03.6
063C:  MOVWF  5C
....................  
....................     glcd_text57(pos_x, 32, difficultyText, 1, 1); // draw difficulty at y=32 centered 
063D:  MOVF   5C,W
063E:  MOVWF  5D
063F:  MOVLW  20
0640:  MOVWF  5E
0641:  MOVLW  01
0642:  MOVWF  60
0643:  MOVLW  49
0644:  MOVWF  5F
0645:  MOVLW  01
0646:  MOVWF  61
0647:  MOVWF  62
0648:  BCF    03.6
0649:  CALL   436
064A:  RETURN
.................... } 
....................  
.................... void selectDifficulty() { // lets user choose game difficulty 
....................     char title[] = "SELECT DIFFICULTY"; // title string 
*
06CC:  MOVLW  53
06CD:  BSF    03.6
06CE:  MOVWF  35
06CF:  MOVLW  45
06D0:  MOVWF  36
06D1:  MOVLW  4C
06D2:  MOVWF  37
06D3:  MOVLW  45
06D4:  MOVWF  38
06D5:  MOVLW  43
06D6:  MOVWF  39
06D7:  MOVLW  54
06D8:  MOVWF  3A
06D9:  MOVLW  20
06DA:  MOVWF  3B
06DB:  MOVLW  44
06DC:  MOVWF  3C
06DD:  MOVLW  49
06DE:  MOVWF  3D
06DF:  MOVLW  46
06E0:  MOVWF  3E
06E1:  MOVWF  3F
06E2:  MOVLW  49
06E3:  MOVWF  40
06E4:  MOVLW  43
06E5:  MOVWF  41
06E6:  MOVLW  55
06E7:  MOVWF  42
06E8:  MOVLW  4C
06E9:  MOVWF  43
06EA:  MOVLW  54
06EB:  MOVWF  44
06EC:  MOVLW  59
06ED:  MOVWF  45
06EE:  CLRF   46
....................     glcd_fillScreen(0); // clear screen 
06EF:  CLRF   49
06F0:  BCF    03.6
06F1:  CALL   271
....................     glcd_text57(13, 18, title, 1, 1); // draw title at top 
06F2:  MOVLW  0D
06F3:  BSF    03.6
06F4:  MOVWF  5D
06F5:  MOVLW  12
06F6:  MOVWF  5E
06F7:  MOVLW  01
06F8:  MOVWF  60
06F9:  MOVLW  35
06FA:  MOVWF  5F
06FB:  MOVLW  01
06FC:  MOVWF  61
06FD:  MOVWF  62
06FE:  BCF    03.6
06FF:  CALL   436
....................     displayDifficulty(difficulty_index); // show initial difficulty 
0700:  MOVF   71,W
0701:  BSF    03.6
0702:  MOVWF  48
0703:  BCF    03.6
0704:  CALL   5A5
....................  
....................     int1 prev_left = 0, prev_right = 0, prev_select = 0; // previous button states 
0705:  BSF    03.6
0706:  BCF    47.0
0707:  BCF    47.1
0708:  BCF    47.2
....................  
....................     while(TRUE) { // loop until selection is made 
....................       int1 curr_left = input(PIN_C4); // read left button 
....................       int1 curr_right = input(PIN_C3); // read right button 
....................       int1 curr_select = input(PIN_C5); // read select button 
0709:  BCF    03.6
070A:  BSF    26.4
070B:  MOVF   26,W
070C:  BSF    03.5
070D:  MOVWF  07
070E:  BCF    03.5
070F:  BSF    03.6
0710:  BCF    47.3
0711:  BCF    03.6
0712:  BTFSS  07.4
0713:  GOTO   717
0714:  BSF    03.6
0715:  BSF    47.3
0716:  BCF    03.6
0717:  BSF    26.3
0718:  MOVF   26,W
0719:  BSF    03.5
071A:  MOVWF  07
071B:  BCF    03.5
071C:  BSF    03.6
071D:  BCF    47.4
071E:  BCF    03.6
071F:  BTFSS  07.3
0720:  GOTO   724
0721:  BSF    03.6
0722:  BSF    47.4
0723:  BCF    03.6
0724:  BSF    26.5
0725:  MOVF   26,W
0726:  BSF    03.5
0727:  MOVWF  07
0728:  BCF    03.5
0729:  BSF    03.6
072A:  BCF    47.5
072B:  BCF    03.6
072C:  BTFSS  07.5
072D:  GOTO   731
072E:  BSF    03.6
072F:  BSF    47.5
0730:  BCF    03.6
....................  
....................       if (curr_right && !prev_right) { // detect right press 
0731:  BSF    03.6
0732:  BTFSS  47.4
0733:  GOTO   741
0734:  BTFSC  47.1
0735:  GOTO   741
....................           if (difficulty_index < 2) { // max index is 2 (hard) 
0736:  MOVF   71,W
0737:  SUBLW  01
0738:  BTFSS  03.0
0739:  GOTO   741
....................               difficulty_index++; // go to next difficulty 
073A:  INCF   71,F
....................               displayDifficulty(difficulty_index); // update screen 
073B:  MOVF   71,W
073C:  MOVWF  48
073D:  BCF    03.6
073E:  CALL   5A5
....................               short_beep(); // confirm with beep 
073F:  CALL   6C6
0740:  BSF    03.6
....................           } 
....................       } 
....................  
....................       if (curr_left && !prev_left) { // detect left press 
0741:  BTFSS  47.3
0742:  GOTO   74F
0743:  BTFSC  47.0
0744:  GOTO   74F
....................           if (difficulty_index > 0) { // min index is 0 (easy) 
0745:  MOVF   71,F
0746:  BTFSC  03.2
0747:  GOTO   74F
....................               difficulty_index--; // go to previous difficulty 
0748:  DECF   71,F
....................               displayDifficulty(difficulty_index); // update screen 
0749:  MOVF   71,W
074A:  MOVWF  48
074B:  BCF    03.6
074C:  CALL   5A5
....................               short_beep(); // confirm beep 
074D:  CALL   6C6
074E:  BSF    03.6
....................           } 
....................       } 
....................  
....................       if (curr_select && !prev_select) { // detect selection press 
074F:  BTFSS  47.5
0750:  GOTO   779
0751:  BTFSC  47.2
0752:  GOTO   779
....................           switch (difficulty_index) { // map index to speed 
0753:  MOVF   71,W
0754:  XORLW  00
0755:  BCF    03.6
0756:  BTFSC  03.2
0757:  GOTO   75F
0758:  XORLW  01
0759:  BTFSC  03.2
075A:  GOTO   764
075B:  XORLW  03
075C:  BTFSC  03.2
075D:  GOTO   769
075E:  GOTO   76D
....................             case 0: gameSettings.delay_time = 3; break; // easy = slowest 
075F:  MOVLW  FC
0760:  ANDWF  72,W
0761:  IORLW  03
0762:  MOVWF  72
0763:  GOTO   76D
....................             case 1: gameSettings.delay_time = 2; break; // medium = normal 
0764:  MOVLW  FC
0765:  ANDWF  72,W
0766:  IORLW  02
0767:  MOVWF  72
0768:  GOTO   76D
....................             case 2: gameSettings.delay_time = 1; break; // hard = fastest 
0769:  MOVLW  FC
076A:  ANDWF  72,W
076B:  IORLW  01
076C:  MOVWF  72
....................           } 
....................           short_beep(); // confirm beep 
076D:  CALL   6C6
....................           delay_ms(300); // wait before starting game 
076E:  MOVLW  02
076F:  BSF    03.6
0770:  MOVWF  48
0771:  MOVLW  96
0772:  MOVWF  52
0773:  BCF    03.6
0774:  CALL   364
0775:  BSF    03.6
0776:  DECFSZ 48,F
0777:  GOTO   771
....................           return; // exit selection screen 
0778:  GOTO   788
....................       } 
....................  
....................       prev_left = curr_left; // update previous states 
0779:  BCF    47.0
077A:  BTFSC  47.3
077B:  BSF    47.0
....................       prev_right = curr_right; 
077C:  BCF    47.1
077D:  BTFSC  47.4
077E:  BSF    47.1
....................       prev_select = curr_select; 
077F:  BCF    47.2
0780:  BTFSC  47.5
0781:  BSF    47.2
....................  
....................       delay_ms(50); // debounce delay 
0782:  MOVLW  32
0783:  MOVWF  52
0784:  BCF    03.6
0785:  CALL   364
0786:  GOTO   70A
0787:  BSF    03.6
....................     } 
0788:  BCF    03.6
0789:  BSF    0A.3
078A:  BCF    0A.4
078B:  GOTO   423 (RETURN)
.................... } 
....................  
.................... void main() { // entry point of the program 
*
0B92:  MOVF   03,W
0B93:  ANDLW  1F
0B94:  MOVWF  03
0B95:  MOVLW  FF
0B96:  MOVWF  26
0B97:  MOVLW  02
0B98:  MOVWF  67
0B99:  MOVLW  40
0B9A:  MOVWF  6A
0B9B:  CLRF   6B
0B9C:  MOVLW  02
0B9D:  MOVWF  6C
0B9E:  CLRF   6D
0B9F:  CLRF   6E
0BA0:  BSF    70.0
0BA1:  CLRF   71
0BA2:  BSF    03.5
0BA3:  BSF    1F.0
0BA4:  BSF    1F.1
0BA5:  BSF    1F.2
0BA6:  BCF    1F.3
0BA7:  MOVLW  07
0BA8:  MOVWF  1C
0BA9:  BCF    03.7
....................     output_high(BUZZER_PIN); // buzzer initially off (active-low) 
*
0BFA:  BSF    03.5
0BFB:  BCF    03.6
0BFC:  BCF    06.3
0BFD:  BCF    03.5
0BFE:  BSF    06.3
....................  
....................     glcd_init(ON); // initialize glcd 
0BFF:  MOVLW  01
0C00:  BSF    03.6
0C01:  MOVWF  35
0C02:  BCF    0A.3
0C03:  BCF    03.6
0C04:  GOTO   2EA
0C05:  BSF    0A.3
....................     glcd_fillScreen(0); // clear glcd screen 
0C06:  BSF    03.6
0C07:  CLRF   49
0C08:  BCF    0A.3
0C09:  BCF    03.6
0C0A:  CALL   271
0C0B:  BSF    0A.3
....................     delay_ms(500); // wait for stabilization 
0C0C:  MOVLW  02
0C0D:  BSF    03.6
0C0E:  MOVWF  35
0C0F:  MOVLW  FA
0C10:  MOVWF  52
0C11:  BCF    0A.3
0C12:  BCF    03.6
0C13:  CALL   364
0C14:  BSF    0A.3
0C15:  BSF    03.6
0C16:  DECFSZ 35,F
0C17:  GOTO   40F
....................  
.................... Start: // label for game restart 
....................     if (isFirstStart) { // only for first run 
0C18:  BTFSS  70.0
0C19:  GOTO   426
....................         showSplashScreen(); // show splash 
0C1A:  BCF    0A.3
0C1B:  BCF    03.6
0C1C:  GOTO   52F
0C1D:  BSF    0A.3
....................         screenWipeDown(); // visual effect 
0C1E:  BCF    0A.3
0C1F:  CALL   582
0C20:  BSF    0A.3
....................         selectDifficulty(); // choose difficulty 
0C21:  BCF    0A.3
0C22:  GOTO   6CC
0C23:  BSF    0A.3
....................         isFirstStart = 0; // disable intro on next runs 
0C24:  BCF    70.0
0C25:  BSF    03.6
....................     } 
....................  
....................     glcd_fillScreen(0); // clear screen 
0C26:  CLRF   49
0C27:  BCF    0A.3
0C28:  BCF    03.6
0C29:  CALL   271
0C2A:  BSF    0A.3
....................     drawGrid(); // draw game grid 
0C2B:  BCF    0A.3
0C2C:  CALL   78C
0C2D:  BSF    0A.3
....................     writeScore(); // show initial score 
0C2E:  CALL   124
....................     generateFood(); // place first food 
0C2F:  CALL   234
....................  
....................     for (i = 0; i < LENGTH_SNAKE; i++) { // init snake segments 
0C30:  CLRF   6F
0C31:  MOVF   6A,W
0C32:  SUBWF  6F,W
0C33:  BTFSC  03.0
0C34:  GOTO   48B
....................         setX(i, posX - i); // x position from head to tail 
0C35:  MOVF   6F,W
0C36:  SUBLW  1F
0C37:  BTFSS  03.0
0C38:  GOTO   441
0C39:  MOVLW  27
0C3A:  ADDWF  6F,W
0C3B:  MOVWF  04
0C3C:  BCF    03.7
0C3D:  MOVF   6F,W
0C3E:  SUBWF  6B,W
0C3F:  MOVWF  00
0C40:  GOTO   449
0C41:  MOVLW  20
0C42:  SUBWF  6F,W
0C43:  ADDLW  A0
0C44:  MOVWF  04
0C45:  BCF    03.7
0C46:  MOVF   6F,W
0C47:  SUBWF  6B,W
0C48:  MOVWF  00
....................         setY(i, posY); // y position constant 
0C49:  MOVF   6F,W
0C4A:  SUBLW  1F
0C4B:  BTFSS  03.0
0C4C:  GOTO   455
0C4D:  MOVLW  47
0C4E:  ADDWF  6F,W
0C4F:  MOVWF  04
0C50:  BCF    03.7
0C51:  MOVF   6C,W
0C52:  MOVWF  00
0C53:  MOVF   6C,W
0C54:  GOTO   45C
0C55:  MOVLW  20
0C56:  SUBWF  6F,W
0C57:  ADDLW  C0
0C58:  MOVWF  04
0C59:  BCF    03.7
0C5A:  MOVF   6C,W
0C5B:  MOVWF  00
....................         fillCell(getX(i), getY(i), 1); // draw segment 
0C5C:  MOVF   6F,W
0C5D:  SUBLW  1F
0C5E:  BTFSS  03.0
0C5F:  GOTO   466
0C60:  MOVLW  27
0C61:  ADDWF  6F,W
0C62:  MOVWF  04
0C63:  BCF    03.7
0C64:  MOVF   00,W
0C65:  GOTO   46C
0C66:  MOVLW  20
0C67:  SUBWF  6F,W
0C68:  ADDLW  A0
0C69:  MOVWF  04
0C6A:  BCF    03.7
0C6B:  MOVF   00,W
0C6C:  BSF    03.6
0C6D:  MOVWF  35
0C6E:  BCF    03.6
0C6F:  MOVF   6F,W
0C70:  SUBLW  1F
0C71:  BTFSS  03.0
0C72:  GOTO   479
0C73:  MOVLW  47
0C74:  ADDWF  6F,W
0C75:  MOVWF  04
0C76:  BCF    03.7
0C77:  MOVF   00,W
0C78:  GOTO   47F
0C79:  MOVLW  20
0C7A:  SUBWF  6F,W
0C7B:  ADDLW  C0
0C7C:  MOVWF  04
0C7D:  BCF    03.7
0C7E:  MOVF   00,W
0C7F:  BSF    03.6
0C80:  MOVWF  36
0C81:  MOVF   35,W
0C82:  MOVWF  37
0C83:  MOVF   36,W
0C84:  MOVWF  38
0C85:  MOVLW  01
0C86:  MOVWF  39
0C87:  BCF    03.6
0C88:  CALL   1E0
0C89:  INCF   6F,F
0C8A:  GOTO   431
....................     } 
....................  
....................     while (TRUE) { // main game loop 
....................         if (input(PIN_C3) && dir != 0) { dir = 3; short_beep(); } // right 
0C8B:  BSF    26.3
0C8C:  MOVF   26,W
0C8D:  BSF    03.5
0C8E:  MOVWF  07
0C8F:  BCF    03.5
0C90:  BTFSS  07.3
0C91:  GOTO   49A
0C92:  MOVF   67,F
0C93:  BTFSC  03.2
0C94:  GOTO   49A
0C95:  MOVLW  03
0C96:  MOVWF  67
0C97:  BCF    0A.3
0C98:  CALL   6C6
0C99:  BSF    0A.3
....................         if (input(PIN_C2) && dir != 1) { dir = 2; short_beep(); } // down 
0C9A:  BSF    26.2
0C9B:  MOVF   26,W
0C9C:  BSF    03.5
0C9D:  MOVWF  07
0C9E:  BCF    03.5
0C9F:  BTFSS  07.2
0CA0:  GOTO   4A9
0CA1:  DECFSZ 67,W
0CA2:  GOTO   4A4
0CA3:  GOTO   4A9
0CA4:  MOVLW  02
0CA5:  MOVWF  67
0CA6:  BCF    0A.3
0CA7:  CALL   6C6
0CA8:  BSF    0A.3
....................         if (input(PIN_C1) && dir != 2) { dir = 1; short_beep(); } // up 
0CA9:  BSF    26.1
0CAA:  MOVF   26,W
0CAB:  BSF    03.5
0CAC:  MOVWF  07
0CAD:  BCF    03.5
0CAE:  BTFSS  07.1
0CAF:  GOTO   4B9
0CB0:  MOVF   67,W
0CB1:  SUBLW  02
0CB2:  BTFSC  03.2
0CB3:  GOTO   4B9
0CB4:  MOVLW  01
0CB5:  MOVWF  67
0CB6:  BCF    0A.3
0CB7:  CALL   6C6
0CB8:  BSF    0A.3
....................         if (input(PIN_C4) && dir != 3) { dir = 0; short_beep(); } // left 
0CB9:  BSF    26.4
0CBA:  MOVF   26,W
0CBB:  BSF    03.5
0CBC:  MOVWF  07
0CBD:  BCF    03.5
0CBE:  BTFSS  07.4
0CBF:  GOTO   4C8
0CC0:  MOVF   67,W
0CC1:  SUBLW  03
0CC2:  BTFSC  03.2
0CC3:  GOTO   4C8
0CC4:  CLRF   67
0CC5:  BCF    0A.3
0CC6:  CALL   6C6
0CC7:  BSF    0A.3
....................         if (input(PIN_C5)) { gameover(); goto Start; } // reset button 
0CC8:  BSF    26.5
0CC9:  MOVF   26,W
0CCA:  BSF    03.5
0CCB:  MOVWF  07
0CCC:  BCF    03.5
0CCD:  BTFSS  07.5
0CCE:  GOTO   4D3
0CCF:  CALL   2A8
0CD0:  BSF    03.6
0CD1:  GOTO   418
0CD2:  BCF    03.6
....................  
....................         switch(dir) { // update head position 
0CD3:  MOVF   67,W
0CD4:  ADDLW  FC
0CD5:  BTFSC  03.0
0CD6:  GOTO   50A
0CD7:  ADDLW  04
0CD8:  GOTO   78B
....................             case 0: if (posX == 0) { gameover(); goto Start; } else posX--; break; 
0CD9:  MOVF   6B,F
0CDA:  BTFSS  03.2
0CDB:  GOTO   4E1
0CDC:  CALL   2A8
0CDD:  BSF    03.6
0CDE:  GOTO   418
0CDF:  GOTO   4E3
0CE0:  BCF    03.6
0CE1:  DECF   6B,F
0CE2:  BSF    03.6
0CE3:  BCF    03.6
0CE4:  GOTO   50A
....................             case 1: if (posY == 0) { gameover(); goto Start; } else posY--; break; 
0CE5:  MOVF   6C,F
0CE6:  BTFSS  03.2
0CE7:  GOTO   4ED
0CE8:  CALL   2A8
0CE9:  BSF    03.6
0CEA:  GOTO   418
0CEB:  GOTO   4EF
0CEC:  BCF    03.6
0CED:  DECF   6C,F
0CEE:  BSF    03.6
0CEF:  BCF    03.6
0CF0:  GOTO   50A
....................             case 2: if (posY == GRID_ROWS - 1) { gameover(); goto Start; } else posY++; break; 
0CF1:  MOVF   6C,W
0CF2:  SUBLW  09
0CF3:  BTFSS  03.2
0CF4:  GOTO   4FA
0CF5:  CALL   2A8
0CF6:  BSF    03.6
0CF7:  GOTO   418
0CF8:  GOTO   4FC
0CF9:  BCF    03.6
0CFA:  INCF   6C,F
0CFB:  BSF    03.6
0CFC:  BCF    03.6
0CFD:  GOTO   50A
....................             case 3: if (posX == GRID_COLS - 1) { gameover(); goto Start; } else posX++; break; 
0CFE:  MOVF   6B,W
0CFF:  SUBLW  09
0D00:  BTFSS  03.2
0D01:  GOTO   507
0D02:  CALL   2A8
0D03:  BSF    03.6
0D04:  GOTO   418
0D05:  GOTO   509
0D06:  BCF    03.6
0D07:  INCF   6B,F
0D08:  BSF    03.6
0D09:  BCF    03.6
....................         } 
....................  
....................         uchar tailX = getX(0), tailY = getY(0); // store tail position 
0D0A:  MOVF   27,W
0D0B:  BSF    03.6
0D0C:  MOVWF  31
0D0D:  BCF    03.6
0D0E:  MOVF   47,W
0D0F:  BSF    03.6
0D10:  MOVWF  32
....................         for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
0D11:  BCF    03.6
0D12:  CLRF   6F
0D13:  MOVLW  01
0D14:  SUBWF  6A,W
0D15:  SUBWF  6F,W
0D16:  BTFSC  03.0
0D17:  GOTO   5CC
....................             setX(i, getX(i + 1)); // shift x 
0D18:  MOVF   6F,W
0D19:  SUBLW  1F
0D1A:  BTFSS  03.0
0D1B:  GOTO   547
0D1C:  MOVLW  27
0D1D:  ADDWF  6F,W
0D1E:  MOVWF  78
0D1F:  CLRF   7A
0D20:  BTFSC  03.0
0D21:  INCF   7A,F
0D22:  MOVF   78,W
0D23:  BSF    03.6
0D24:  MOVWF  35
0D25:  MOVF   7A,W
0D26:  MOVWF  36
0D27:  MOVLW  01
0D28:  BCF    03.6
0D29:  ADDWF  6F,W
0D2A:  SUBLW  1F
0D2B:  BTFSS  03.0
0D2C:  GOTO   534
0D2D:  MOVLW  01
0D2E:  ADDWF  6F,W
0D2F:  ADDLW  27
0D30:  MOVWF  04
0D31:  BCF    03.7
0D32:  MOVF   00,W
0D33:  GOTO   53B
0D34:  MOVLW  01
0D35:  ADDWF  6F,W
0D36:  ADDLW  E0
0D37:  ADDLW  A0
0D38:  MOVWF  04
0D39:  BCF    03.7
0D3A:  MOVF   00,W
0D3B:  BSF    03.6
0D3C:  MOVWF  37
0D3D:  MOVF   35,W
0D3E:  MOVWF  04
0D3F:  BCF    03.7
0D40:  BTFSC  36.0
0D41:  BSF    03.7
0D42:  MOVF   37,W
0D43:  MOVWF  00
0D44:  MOVF   37,W
0D45:  GOTO   570
0D46:  BCF    03.6
0D47:  MOVLW  20
0D48:  SUBWF  6F,W
0D49:  ADDLW  A0
0D4A:  MOVWF  78
0D4B:  CLRF   7A
0D4C:  BTFSC  03.0
0D4D:  INCF   7A,F
0D4E:  MOVF   78,W
0D4F:  BSF    03.6
0D50:  MOVWF  37
0D51:  MOVF   7A,W
0D52:  MOVWF  38
0D53:  MOVLW  01
0D54:  BCF    03.6
0D55:  ADDWF  6F,W
0D56:  SUBLW  1F
0D57:  BTFSS  03.0
0D58:  GOTO   560
0D59:  MOVLW  01
0D5A:  ADDWF  6F,W
0D5B:  ADDLW  27
0D5C:  MOVWF  04
0D5D:  BCF    03.7
0D5E:  MOVF   00,W
0D5F:  GOTO   567
0D60:  MOVLW  01
0D61:  ADDWF  6F,W
0D62:  ADDLW  E0
0D63:  ADDLW  A0
0D64:  MOVWF  04
0D65:  BCF    03.7
0D66:  MOVF   00,W
0D67:  BSF    03.6
0D68:  MOVWF  35
0D69:  MOVF   37,W
0D6A:  MOVWF  04
0D6B:  BCF    03.7
0D6C:  BTFSC  38.0
0D6D:  BSF    03.7
0D6E:  MOVF   35,W
0D6F:  MOVWF  00
....................             setY(i, getY(i + 1)); // shift y 
0D70:  BCF    03.6
0D71:  MOVF   6F,W
0D72:  SUBLW  1F
0D73:  BTFSS  03.0
0D74:  GOTO   5A0
0D75:  MOVLW  47
0D76:  ADDWF  6F,W
0D77:  MOVWF  78
0D78:  CLRF   7A
0D79:  BTFSC  03.0
0D7A:  INCF   7A,F
0D7B:  MOVF   78,W
0D7C:  BSF    03.6
0D7D:  MOVWF  35
0D7E:  MOVF   7A,W
0D7F:  MOVWF  36
0D80:  MOVLW  01
0D81:  BCF    03.6
0D82:  ADDWF  6F,W
0D83:  SUBLW  1F
0D84:  BTFSS  03.0
0D85:  GOTO   58D
0D86:  MOVLW  01
0D87:  ADDWF  6F,W
0D88:  ADDLW  47
0D89:  MOVWF  04
0D8A:  BCF    03.7
0D8B:  MOVF   00,W
0D8C:  GOTO   594
0D8D:  MOVLW  01
0D8E:  ADDWF  6F,W
0D8F:  ADDLW  E0
0D90:  ADDLW  C0
0D91:  MOVWF  04
0D92:  BCF    03.7
0D93:  MOVF   00,W
0D94:  BSF    03.6
0D95:  MOVWF  37
0D96:  MOVF   35,W
0D97:  MOVWF  04
0D98:  BCF    03.7
0D99:  BTFSC  36.0
0D9A:  BSF    03.7
0D9B:  MOVF   37,W
0D9C:  MOVWF  00
0D9D:  MOVF   37,W
0D9E:  GOTO   5C9
0D9F:  BCF    03.6
0DA0:  MOVLW  20
0DA1:  SUBWF  6F,W
0DA2:  ADDLW  C0
0DA3:  MOVWF  78
0DA4:  CLRF   7A
0DA5:  BTFSC  03.0
0DA6:  INCF   7A,F
0DA7:  MOVF   78,W
0DA8:  BSF    03.6
0DA9:  MOVWF  37
0DAA:  MOVF   7A,W
0DAB:  MOVWF  38
0DAC:  MOVLW  01
0DAD:  BCF    03.6
0DAE:  ADDWF  6F,W
0DAF:  SUBLW  1F
0DB0:  BTFSS  03.0
0DB1:  GOTO   5B9
0DB2:  MOVLW  01
0DB3:  ADDWF  6F,W
0DB4:  ADDLW  47
0DB5:  MOVWF  04
0DB6:  BCF    03.7
0DB7:  MOVF   00,W
0DB8:  GOTO   5C0
0DB9:  MOVLW  01
0DBA:  ADDWF  6F,W
0DBB:  ADDLW  E0
0DBC:  ADDLW  C0
0DBD:  MOVWF  04
0DBE:  BCF    03.7
0DBF:  MOVF   00,W
0DC0:  BSF    03.6
0DC1:  MOVWF  35
0DC2:  MOVF   37,W
0DC3:  MOVWF  04
0DC4:  BCF    03.7
0DC5:  BTFSC  38.0
0DC6:  BSF    03.7
0DC7:  MOVF   35,W
0DC8:  MOVWF  00
0DC9:  BCF    03.6
0DCA:  INCF   6F,F
0DCB:  GOTO   513
....................         } 
....................         setX(LENGTH_SNAKE - 1, posX); // new head x 
0DCC:  MOVLW  01
0DCD:  SUBWF  6A,W
0DCE:  SUBLW  1F
0DCF:  BTFSS  03.0
0DD0:  GOTO   5DA
0DD1:  MOVLW  01
0DD2:  SUBWF  6A,W
0DD3:  ADDLW  27
0DD4:  MOVWF  04
0DD5:  BCF    03.7
0DD6:  MOVF   6B,W
0DD7:  MOVWF  00
0DD8:  MOVF   6B,W
0DD9:  GOTO   5E2
0DDA:  MOVLW  01
0DDB:  SUBWF  6A,W
0DDC:  ADDLW  E0
0DDD:  ADDLW  A0
0DDE:  MOVWF  04
0DDF:  BCF    03.7
0DE0:  MOVF   6B,W
0DE1:  MOVWF  00
....................         setY(LENGTH_SNAKE - 1, posY); // new head y 
0DE2:  MOVLW  01
0DE3:  SUBWF  6A,W
0DE4:  SUBLW  1F
0DE5:  BTFSS  03.0
0DE6:  GOTO   5F0
0DE7:  MOVLW  01
0DE8:  SUBWF  6A,W
0DE9:  ADDLW  47
0DEA:  MOVWF  04
0DEB:  BCF    03.7
0DEC:  MOVF   6C,W
0DED:  MOVWF  00
0DEE:  MOVF   6C,W
0DEF:  GOTO   5F8
0DF0:  MOVLW  01
0DF1:  SUBWF  6A,W
0DF2:  ADDLW  E0
0DF3:  ADDLW  C0
0DF4:  MOVWF  04
0DF5:  BCF    03.7
0DF6:  MOVF   6C,W
0DF7:  MOVWF  00
....................  
....................         for (i = 0; i < LENGTH_SNAKE - 1; i++) { // check self-collision 
0DF8:  CLRF   6F
0DF9:  MOVLW  01
0DFA:  SUBWF  6A,W
0DFB:  SUBWF  6F,W
0DFC:  BTFSC  03.0
0DFD:  GOTO   62A
....................             if (getX(i) == posX && getY(i) == posY) { 
0DFE:  MOVF   6F,W
0DFF:  SUBLW  1F
0E00:  BTFSS  03.0
0E01:  GOTO   608
0E02:  MOVLW  27
0E03:  ADDWF  6F,W
0E04:  MOVWF  04
0E05:  BCF    03.7
0E06:  MOVF   00,W
0E07:  GOTO   60E
0E08:  MOVLW  20
0E09:  SUBWF  6F,W
0E0A:  ADDLW  A0
0E0B:  MOVWF  04
0E0C:  BCF    03.7
0E0D:  MOVF   00,W
0E0E:  SUBWF  6B,W
0E0F:  BTFSS  03.2
0E10:  GOTO   628
0E11:  MOVF   6F,W
0E12:  SUBLW  1F
0E13:  BTFSS  03.0
0E14:  GOTO   61B
0E15:  MOVLW  47
0E16:  ADDWF  6F,W
0E17:  MOVWF  04
0E18:  BCF    03.7
0E19:  MOVF   00,W
0E1A:  GOTO   621
0E1B:  MOVLW  20
0E1C:  SUBWF  6F,W
0E1D:  ADDLW  C0
0E1E:  MOVWF  04
0E1F:  BCF    03.7
0E20:  MOVF   00,W
0E21:  SUBWF  6C,W
0E22:  BTFSS  03.2
0E23:  GOTO   628
....................                 gameover(); goto Start; 
0E24:  CALL   2A8
0E25:  BSF    03.6
0E26:  GOTO   418
0E27:  BCF    03.6
....................             } 
0E28:  INCF   6F,F
0E29:  GOTO   5F9
....................         } 
....................  
....................         fillCell(posX, posY, 1); // draw new head 
0E2A:  MOVF   6B,W
0E2B:  BSF    03.6
0E2C:  MOVWF  37
0E2D:  BCF    03.6
0E2E:  MOVF   6C,W
0E2F:  BSF    03.6
0E30:  MOVWF  38
0E31:  MOVLW  01
0E32:  MOVWF  39
0E33:  BCF    03.6
0E34:  CALL   1E0
....................         fillCell(tailX, tailY, 0); // clear old tail 
0E35:  BSF    03.6
0E36:  MOVF   31,W
0E37:  MOVWF  37
0E38:  MOVF   32,W
0E39:  MOVWF  38
0E3A:  CLRF   39
0E3B:  BCF    03.6
0E3C:  CALL   1E0
....................  
....................         if (posX == food[0] && posY == food[1]) { // food eaten 
0E3D:  MOVF   68,W
0E3E:  SUBWF  6B,W
0E3F:  BTFSS  03.2
0E40:  GOTO   761
0E41:  MOVF   69,W
0E42:  SUBWF  6C,W
0E43:  BTFSS  03.2
0E44:  GOTO   761
....................             buzzer_beep(100); // eat sound 
0E45:  MOVLW  64
0E46:  BSF    03.6
0E47:  MOVWF  4F
0E48:  BCF    0A.3
0E49:  BCF    03.6
0E4A:  CALL   689
0E4B:  BSF    0A.3
....................             // store old tail before growing 
....................             uchar oldTailX = getX(0); 
....................             uchar oldTailY = getY(0); 
0E4C:  MOVF   27,W
0E4D:  BSF    03.6
0E4E:  MOVWF  33
0E4F:  BCF    03.6
0E50:  MOVF   47,W
0E51:  BSF    03.6
0E52:  MOVWF  34
....................        
....................             if (LENGTH_SNAKE >= 64) { 
0E53:  BCF    03.6
0E54:  MOVF   6A,W
0E55:  SUBLW  3F
0E56:  BTFSC  03.0
0E57:  GOTO   65C
....................                 winScreen(); 
0E58:  GOTO   33B
....................                 goto Start; 
0E59:  BSF    03.6
0E5A:  GOTO   418
0E5B:  BCF    03.6
....................             } 
....................  
....................             LENGTH_SNAKE++; // grow snake 
0E5C:  INCF   6A,F
....................             // insert new segment at old tail position 
....................             for (i = LENGTH_SNAKE - 1; i > 0; i--) { 
0E5D:  MOVLW  01
0E5E:  SUBWF  6A,W
0E5F:  MOVWF  6F
0E60:  MOVF   6F,F
0E61:  BTFSC  03.2
0E62:  GOTO   717
....................                 setX(i, getX(i - 1)); 
0E63:  MOVF   6F,W
0E64:  SUBLW  1F
0E65:  BTFSS  03.0
0E66:  GOTO   692
0E67:  MOVLW  27
0E68:  ADDWF  6F,W
0E69:  MOVWF  78
0E6A:  CLRF   7A
0E6B:  BTFSC  03.0
0E6C:  INCF   7A,F
0E6D:  MOVF   78,W
0E6E:  BSF    03.6
0E6F:  MOVWF  35
0E70:  MOVF   7A,W
0E71:  MOVWF  36
0E72:  MOVLW  01
0E73:  BCF    03.6
0E74:  SUBWF  6F,W
0E75:  SUBLW  1F
0E76:  BTFSS  03.0
0E77:  GOTO   67F
0E78:  MOVLW  01
0E79:  SUBWF  6F,W
0E7A:  ADDLW  27
0E7B:  MOVWF  04
0E7C:  BCF    03.7
0E7D:  MOVF   00,W
0E7E:  GOTO   686
0E7F:  MOVLW  01
0E80:  SUBWF  6F,W
0E81:  ADDLW  E0
0E82:  ADDLW  A0
0E83:  MOVWF  04
0E84:  BCF    03.7
0E85:  MOVF   00,W
0E86:  BSF    03.6
0E87:  MOVWF  37
0E88:  MOVF   35,W
0E89:  MOVWF  04
0E8A:  BCF    03.7
0E8B:  BTFSC  36.0
0E8C:  BSF    03.7
0E8D:  MOVF   37,W
0E8E:  MOVWF  00
0E8F:  MOVF   37,W
0E90:  GOTO   6BB
0E91:  BCF    03.6
0E92:  MOVLW  20
0E93:  SUBWF  6F,W
0E94:  ADDLW  A0
0E95:  MOVWF  78
0E96:  CLRF   7A
0E97:  BTFSC  03.0
0E98:  INCF   7A,F
0E99:  MOVF   78,W
0E9A:  BSF    03.6
0E9B:  MOVWF  37
0E9C:  MOVF   7A,W
0E9D:  MOVWF  38
0E9E:  MOVLW  01
0E9F:  BCF    03.6
0EA0:  SUBWF  6F,W
0EA1:  SUBLW  1F
0EA2:  BTFSS  03.0
0EA3:  GOTO   6AB
0EA4:  MOVLW  01
0EA5:  SUBWF  6F,W
0EA6:  ADDLW  27
0EA7:  MOVWF  04
0EA8:  BCF    03.7
0EA9:  MOVF   00,W
0EAA:  GOTO   6B2
0EAB:  MOVLW  01
0EAC:  SUBWF  6F,W
0EAD:  ADDLW  E0
0EAE:  ADDLW  A0
0EAF:  MOVWF  04
0EB0:  BCF    03.7
0EB1:  MOVF   00,W
0EB2:  BSF    03.6
0EB3:  MOVWF  35
0EB4:  MOVF   37,W
0EB5:  MOVWF  04
0EB6:  BCF    03.7
0EB7:  BTFSC  38.0
0EB8:  BSF    03.7
0EB9:  MOVF   35,W
0EBA:  MOVWF  00
....................                 setY(i, getY(i - 1)); 
0EBB:  BCF    03.6
0EBC:  MOVF   6F,W
0EBD:  SUBLW  1F
0EBE:  BTFSS  03.0
0EBF:  GOTO   6EB
0EC0:  MOVLW  47
0EC1:  ADDWF  6F,W
0EC2:  MOVWF  78
0EC3:  CLRF   7A
0EC4:  BTFSC  03.0
0EC5:  INCF   7A,F
0EC6:  MOVF   78,W
0EC7:  BSF    03.6
0EC8:  MOVWF  35
0EC9:  MOVF   7A,W
0ECA:  MOVWF  36
0ECB:  MOVLW  01
0ECC:  BCF    03.6
0ECD:  SUBWF  6F,W
0ECE:  SUBLW  1F
0ECF:  BTFSS  03.0
0ED0:  GOTO   6D8
0ED1:  MOVLW  01
0ED2:  SUBWF  6F,W
0ED3:  ADDLW  47
0ED4:  MOVWF  04
0ED5:  BCF    03.7
0ED6:  MOVF   00,W
0ED7:  GOTO   6DF
0ED8:  MOVLW  01
0ED9:  SUBWF  6F,W
0EDA:  ADDLW  E0
0EDB:  ADDLW  C0
0EDC:  MOVWF  04
0EDD:  BCF    03.7
0EDE:  MOVF   00,W
0EDF:  BSF    03.6
0EE0:  MOVWF  37
0EE1:  MOVF   35,W
0EE2:  MOVWF  04
0EE3:  BCF    03.7
0EE4:  BTFSC  36.0
0EE5:  BSF    03.7
0EE6:  MOVF   37,W
0EE7:  MOVWF  00
0EE8:  MOVF   37,W
0EE9:  GOTO   714
0EEA:  BCF    03.6
0EEB:  MOVLW  20
0EEC:  SUBWF  6F,W
0EED:  ADDLW  C0
0EEE:  MOVWF  78
0EEF:  CLRF   7A
0EF0:  BTFSC  03.0
0EF1:  INCF   7A,F
0EF2:  MOVF   78,W
0EF3:  BSF    03.6
0EF4:  MOVWF  37
0EF5:  MOVF   7A,W
0EF6:  MOVWF  38
0EF7:  MOVLW  01
0EF8:  BCF    03.6
0EF9:  SUBWF  6F,W
0EFA:  SUBLW  1F
0EFB:  BTFSS  03.0
0EFC:  GOTO   704
0EFD:  MOVLW  01
0EFE:  SUBWF  6F,W
0EFF:  ADDLW  47
0F00:  MOVWF  04
0F01:  BCF    03.7
0F02:  MOVF   00,W
0F03:  GOTO   70B
0F04:  MOVLW  01
0F05:  SUBWF  6F,W
0F06:  ADDLW  E0
0F07:  ADDLW  C0
0F08:  MOVWF  04
0F09:  BCF    03.7
0F0A:  MOVF   00,W
0F0B:  BSF    03.6
0F0C:  MOVWF  35
0F0D:  MOVF   37,W
0F0E:  MOVWF  04
0F0F:  BCF    03.7
0F10:  BTFSC  38.0
0F11:  BSF    03.7
0F12:  MOVF   35,W
0F13:  MOVWF  00
0F14:  BCF    03.6
0F15:  DECF   6F,F
0F16:  GOTO   660
....................             } 
....................             setX(0, oldTailX); 
0F17:  BSF    03.6
0F18:  MOVF   33,W
0F19:  BCF    03.6
0F1A:  MOVWF  27
....................             setY(0, oldTailY); 
0F1B:  BSF    03.6
0F1C:  MOVF   34,W
0F1D:  BCF    03.6
0F1E:  MOVWF  47
....................             fillCell(oldTailX, oldTailY, 1); // draw new segment immediately 
0F1F:  BSF    03.6
0F20:  MOVF   33,W
0F21:  MOVWF  37
0F22:  MOVF   34,W
0F23:  MOVWF  38
0F24:  MOVLW  01
0F25:  MOVWF  39
0F26:  BCF    03.6
0F27:  CALL   1E0
....................             generateFood(); // new food 
0F28:  CALL   234
....................             score++; // update score 
0F29:  INCF   6D,F
....................             score_txt[7] = '0' + (score / 10); 
0F2A:  MOVF   6D,W
0F2B:  BSF    03.6
0F2C:  MOVWF  35
0F2D:  MOVLW  0A
0F2E:  MOVWF  36
0F2F:  BCF    03.6
0F30:  CALL   37B
0F31:  MOVF   78,W
0F32:  ADDLW  30
0F33:  BSF    03.5
0F34:  MOVWF  67
....................             score_txt[8] = '0' + (score % 10); 
0F35:  BCF    03.5
0F36:  MOVF   6D,W
0F37:  BSF    03.6
0F38:  MOVWF  35
0F39:  MOVLW  0A
0F3A:  MOVWF  36
0F3B:  BCF    03.6
0F3C:  CALL   37B
0F3D:  MOVF   77,W
0F3E:  ADDLW  30
0F3F:  BSF    03.5
0F40:  MOVWF  68
....................        
....................             if (score > best_score) { 
0F41:  BCF    03.5
0F42:  MOVF   6D,W
0F43:  SUBWF  6E,W
0F44:  BTFSC  03.0
0F45:  GOTO   760
....................                 best_score = score; 
0F46:  MOVF   6D,W
0F47:  MOVWF  6E
....................                 best_score_txt[7] = '0' + (best_score / 10); 
0F48:  MOVF   6E,W
0F49:  BSF    03.6
0F4A:  MOVWF  35
0F4B:  MOVLW  0A
0F4C:  MOVWF  36
0F4D:  BCF    03.6
0F4E:  CALL   37B
0F4F:  MOVF   78,W
0F50:  ADDLW  30
0F51:  BSF    03.6
0F52:  MOVWF  17
....................                 best_score_txt[8] = '0' + (best_score % 10); 
0F53:  BCF    03.6
0F54:  MOVF   6E,W
0F55:  BSF    03.6
0F56:  MOVWF  35
0F57:  MOVLW  0A
0F58:  MOVWF  36
0F59:  BCF    03.6
0F5A:  CALL   37B
0F5B:  MOVF   77,W
0F5C:  ADDLW  30
0F5D:  BSF    03.6
0F5E:  MOVWF  18
0F5F:  BCF    03.6
....................             } 
....................        
....................             writeScore(); // update display 
0F60:  CALL   124
....................         } 
....................         delay_ms(gameSettings.delay_time * 300); // control speed (if I divide by LENGTH_SNAKE, the game gets harder 
0F61:  MOVF   72,W
0F62:  ANDLW  03
0F63:  BSF    03.6
0F64:  MOVWF  36
0F65:  CLRF   53
0F66:  MOVF   36,W
0F67:  MOVWF  52
0F68:  MOVLW  01
0F69:  MOVWF  55
0F6A:  MOVLW  2C
0F6B:  MOVWF  54
0F6C:  BCF    0A.3
0F6D:  BCF    03.6
0F6E:  CALL   64B
0F6F:  BSF    0A.3
0F70:  MOVF   79,W
0F71:  BSF    03.6
0F72:  MOVWF  36
0F73:  MOVF   78,W
0F74:  MOVWF  35
0F75:  MOVF   36,W
0F76:  MOVWF  37
0F77:  INCF   37,F
0F78:  DECF   37,F
0F79:  BTFSC  03.2
0F7A:  GOTO   783
0F7B:  MOVLW  FF
0F7C:  MOVWF  52
0F7D:  BCF    0A.3
0F7E:  BCF    03.6
0F7F:  CALL   364
0F80:  BSF    0A.3
0F81:  BSF    03.6
0F82:  GOTO   778
0F83:  MOVF   35,W
0F84:  MOVWF  52
0F85:  BCF    0A.3
0F86:  BCF    03.6
0F87:  CALL   364
0F88:  BSF    0A.3
0F89:  GOTO   48B
....................     } 
.................... } 
....................  
0F8A:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
