CCS PCM C Compiler, Version 5.025, 5967               30-May-25 15:34

               Filename:   C:\Users\Eren\Documents\CCS C Projects\snake_project\main.lst

               ROM used:   3105 words (38%)
                           Largest free fragment is 2048
               RAM used:   281 (76%) at main() level
                           305 (83%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   0EC
0003:  NOP
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDLW  0B
0008:  BTFSC  03.0
0009:  INCF   0A,F
000A:  MOVWF  02
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  5F
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  03
0017:  RETLW  00
0018:  RETLW  03
0019:  RETLW  00
001A:  RETLW  14
001B:  RETLW  3E
001C:  RETLW  14
001D:  RETLW  3E
001E:  RETLW  14
001F:  RETLW  24
0020:  RETLW  2A
0021:  RETLW  7F
0022:  RETLW  2A
0023:  RETLW  12
0024:  RETLW  43
0025:  RETLW  33
0026:  RETLW  08
0027:  RETLW  66
0028:  RETLW  61
0029:  RETLW  36
002A:  RETLW  49
002B:  RETLW  55
002C:  RETLW  22
002D:  RETLW  50
002E:  RETLW  00
002F:  RETLW  05
0030:  RETLW  03
0031:  RETLW  00
0032:  RETLW  00
0033:  RETLW  00
0034:  RETLW  1C
0035:  RETLW  22
0036:  RETLW  41
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  41
003A:  RETLW  22
003B:  RETLW  1C
003C:  RETLW  00
003D:  RETLW  14
003E:  RETLW  08
003F:  RETLW  3E
0040:  RETLW  08
0041:  RETLW  14
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  3E
0045:  RETLW  08
0046:  RETLW  08
0047:  RETLW  00
0048:  RETLW  50
0049:  RETLW  30
004A:  RETLW  00
004B:  RETLW  00
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  08
004F:  RETLW  08
0050:  RETLW  08
0051:  RETLW  00
0052:  RETLW  60
0053:  RETLW  60
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  20
0057:  RETLW  10
0058:  RETLW  08
0059:  RETLW  04
005A:  RETLW  02
005B:  RETLW  3E
005C:  RETLW  51
005D:  RETLW  49
005E:  RETLW  45
005F:  RETLW  3E
0060:  RETLW  04
0061:  RETLW  02
0062:  RETLW  7F
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  61
0067:  RETLW  51
0068:  RETLW  49
0069:  RETLW  46
006A:  RETLW  22
006B:  RETLW  41
006C:  RETLW  49
006D:  RETLW  49
006E:  RETLW  36
006F:  RETLW  18
0070:  RETLW  14
0071:  RETLW  12
0072:  RETLW  7F
0073:  RETLW  10
0074:  RETLW  27
0075:  RETLW  45
0076:  RETLW  45
0077:  RETLW  45
0078:  RETLW  39
0079:  RETLW  3E
007A:  RETLW  49
007B:  RETLW  49
007C:  RETLW  49
007D:  RETLW  32
007E:  RETLW  01
007F:  RETLW  01
0080:  RETLW  71
0081:  RETLW  09
0082:  RETLW  07
0083:  RETLW  36
0084:  RETLW  49
0085:  RETLW  49
0086:  RETLW  49
0087:  RETLW  36
0088:  RETLW  26
0089:  RETLW  49
008A:  RETLW  49
008B:  RETLW  49
008C:  RETLW  3E
008D:  RETLW  00
008E:  RETLW  36
008F:  RETLW  36
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  56
0094:  RETLW  36
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  08
0098:  RETLW  14
0099:  RETLW  22
009A:  RETLW  41
009B:  RETLW  00
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  14
009F:  RETLW  14
00A0:  RETLW  14
00A1:  RETLW  00
00A2:  RETLW  41
00A3:  RETLW  22
00A4:  RETLW  14
00A5:  RETLW  08
00A6:  RETLW  02
00A7:  RETLW  01
00A8:  RETLW  51
00A9:  RETLW  09
00AA:  RETLW  06
00AB:  RETLW  3E
00AC:  RETLW  41
00AD:  RETLW  59
00AE:  RETLW  55
00AF:  RETLW  5E
00B0:  RETLW  7E
00B1:  RETLW  09
00B2:  RETLW  09
00B3:  RETLW  09
00B4:  RETLW  7E
00B5:  RETLW  7F
00B6:  RETLW  49
00B7:  RETLW  49
00B8:  RETLW  49
00B9:  RETLW  36
00BA:  RETLW  3E
00BB:  RETLW  41
00BC:  RETLW  41
00BD:  RETLW  41
00BE:  RETLW  22
00BF:  RETLW  7F
00C0:  RETLW  41
00C1:  RETLW  41
00C2:  RETLW  41
00C3:  RETLW  3E
00C4:  RETLW  7F
00C5:  RETLW  49
00C6:  RETLW  49
00C7:  RETLW  49
00C8:  RETLW  41
00C9:  RETLW  7F
00CA:  RETLW  09
00CB:  RETLW  09
00CC:  RETLW  09
00CD:  RETLW  01
00CE:  RETLW  3E
00CF:  RETLW  41
00D0:  RETLW  41
00D1:  RETLW  49
00D2:  RETLW  3A
00D3:  RETLW  7F
00D4:  RETLW  08
00D5:  RETLW  08
00D6:  RETLW  08
00D7:  RETLW  7F
00D8:  RETLW  00
00D9:  RETLW  41
00DA:  RETLW  7F
00DB:  RETLW  41
00DC:  RETLW  00
00DD:  RETLW  30
00DE:  RETLW  40
00DF:  RETLW  40
00E0:  RETLW  40
00E1:  RETLW  3F
00E2:  RETLW  7F
00E3:  RETLW  08
00E4:  RETLW  14
00E5:  RETLW  22
00E6:  RETLW  41
00E7:  RETLW  7F
00E8:  RETLW  40
00E9:  RETLW  40
00EA:  RETLW  40
00EB:  RETLW  40
00EC:  RETLW  7F
00ED:  RETLW  02
00EE:  RETLW  0C
00EF:  RETLW  02
00F0:  RETLW  7F
00F1:  RETLW  7F
00F2:  RETLW  02
00F3:  RETLW  04
00F4:  RETLW  08
00F5:  RETLW  7F
00F6:  RETLW  3E
00F7:  RETLW  41
00F8:  RETLW  41
00F9:  RETLW  41
00FA:  RETLW  3E
00FB:  RETLW  7F
00FC:  RETLW  09
00FD:  RETLW  09
00FE:  RETLW  09
00FF:  RETLW  06
0100:  RETLW  1E
0101:  RETLW  21
0102:  RETLW  21
0103:  RETLW  21
0104:  RETLW  5E
0105:  RETLW  7F
0106:  RETLW  09
0107:  RETLW  09
0108:  RETLW  09
0109:  RETLW  76
010A:  BSF    0A.0
010B:  BCF    0A.1
010C:  BCF    0A.2
010D:  ADDWF  02,F
010E:  RETLW  26
010F:  RETLW  49
0110:  RETLW  49
0111:  RETLW  49
0112:  RETLW  32
0113:  RETLW  01
0114:  RETLW  01
0115:  RETLW  7F
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  3F
0119:  RETLW  40
011A:  RETLW  40
011B:  RETLW  40
011C:  RETLW  3F
011D:  RETLW  1F
011E:  RETLW  20
011F:  RETLW  40
0120:  RETLW  20
0121:  RETLW  1F
0122:  RETLW  7F
0123:  RETLW  20
0124:  RETLW  10
0125:  RETLW  20
0126:  RETLW  7F
0127:  RETLW  41
0128:  RETLW  22
0129:  RETLW  1C
012A:  RETLW  22
012B:  RETLW  41
012C:  RETLW  07
012D:  RETLW  08
012E:  RETLW  70
012F:  RETLW  08
0130:  RETLW  07
0131:  RETLW  61
0132:  RETLW  51
0133:  RETLW  49
0134:  RETLW  45
0135:  RETLW  43
0136:  RETLW  00
0137:  RETLW  7F
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  02
013C:  RETLW  04
013D:  RETLW  08
013E:  RETLW  10
013F:  RETLW  20
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  41
0143:  RETLW  7F
0144:  RETLW  00
0145:  RETLW  04
0146:  RETLW  02
0147:  RETLW  01
0148:  RETLW  02
0149:  RETLW  04
014A:  RETLW  40
014B:  RETLW  40
014C:  RETLW  40
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  00
0150:  RETLW  01
0151:  RETLW  02
0152:  RETLW  04
0153:  RETLW  00
0154:  RETLW  20
0155:  RETLW  54
0156:  RETLW  54
0157:  RETLW  54
0158:  RETLW  78
0159:  RETLW  7F
015A:  RETLW  44
015B:  RETLW  44
015C:  RETLW  44
015D:  RETLW  38
015E:  RETLW  38
015F:  RETLW  44
0160:  RETLW  44
0161:  RETLW  44
0162:  RETLW  44
0163:  RETLW  38
0164:  RETLW  44
0165:  RETLW  44
0166:  RETLW  44
0167:  RETLW  7F
0168:  RETLW  38
0169:  RETLW  54
016A:  RETLW  54
016B:  RETLW  54
016C:  RETLW  18
016D:  RETLW  04
016E:  RETLW  04
016F:  RETLW  7E
0170:  RETLW  05
0171:  RETLW  05
0172:  RETLW  08
0173:  RETLW  54
0174:  RETLW  54
0175:  RETLW  54
0176:  RETLW  3C
0177:  RETLW  7F
0178:  RETLW  08
0179:  RETLW  04
017A:  RETLW  04
017B:  RETLW  78
017C:  RETLW  00
017D:  RETLW  44
017E:  RETLW  7D
017F:  RETLW  40
0180:  RETLW  00
0181:  RETLW  20
0182:  RETLW  40
0183:  RETLW  44
0184:  RETLW  3D
0185:  RETLW  00
0186:  RETLW  7F
0187:  RETLW  10
0188:  RETLW  28
0189:  RETLW  44
018A:  RETLW  00
018B:  RETLW  00
018C:  RETLW  41
018D:  RETLW  7F
018E:  RETLW  40
018F:  RETLW  00
0190:  RETLW  7C
0191:  RETLW  04
0192:  RETLW  78
0193:  RETLW  04
0194:  RETLW  78
0195:  RETLW  7C
0196:  RETLW  08
0197:  RETLW  04
0198:  RETLW  04
0199:  RETLW  78
019A:  RETLW  38
019B:  RETLW  44
019C:  RETLW  44
019D:  RETLW  44
019E:  RETLW  38
019F:  RETLW  7C
01A0:  RETLW  14
01A1:  RETLW  14
01A2:  RETLW  14
01A3:  RETLW  08
01A4:  RETLW  08
01A5:  RETLW  14
01A6:  RETLW  14
01A7:  RETLW  14
01A8:  RETLW  7C
01A9:  RETLW  00
01AA:  RETLW  7C
01AB:  RETLW  08
01AC:  RETLW  04
01AD:  RETLW  04
01AE:  RETLW  48
01AF:  RETLW  54
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  20
01B3:  RETLW  04
01B4:  RETLW  04
01B5:  RETLW  3F
01B6:  RETLW  44
01B7:  RETLW  44
01B8:  RETLW  3C
01B9:  RETLW  40
01BA:  RETLW  40
01BB:  RETLW  20
01BC:  RETLW  7C
01BD:  RETLW  1C
01BE:  RETLW  20
01BF:  RETLW  40
01C0:  RETLW  20
01C1:  RETLW  1C
01C2:  RETLW  3C
01C3:  RETLW  40
01C4:  RETLW  30
01C5:  RETLW  40
01C6:  RETLW  3C
01C7:  RETLW  44
01C8:  RETLW  28
01C9:  RETLW  10
01CA:  RETLW  28
01CB:  RETLW  44
01CC:  RETLW  0C
01CD:  RETLW  50
01CE:  RETLW  50
01CF:  RETLW  50
01D0:  RETLW  3C
01D1:  RETLW  44
01D2:  RETLW  64
01D3:  RETLW  54
01D4:  RETLW  4C
01D5:  RETLW  44
01D6:  RETLW  00
01D7:  RETLW  08
01D8:  RETLW  36
01D9:  RETLW  41
01DA:  RETLW  41
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  7F
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  41
01E1:  RETLW  41
01E2:  RETLW  36
01E3:  RETLW  08
01E4:  RETLW  00
01E5:  RETLW  02
01E6:  RETLW  01
01E7:  RETLW  02
01E8:  RETLW  04
01E9:  RETLW  02
*
021C:  CLRF   77
021D:  CLRF   78
021E:  BSF    03.5
021F:  BSF    03.6
0220:  MOVF   57,W
0221:  BCF    03.0
0222:  BTFSC  58.0
0223:  ADDWF  77,F
0224:  RRF    77,F
0225:  RRF    78,F
0226:  BTFSC  58.1
0227:  ADDWF  77,F
0228:  RRF    77,F
0229:  RRF    78,F
022A:  BTFSC  58.2
022B:  ADDWF  77,F
022C:  RRF    77,F
022D:  RRF    78,F
022E:  BTFSC  58.3
022F:  ADDWF  77,F
0230:  RRF    77,F
0231:  RRF    78,F
0232:  BTFSC  58.4
0233:  ADDWF  77,F
0234:  RRF    77,F
0235:  RRF    78,F
0236:  BTFSC  58.5
0237:  ADDWF  77,F
0238:  RRF    77,F
0239:  RRF    78,F
023A:  BTFSC  58.6
023B:  ADDWF  77,F
023C:  RRF    77,F
023D:  RRF    78,F
023E:  BTFSC  58.7
023F:  ADDWF  77,F
0240:  RRF    77,F
0241:  RRF    78,F
0242:  BCF    03.5
0243:  BCF    03.6
0244:  RETURN
*
06B4:  CLRF   78
06B5:  CLRF   79
06B6:  CLRF   77
06B7:  CLRF   7A
06B8:  BSF    03.5
06B9:  BSF    03.6
06BA:  MOVF   4C,W
06BB:  BTFSS  03.2
06BC:  GOTO   6C0
06BD:  MOVF   4B,W
06BE:  BTFSC  03.2
06BF:  GOTO   6DA
06C0:  MOVLW  10
06C1:  MOVWF  4D
06C2:  BCF    03.0
06C3:  RLF    49,F
06C4:  RLF    4A,F
06C5:  RLF    77,F
06C6:  RLF    7A,F
06C7:  MOVF   4C,W
06C8:  SUBWF  7A,W
06C9:  BTFSS  03.2
06CA:  GOTO   6CD
06CB:  MOVF   4B,W
06CC:  SUBWF  77,W
06CD:  BTFSS  03.0
06CE:  GOTO   6D6
06CF:  MOVF   4B,W
06D0:  SUBWF  77,F
06D1:  BTFSS  03.0
06D2:  DECF   7A,F
06D3:  MOVF   4C,W
06D4:  SUBWF  7A,F
06D5:  BSF    03.0
06D6:  RLF    78,F
06D7:  RLF    79,F
06D8:  DECFSZ 4D,F
06D9:  GOTO   6C2
06DA:  BCF    03.5
06DB:  BCF    03.6
06DC:  RETURN
*
06FB:  MOVLW  20
06FC:  MOVWF  52
06FD:  CLRF   4E
06FE:  CLRF   4F
06FF:  CLRF   50
0700:  CLRF   51
0701:  MOVF   49,W
0702:  MOVWF  7A
0703:  MOVF   48,W
0704:  MOVWF  79
0705:  MOVF   47,W
0706:  MOVWF  78
0707:  MOVF   46,W
0708:  MOVWF  77
0709:  BCF    03.0
070A:  BTFSS  77.0
070B:  GOTO   71A
070C:  MOVF   4A,W
070D:  ADDWF  4E,F
070E:  MOVF   4B,W
070F:  BTFSC  03.0
0710:  INCFSZ 4B,W
0711:  ADDWF  4F,F
0712:  MOVF   4C,W
0713:  BTFSC  03.0
0714:  INCFSZ 4C,W
0715:  ADDWF  50,F
0716:  MOVF   4D,W
0717:  BTFSC  03.0
0718:  INCFSZ 4D,W
0719:  ADDWF  51,F
071A:  RRF    51,F
071B:  RRF    50,F
071C:  RRF    4F,F
071D:  RRF    4E,F
071E:  RRF    7A,F
071F:  RRF    79,F
0720:  RRF    78,F
0721:  RRF    77,F
0722:  DECFSZ 52,F
0723:  GOTO   709
*
08D3:  BSF    03.5
08D4:  BSF    03.6
08D5:  MOVF   45,W
08D6:  CLRF   78
08D7:  SUBWF  44,W
08D8:  BTFSC  03.0
08D9:  GOTO   0DD
08DA:  MOVF   44,W
08DB:  MOVWF  77
08DC:  GOTO   0E9
08DD:  CLRF   77
08DE:  MOVLW  08
08DF:  MOVWF  46
08E0:  RLF    44,F
08E1:  RLF    77,F
08E2:  MOVF   45,W
08E3:  SUBWF  77,W
08E4:  BTFSC  03.0
08E5:  MOVWF  77
08E6:  RLF    78,F
08E7:  DECFSZ 46,F
08E8:  GOTO   0E0
08E9:  BCF    03.5
08EA:  BCF    03.6
08EB:  RETURN
*
0C2A:  BCF    0A.0
0C2B:  BCF    0A.1
0C2C:  BSF    0A.2
0C2D:  ADDWF  02,F
0C2E:  GOTO   243
0C2F:  GOTO   255
0C30:  GOTO   267
0C31:  GOTO   27A
....................  
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=16000000) 
*
0330:  MOVLW  C6
0331:  MOVWF  04
0332:  BSF    03.7
0333:  MOVF   00,W
0334:  BTFSC  03.2
0335:  GOTO   344
0336:  MOVLW  05
0337:  MOVWF  78
0338:  CLRF   77
0339:  DECFSZ 77,F
033A:  GOTO   339
033B:  DECFSZ 78,F
033C:  GOTO   338
033D:  MOVLW  2E
033E:  MOVWF  77
033F:  DECFSZ 77,F
0340:  GOTO   33F
0341:  GOTO   342
0342:  DECFSZ 00,F
0343:  GOTO   336
0344:  RETURN
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0903:  BCF    03.5
0904:  CLRF   20
0905:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
06DD:  MOVF   25,W
06DE:  BSF    03.5
06DF:  BSF    03.6
06E0:  MOVWF  49
06E1:  BCF    03.5
06E2:  BCF    03.6
06E3:  MOVF   24,W
06E4:  BSF    03.5
06E5:  BSF    03.6
06E6:  MOVWF  48
06E7:  BCF    03.5
06E8:  BCF    03.6
06E9:  MOVF   23,W
06EA:  BSF    03.5
06EB:  BSF    03.6
06EC:  MOVWF  47
06ED:  BCF    03.5
06EE:  BCF    03.6
06EF:  MOVF   22,W
06F0:  BSF    03.5
06F1:  BSF    03.6
06F2:  MOVWF  46
06F3:  MOVLW  41
06F4:  MOVWF  4D
06F5:  MOVLW  C6
06F6:  MOVWF  4C
06F7:  MOVLW  4E
06F8:  MOVWF  4B
06F9:  MOVLW  6D
06FA:  MOVWF  4A
*
0724:  MOVF   7A,W
0725:  MOVWF  49
0726:  MOVF   79,W
0727:  MOVWF  48
0728:  MOVF   78,W
0729:  MOVWF  47
072A:  MOVF   77,W
072B:  MOVWF  46
072C:  MOVLW  39
072D:  ADDWF  46,W
072E:  BCF    03.5
072F:  BCF    03.6
0730:  MOVWF  22
0731:  BSF    03.5
0732:  BSF    03.6
0733:  MOVF   47,W
0734:  BCF    03.5
0735:  BCF    03.6
0736:  MOVWF  23
0737:  MOVLW  30
0738:  BTFSC  03.0
0739:  MOVLW  31
073A:  ADDWF  23,F
073B:  BSF    03.5
073C:  BSF    03.6
073D:  MOVF   48,W
073E:  BCF    03.5
073F:  BCF    03.6
0740:  MOVWF  24
0741:  MOVLW  00
0742:  BTFSC  03.0
0743:  MOVLW  01
0744:  ADDWF  24,F
0745:  BSF    03.5
0746:  BSF    03.6
0747:  MOVF   49,W
0748:  BCF    03.5
0749:  BCF    03.6
074A:  MOVWF  25
074B:  MOVLW  00
074C:  BTFSC  03.0
074D:  MOVLW  01
074E:  ADDWF  25,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
074F:  MOVF   24,W
0750:  MOVWF  77
0751:  MOVF   25,W
0752:  MOVWF  78
0753:  CLRF   79
0754:  CLRF   7A
0755:  MOVF   25,W
0756:  BSF    03.5
0757:  BSF    03.6
0758:  MOVWF  48
0759:  MOVF   77,W
075A:  MOVWF  47
075B:  MOVF   48,W
075C:  MOVWF  4A
075D:  MOVF   47,W
075E:  MOVWF  49
075F:  MOVLW  7F
0760:  MOVWF  4C
0761:  MOVLW  FF
0762:  MOVWF  4B
0763:  BCF    03.5
0764:  BCF    03.6
0765:  CALL   6B4
0766:  MOVF   77,W
0767:  MOVWF  78
0768:  MOVF   7A,W
0769:  MOVWF  79
076A:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <glcd.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
02B4:  BCF    26.0
02B5:  MOVF   26,W
02B6:  BSF    03.5
02B7:  MOVWF  07
02B8:  BCF    03.5
02B9:  BSF    07.0
....................    output_low(GLCD_E); 
02BA:  BSF    03.5
02BB:  BCF    06.5
02BC:  BCF    03.5
02BD:  BCF    06.5
....................    output_low(GLCD_CS1); 
02BE:  BSF    03.5
02BF:  BCF    06.0
02C0:  BCF    03.5
02C1:  BCF    06.0
....................    output_low(GLCD_CS2); 
02C2:  BSF    03.5
02C3:  BCF    06.1
02C4:  BCF    03.5
02C5:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
02C6:  BSF    03.5
02C7:  BCF    06.2
02C8:  BCF    03.5
02C9:  BCF    06.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
02CA:  MOVLW  30
02CB:  BSF    03.5
02CC:  BSF    03.6
02CD:  MOVWF  5C
02CE:  MOVLW  C0
02CF:  MOVWF  5D
02D0:  BCF    03.5
02D1:  BCF    03.6
02D2:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
02D3:  MOVLW  31
02D4:  BSF    03.5
02D5:  BSF    03.6
02D6:  MOVWF  5C
02D7:  MOVLW  C0
02D8:  MOVWF  5D
02D9:  BCF    03.5
02DA:  BCF    03.6
02DB:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
02DC:  MOVLW  30
02DD:  BSF    03.5
02DE:  BSF    03.6
02DF:  MOVWF  5C
02E0:  MOVLW  40
02E1:  MOVWF  5D
02E2:  BCF    03.5
02E3:  BCF    03.6
02E4:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0x40); 
02E5:  MOVLW  31
02E6:  BSF    03.5
02E7:  BSF    03.6
02E8:  MOVWF  5C
02E9:  MOVLW  40
02EA:  MOVWF  5D
02EB:  BCF    03.5
02EC:  BCF    03.6
02ED:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
02EE:  MOVLW  30
02EF:  BSF    03.5
02F0:  BSF    03.6
02F1:  MOVWF  5C
02F2:  MOVLW  B8
02F3:  MOVWF  5D
02F4:  BCF    03.5
02F5:  BCF    03.6
02F6:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
02F7:  MOVLW  31
02F8:  BSF    03.5
02F9:  BSF    03.6
02FA:  MOVWF  5C
02FB:  MOVLW  B8
02FC:  MOVWF  5D
02FD:  BCF    03.5
02FE:  BCF    03.6
02FF:  CALL   1EA
....................    if(mode == ON) 
0300:  BSF    03.5
0301:  BSF    03.6
0302:  DECFSZ 44,W
0303:  GOTO   317
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
0304:  MOVLW  30
0305:  MOVWF  5C
0306:  MOVLW  3F
0307:  MOVWF  5D
0308:  BCF    03.5
0309:  BCF    03.6
030A:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
030B:  MOVLW  31
030C:  BSF    03.5
030D:  BSF    03.6
030E:  MOVWF  5C
030F:  MOVLW  3F
0310:  MOVWF  5D
0311:  BCF    03.5
0312:  BCF    03.6
0313:  CALL   1EA
....................    } 
0314:  GOTO   327
0315:  BSF    03.5
0316:  BSF    03.6
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
0317:  MOVLW  30
0318:  MOVWF  5C
0319:  MOVLW  3E
031A:  MOVWF  5D
031B:  BCF    03.5
031C:  BCF    03.6
031D:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
031E:  MOVLW  31
031F:  BSF    03.5
0320:  BSF    03.6
0321:  MOVWF  5C
0322:  MOVLW  3E
0323:  MOVWF  5D
0324:  BCF    03.5
0325:  BCF    03.6
0326:  CALL   1EA
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
0327:  BSF    03.5
0328:  BSF    03.6
0329:  CLRF   45
032A:  BCF    03.5
032B:  BCF    03.6
032C:  CALL   245
032D:  BSF    0A.3
032E:  BCF    0A.4
032F:  GOTO   16F (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
*
0345:  MOVLW  30
0346:  BSF    03.5
0347:  BSF    03.6
0348:  MOVWF  5A
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
0349:  MOVF   56,W
034A:  SUBLW  3F
034B:  BTFSC  03.0
034C:  GOTO   351
....................    { 
....................       x -= 64; 
034D:  MOVLW  40
034E:  SUBWF  56,F
....................       chip = GLCD_CS2; 
034F:  MOVLW  31
0350:  MOVWF  5A
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
0351:  BCF    03.6
0352:  BCF    06.2
0353:  BCF    03.5
0354:  BCF    06.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
0355:  BSF    03.5
0356:  BSF    03.6
0357:  BCF    56.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
0358:  BSF    56.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
0359:  MOVF   5A,W
035A:  MOVWF  5C
035B:  MOVF   56,W
035C:  MOVWF  5D
035D:  BCF    03.5
035E:  BCF    03.6
035F:  CALL   1EA
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
0360:  BSF    03.5
0361:  BSF    03.6
0362:  RRF    57,W
0363:  MOVWF  77
0364:  RRF    77,F
0365:  RRF    77,F
0366:  MOVLW  1F
0367:  ANDWF  77,F
0368:  MOVF   77,W
0369:  ANDLW  BF
036A:  IORLW  B8
036B:  MOVWF  5B
036C:  MOVF   5A,W
036D:  MOVWF  5C
036E:  MOVF   5B,W
036F:  MOVWF  5D
0370:  BCF    03.5
0371:  BCF    03.6
0372:  CALL   1EA
....................    output_high(GLCD_DI);                                    // Set for data 
0373:  BSF    03.5
0374:  BCF    06.2
0375:  BCF    03.5
0376:  BSF    06.2
....................    data = glcd_readByte(chip); 
0377:  BSF    03.5
0378:  BSF    03.6
0379:  MOVF   5A,W
037A:  MOVWF  5B
*
03C3:  MOVF   78,W
03C4:  MOVWF  59
....................  
....................    if(color == ON) 
03C5:  DECFSZ 58,W
03C6:  GOTO   3D7
....................       bit_set(data, y%8);        // Turn the pixel on 
03C7:  MOVF   57,W
03C8:  ANDLW  07
03C9:  MOVWF  5B
03CA:  MOVLW  01
03CB:  MOVWF  77
03CC:  MOVF   5B,W
03CD:  MOVWF  78
03CE:  BTFSC  03.2
03CF:  GOTO   3D4
03D0:  BCF    03.0
03D1:  RLF    77,F
03D2:  DECFSZ 78,F
03D3:  GOTO   3D0
03D4:  MOVF   77,W
03D5:  IORWF  59,F
03D6:  GOTO   3E7
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
03D7:  MOVF   57,W
03D8:  ANDLW  07
03D9:  MOVWF  5B
03DA:  MOVLW  01
03DB:  MOVWF  77
03DC:  MOVF   5B,W
03DD:  MOVWF  78
03DE:  BTFSC  03.2
03DF:  GOTO   3E4
03E0:  BCF    03.0
03E1:  RLF    77,F
03E2:  DECFSZ 78,F
03E3:  GOTO   3E0
03E4:  MOVF   77,W
03E5:  XORLW  FF
03E6:  ANDWF  59,F
....................    output_low(GLCD_DI);          // Set for instruction 
03E7:  BCF    03.6
03E8:  BCF    06.2
03E9:  BCF    03.5
03EA:  BCF    06.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
03EB:  BSF    03.5
03EC:  BSF    03.6
03ED:  MOVF   5A,W
03EE:  MOVWF  5C
03EF:  MOVF   56,W
03F0:  MOVWF  5D
03F1:  BCF    03.5
03F2:  BCF    03.6
03F3:  CALL   1EA
....................    output_high(GLCD_DI);         // Set for data 
03F4:  BSF    03.5
03F5:  BCF    06.2
03F6:  BCF    03.5
03F7:  BSF    06.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
03F8:  BSF    03.5
03F9:  BSF    03.6
03FA:  MOVF   5A,W
03FB:  MOVWF  5C
03FC:  MOVF   59,W
03FD:  MOVWF  5D
03FE:  BCF    03.5
03FF:  BCF    03.6
0400:  CALL   1EA
0401:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
*
053E:  BSF    03.5
053F:  BSF    03.6
0540:  MOVF   48,W
0541:  SUBWF  4A,W
0542:  MOVWF  56
0543:  MOVF   56,W
0544:  BTFSS  56.7
0545:  GOTO   548
0546:  MOVF   56,W
0547:  SUBLW  00
0548:  MOVWF  51
....................    dy = abs((signed int)(y2 - y1)); 
0549:  MOVF   49,W
054A:  SUBWF  4B,W
054B:  MOVWF  56
054C:  MOVF   56,W
054D:  BTFSS  56.7
054E:  GOTO   551
054F:  MOVF   56,W
0550:  SUBLW  00
0551:  MOVWF  52
....................    x = x1; 
0552:  MOVF   48,W
0553:  MOVWF  4D
....................    y = y1; 
0554:  MOVF   49,W
0555:  MOVWF  4E
....................  
....................    if(x1 > x2) 
0556:  MOVF   48,W
0557:  SUBWF  4A,W
0558:  BTFSC  03.0
0559:  GOTO   55D
....................       addx = -1; 
055A:  MOVLW  FF
055B:  MOVWF  4F
055C:  GOTO   55F
....................    else 
....................       addx = 1; 
055D:  MOVLW  01
055E:  MOVWF  4F
....................    if(y1 > y2) 
055F:  MOVF   49,W
0560:  SUBWF  4B,W
0561:  BTFSC  03.0
0562:  GOTO   566
....................       addy = -1; 
0563:  MOVLW  FF
0564:  MOVWF  50
0565:  GOTO   568
....................    else 
....................       addy = 1; 
0566:  MOVLW  01
0567:  MOVWF  50
....................  
....................    if(dx >= dy) 
0568:  MOVF   52,W
0569:  XORLW  80
056A:  MOVWF  77
056B:  MOVF   51,W
056C:  XORLW  80
056D:  SUBWF  77,W
056E:  BTFSC  03.2
056F:  GOTO   572
0570:  BTFSC  03.0
0571:  GOTO   5D4
....................    { 
....................       P = 2*dy - dx; 
0572:  MOVLW  02
0573:  MOVWF  57
0574:  MOVF   52,W
0575:  MOVWF  58
0576:  BCF    03.5
0577:  BCF    03.6
0578:  CALL   21C
0579:  BSF    03.5
057A:  BSF    03.6
057B:  MOVF   51,W
057C:  SUBWF  78,W
057D:  CLRF   7A
057E:  MOVWF  77
057F:  BTFSC  77.7
0580:  DECF   7A,F
0581:  MOVWF  53
0582:  MOVF   7A,W
0583:  MOVWF  54
....................  
....................       for(i=0; i<=dx; ++i) 
0584:  CLRF   55
0585:  BTFSC  51.7
0586:  GOTO   5D3
0587:  MOVF   55,W
0588:  SUBWF  51,W
0589:  BTFSS  03.0
058A:  GOTO   5D3
....................       { 
....................          glcd_pixel(x, y, color); 
058B:  MOVF   4D,W
058C:  MOVWF  56
058D:  MOVF   4E,W
058E:  MOVWF  57
058F:  MOVF   4C,W
0590:  MOVWF  58
0591:  BCF    03.5
0592:  BCF    03.6
0593:  CALL   345
....................  
....................          if(P < 0) 
0594:  BSF    03.5
0595:  BSF    03.6
0596:  BTFSS  54.7
0597:  GOTO   5AE
....................          { 
....................             P += 2*dy; 
0598:  MOVLW  02
0599:  MOVWF  57
059A:  MOVF   52,W
059B:  MOVWF  58
059C:  BCF    03.5
059D:  BCF    03.6
059E:  CALL   21C
059F:  MOVF   78,W
05A0:  CLRF   7A
05A1:  MOVWF  77
05A2:  BTFSC  77.7
05A3:  DECF   7A,F
05A4:  BSF    03.5
05A5:  BSF    03.6
05A6:  ADDWF  53,F
05A7:  MOVF   7A,W
05A8:  BTFSC  03.0
05A9:  INCFSZ 7A,W
05AA:  ADDWF  54,F
....................             x += addx; 
05AB:  MOVF   4F,W
05AC:  ADDWF  4D,F
....................          } 
05AD:  GOTO   5D1
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
05AE:  MOVLW  02
05AF:  MOVWF  57
05B0:  MOVF   52,W
05B1:  MOVWF  58
05B2:  BCF    03.5
05B3:  BCF    03.6
05B4:  CALL   21C
05B5:  MOVF   78,W
05B6:  BSF    03.5
05B7:  BSF    03.6
05B8:  MOVWF  56
05B9:  MOVLW  02
05BA:  MOVWF  57
05BB:  MOVF   51,W
05BC:  MOVWF  58
05BD:  BCF    03.5
05BE:  BCF    03.6
05BF:  CALL   21C
05C0:  MOVF   78,W
05C1:  BSF    03.5
05C2:  BSF    03.6
05C3:  SUBWF  56,W
05C4:  CLRF   7A
05C5:  MOVWF  77
05C6:  BTFSC  77.7
05C7:  DECF   7A,F
05C8:  ADDWF  53,F
05C9:  MOVF   7A,W
05CA:  BTFSC  03.0
05CB:  INCFSZ 7A,W
05CC:  ADDWF  54,F
....................             x += addx; 
05CD:  MOVF   4F,W
05CE:  ADDWF  4D,F
....................             y += addy; 
05CF:  MOVF   50,W
05D0:  ADDWF  4E,F
....................          } 
05D1:  INCF   55,F
05D2:  GOTO   585
....................       } 
....................    } 
05D3:  GOTO   635
....................    else 
....................    { 
....................       P = 2*dx - dy; 
05D4:  MOVLW  02
05D5:  MOVWF  57
05D6:  MOVF   51,W
05D7:  MOVWF  58
05D8:  BCF    03.5
05D9:  BCF    03.6
05DA:  CALL   21C
05DB:  BSF    03.5
05DC:  BSF    03.6
05DD:  MOVF   52,W
05DE:  SUBWF  78,W
05DF:  CLRF   7A
05E0:  MOVWF  77
05E1:  BTFSC  77.7
05E2:  DECF   7A,F
05E3:  MOVWF  53
05E4:  MOVF   7A,W
05E5:  MOVWF  54
....................  
....................       for(i=0; i<=dy; ++i) 
05E6:  CLRF   55
05E7:  BTFSC  52.7
05E8:  GOTO   635
05E9:  MOVF   55,W
05EA:  SUBWF  52,W
05EB:  BTFSS  03.0
05EC:  GOTO   635
....................       { 
....................          glcd_pixel(x, y, color); 
05ED:  MOVF   4D,W
05EE:  MOVWF  56
05EF:  MOVF   4E,W
05F0:  MOVWF  57
05F1:  MOVF   4C,W
05F2:  MOVWF  58
05F3:  BCF    03.5
05F4:  BCF    03.6
05F5:  CALL   345
....................  
....................          if(P < 0) 
05F6:  BSF    03.5
05F7:  BSF    03.6
05F8:  BTFSS  54.7
05F9:  GOTO   610
....................          { 
....................             P += 2*dx; 
05FA:  MOVLW  02
05FB:  MOVWF  57
05FC:  MOVF   51,W
05FD:  MOVWF  58
05FE:  BCF    03.5
05FF:  BCF    03.6
0600:  CALL   21C
0601:  MOVF   78,W
0602:  CLRF   7A
0603:  MOVWF  77
0604:  BTFSC  77.7
0605:  DECF   7A,F
0606:  BSF    03.5
0607:  BSF    03.6
0608:  ADDWF  53,F
0609:  MOVF   7A,W
060A:  BTFSC  03.0
060B:  INCFSZ 7A,W
060C:  ADDWF  54,F
....................             y += addy; 
060D:  MOVF   50,W
060E:  ADDWF  4E,F
....................          } 
060F:  GOTO   633
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
0610:  MOVLW  02
0611:  MOVWF  57
0612:  MOVF   51,W
0613:  MOVWF  58
0614:  BCF    03.5
0615:  BCF    03.6
0616:  CALL   21C
0617:  MOVF   78,W
0618:  BSF    03.5
0619:  BSF    03.6
061A:  MOVWF  56
061B:  MOVLW  02
061C:  MOVWF  57
061D:  MOVF   52,W
061E:  MOVWF  58
061F:  BCF    03.5
0620:  BCF    03.6
0621:  CALL   21C
0622:  MOVF   78,W
0623:  BSF    03.5
0624:  BSF    03.6
0625:  SUBWF  56,W
0626:  CLRF   7A
0627:  MOVWF  77
0628:  BTFSC  77.7
0629:  DECF   7A,F
062A:  ADDWF  53,F
062B:  MOVF   7A,W
062C:  BTFSC  03.0
062D:  INCFSZ 7A,W
062E:  ADDWF  54,F
....................             x += addx; 
062F:  MOVF   4F,W
0630:  ADDWF  4D,F
....................             y += addy; 
0631:  MOVF   50,W
0632:  ADDWF  4E,F
....................          } 
0633:  INCF   55,F
0634:  GOTO   5E7
....................       } 
....................    } 
0635:  BCF    03.5
0636:  BCF    03.6
0637:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
*
0402:  BSF    03.5
0403:  BSF    03.6
0404:  CLRF   4A
0405:  MOVF   4A,W
0406:  ADDWF  46,W
0407:  MOVWF  04
0408:  BCF    03.7
0409:  BTFSC  47.0
040A:  BSF    03.7
040B:  MOVF   00,F
040C:  BTFSC  03.2
040D:  GOTO   4EE
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
040E:  MOVF   4A,W
040F:  ADDWF  46,W
0410:  MOVWF  04
0411:  BCF    03.7
0412:  BTFSC  47.0
0413:  BSF    03.7
0414:  MOVF   00,W
0415:  SUBLW  52
0416:  BTFSS  03.0
0417:  GOTO   441
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
0418:  MOVF   4A,W
0419:  ADDWF  46,W
041A:  MOVWF  04
041B:  BCF    03.7
041C:  BTFSC  47.0
041D:  BSF    03.7
041E:  MOVLW  20
041F:  SUBWF  00,W
0420:  MOVWF  55
0421:  MOVWF  57
0422:  MOVLW  05
0423:  MOVWF  58
0424:  BCF    03.5
0425:  BCF    03.6
0426:  CALL   21C
0427:  MOVF   78,W
0428:  BSF    03.5
0429:  BSF    03.6
042A:  MOVWF  54
042B:  MOVWF  78
042C:  MOVLW  05
042D:  MOVWF  77
042E:  MOVLW  CF
042F:  MOVWF  04
0430:  BSF    03.7
0431:  MOVF   78,W
0432:  BCF    03.5
0433:  BCF    03.6
0434:  CALL   004
0435:  MOVWF  00
0436:  INCF   78,F
0437:  INCF   04,F
0438:  DECFSZ 77,F
0439:  GOTO   43B
043A:  GOTO   43E
043B:  BSF    03.5
043C:  BSF    03.6
043D:  GOTO   431
043E:  GOTO   47B
043F:  BSF    03.5
0440:  BSF    03.6
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
0441:  MOVF   4A,W
0442:  ADDWF  46,W
0443:  MOVWF  04
0444:  BCF    03.7
0445:  BTFSC  47.0
0446:  BSF    03.7
0447:  MOVF   00,W
0448:  SUBLW  7E
0449:  BTFSS  03.0
044A:  GOTO   474
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
044B:  MOVF   4A,W
044C:  ADDWF  46,W
044D:  MOVWF  04
044E:  BCF    03.7
044F:  BTFSC  47.0
0450:  BSF    03.7
0451:  MOVLW  53
0452:  SUBWF  00,W
0453:  MOVWF  55
0454:  MOVWF  57
0455:  MOVLW  05
0456:  MOVWF  58
0457:  BCF    03.5
0458:  BCF    03.6
0459:  CALL   21C
045A:  MOVF   78,W
045B:  BSF    03.5
045C:  BSF    03.6
045D:  MOVWF  54
045E:  MOVWF  78
045F:  MOVLW  05
0460:  MOVWF  77
0461:  MOVLW  CF
0462:  MOVWF  04
0463:  BSF    03.7
0464:  MOVF   78,W
0465:  BCF    03.5
0466:  BCF    03.6
0467:  CALL   10A
0468:  MOVWF  00
0469:  INCF   78,F
046A:  INCF   04,F
046B:  DECFSZ 77,F
046C:  GOTO   46E
046D:  GOTO   471
046E:  BSF    03.5
046F:  BSF    03.6
0470:  GOTO   464
0471:  GOTO   47B
0472:  BSF    03.5
0473:  BSF    03.6
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
0474:  CLRF   4F
0475:  CLRF   50
0476:  CLRF   51
0477:  CLRF   52
0478:  CLRF   53
0479:  BCF    03.5
047A:  BCF    03.6
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
047B:  MOVLW  05
047C:  BSF    03.5
047D:  BSF    03.6
047E:  MOVWF  57
047F:  MOVF   48,W
0480:  MOVWF  58
0481:  BCF    03.5
0482:  BCF    03.6
0483:  CALL   21C
0484:  MOVF   78,W
0485:  BSF    03.5
0486:  BSF    03.6
0487:  ADDWF  44,W
0488:  SUBLW  7F
0489:  BTFSC  03.0
048A:  GOTO   498
....................       { 
....................          x = 0;                           // Set x at far left position 
048B:  CLRF   44
....................          y += 7*size + 1;                 // Set y at next position down 
048C:  MOVLW  07
048D:  MOVWF  57
048E:  MOVF   48,W
048F:  MOVWF  58
0490:  BCF    03.5
0491:  BCF    03.6
0492:  CALL   21C
0493:  MOVLW  01
0494:  ADDWF  78,W
0495:  BSF    03.5
0496:  BSF    03.6
0497:  ADDWF  45,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0498:  CLRF   4B
0499:  MOVF   4B,W
049A:  SUBLW  04
049B:  BTFSS  03.0
049C:  GOTO   4EB
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
049D:  CLRF   4C
049E:  MOVLW  07
049F:  MOVWF  57
04A0:  MOVF   48,W
04A1:  MOVWF  58
04A2:  BCF    03.5
04A3:  BCF    03.6
04A4:  CALL   21C
04A5:  MOVF   78,W
04A6:  BSF    03.5
04A7:  BSF    03.6
04A8:  SUBWF  4C,W
04A9:  BTFSC  03.0
04AA:  GOTO   4E7
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
04AB:  MOVLW  CF
04AC:  ADDWF  4B,W
04AD:  MOVWF  04
04AE:  BSF    03.7
04AF:  MOVF   00,W
04B0:  MOVWF  54
04B1:  MOVWF  77
04B2:  MOVF   4C,W
04B3:  MOVWF  78
04B4:  BTFSC  03.2
04B5:  GOTO   4BA
04B6:  BCF    03.0
04B7:  RRF    77,F
04B8:  DECFSZ 78,F
04B9:  GOTO   4B6
04BA:  BTFSS  77.0
04BB:  GOTO   4E5
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
04BC:  CLRF   4D
04BD:  MOVF   48,W
04BE:  SUBWF  4D,W
04BF:  BTFSC  03.0
04C0:  GOTO   4E5
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
04C1:  CLRF   4E
04C2:  MOVF   48,W
04C3:  SUBWF  4E,W
04C4:  BTFSC  03.0
04C5:  GOTO   4E3
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
04C6:  MOVF   4E,W
04C7:  ADDWF  44,W
04C8:  MOVWF  54
04C9:  MOVF   4C,W
04CA:  MOVWF  57
04CB:  MOVF   48,W
04CC:  MOVWF  58
04CD:  BCF    03.5
04CE:  BCF    03.6
04CF:  CALL   21C
04D0:  MOVF   78,W
04D1:  BSF    03.5
04D2:  BSF    03.6
04D3:  ADDWF  45,W
04D4:  ADDWF  4D,W
04D5:  MOVWF  55
04D6:  MOVF   54,W
04D7:  MOVWF  56
04D8:  MOVF   55,W
04D9:  MOVWF  57
04DA:  MOVF   49,W
04DB:  MOVWF  58
04DC:  BCF    03.5
04DD:  BCF    03.6
04DE:  CALL   345
04DF:  BSF    03.5
04E0:  BSF    03.6
04E1:  INCF   4E,F
04E2:  GOTO   4C2
....................                   } 
04E3:  INCF   4D,F
04E4:  GOTO   4BD
....................                } 
....................             } 
04E5:  INCF   4C,F
04E6:  GOTO   49E
....................          } 
04E7:  INCF   4B,F
04E8:  MOVF   48,W
04E9:  ADDWF  44,F
04EA:  GOTO   499
....................       } 
04EB:  INCF   4A,F
04EC:  INCF   44,F
04ED:  GOTO   405
....................    } 
04EE:  BCF    03.5
04EF:  BCF    03.6
04F0:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0245:  BSF    03.5
0246:  BSF    03.6
0247:  CLRF   46
0248:  MOVF   46,W
0249:  SUBLW  07
024A:  BTFSS  03.0
024B:  GOTO   2B1
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
024C:  BCF    03.6
024D:  BCF    06.2
024E:  BCF    03.5
024F:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0250:  MOVLW  30
0251:  BSF    03.5
0252:  BSF    03.6
0253:  MOVWF  5C
0254:  MOVLW  40
0255:  MOVWF  5D
0256:  BCF    03.5
0257:  BCF    03.6
0258:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
0259:  MOVLW  31
025A:  BSF    03.5
025B:  BSF    03.6
025C:  MOVWF  5C
025D:  MOVLW  40
025E:  MOVWF  5D
025F:  BCF    03.5
0260:  BCF    03.6
0261:  CALL   1EA
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
0262:  BSF    03.5
0263:  BSF    03.6
0264:  MOVF   46,W
0265:  IORLW  B8
0266:  MOVWF  48
0267:  MOVLW  30
0268:  MOVWF  5C
0269:  MOVF   48,W
026A:  MOVWF  5D
026B:  BCF    03.5
026C:  BCF    03.6
026D:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
026E:  BSF    03.5
026F:  BSF    03.6
0270:  MOVF   46,W
0271:  IORLW  B8
0272:  MOVWF  48
0273:  MOVLW  31
0274:  MOVWF  5C
0275:  MOVF   48,W
0276:  MOVWF  5D
0277:  BCF    03.5
0278:  BCF    03.6
0279:  CALL   1EA
....................       output_high(GLCD_DI);                     // Set for data 
027A:  BSF    03.5
027B:  BCF    06.2
027C:  BCF    03.5
027D:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
027E:  BSF    03.5
027F:  BSF    03.6
0280:  CLRF   47
0281:  MOVF   47,W
0282:  SUBLW  3F
0283:  BTFSS  03.0
0284:  GOTO   2AF
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0285:  MOVLW  FF
0286:  MOVWF  57
0287:  MOVF   45,W
0288:  MOVWF  58
0289:  BCF    03.5
028A:  BCF    03.6
028B:  CALL   21C
028C:  MOVF   78,W
028D:  BSF    03.5
028E:  BSF    03.6
028F:  MOVWF  48
0290:  MOVLW  30
0291:  MOVWF  5C
0292:  MOVF   48,W
0293:  MOVWF  5D
0294:  BCF    03.5
0295:  BCF    03.6
0296:  CALL   1EA
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
0297:  MOVLW  FF
0298:  BSF    03.5
0299:  BSF    03.6
029A:  MOVWF  57
029B:  MOVF   45,W
029C:  MOVWF  58
029D:  BCF    03.5
029E:  BCF    03.6
029F:  CALL   21C
02A0:  MOVF   78,W
02A1:  BSF    03.5
02A2:  BSF    03.6
02A3:  MOVWF  48
02A4:  MOVLW  31
02A5:  MOVWF  5C
02A6:  MOVF   48,W
02A7:  MOVWF  5D
02A8:  BCF    03.5
02A9:  BCF    03.6
02AA:  CALL   1EA
02AB:  BSF    03.5
02AC:  BSF    03.6
02AD:  INCF   47,F
02AE:  GOTO   281
....................       } 
02AF:  INCF   46,F
02B0:  GOTO   248
....................    } 
02B1:  BCF    03.5
02B2:  BCF    03.6
02B3:  RETURN
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
01EA:  BSF    03.5
01EB:  BSF    03.6
01EC:  MOVF   5C,W
01ED:  SUBLW  30
01EE:  BTFSS  03.2
01EF:  GOTO   1F7
....................       output_high(GLCD_CS1); 
01F0:  BCF    03.6
01F1:  BCF    06.0
01F2:  BCF    03.5
01F3:  BSF    06.0
01F4:  GOTO   1FB
01F5:  BSF    03.5
01F6:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS2); 
01F7:  BCF    03.6
01F8:  BCF    06.1
01F9:  BCF    03.5
01FA:  BSF    06.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
01FB:  BSF    03.5
01FC:  BCF    06.4
01FD:  BCF    03.5
01FE:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
01FF:  BSF    03.5
0200:  CLRF   08
0201:  BSF    03.6
0202:  MOVF   5D,W
0203:  BCF    03.5
0204:  BCF    03.6
0205:  MOVWF  08
....................    output_high(GLCD_E);       // Pulse the enable pin 
0206:  BSF    03.5
0207:  BCF    06.5
0208:  BCF    03.5
0209:  BSF    06.5
....................    delay_us(2); 
020A:  MOVLW  02
020B:  MOVWF  77
020C:  DECFSZ 77,F
020D:  GOTO   20C
020E:  NOP
....................    output_low(GLCD_E); 
020F:  BSF    03.5
0210:  BCF    06.5
0211:  BCF    03.5
0212:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0213:  BSF    03.5
0214:  BCF    06.0
0215:  BCF    03.5
0216:  BCF    06.0
....................    output_low(GLCD_CS2); 
0217:  BSF    03.5
0218:  BCF    06.1
0219:  BCF    03.5
021A:  BCF    06.1
021B:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
037B:  MOVF   5B,W
037C:  SUBLW  30
037D:  BTFSS  03.2
037E:  GOTO   386
....................       output_high(GLCD_CS1); 
037F:  BCF    03.6
0380:  BCF    06.0
0381:  BCF    03.5
0382:  BSF    06.0
0383:  GOTO   38A
0384:  BSF    03.5
0385:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS2); 
0386:  BCF    03.6
0387:  BCF    06.1
0388:  BCF    03.5
0389:  BSF    06.1
....................  
....................    input_d();                 // Set port d to input 
038A:  MOVLW  FF
038B:  BSF    03.5
038C:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
038D:  BCF    06.4
038E:  BCF    03.5
038F:  BSF    06.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
0390:  BSF    03.5
0391:  BCF    06.5
0392:  BCF    03.5
0393:  BSF    06.5
....................    delay_us(2); 
0394:  MOVLW  02
0395:  MOVWF  77
0396:  DECFSZ 77,F
0397:  GOTO   396
0398:  NOP
....................    output_low(GLCD_E); 
0399:  BSF    03.5
039A:  BCF    06.5
039B:  BCF    03.5
039C:  BCF    06.5
....................    delay_us(2); 
039D:  MOVLW  02
039E:  MOVWF  77
039F:  DECFSZ 77,F
03A0:  GOTO   39F
03A1:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
03A2:  BSF    03.5
03A3:  BCF    06.5
03A4:  BCF    03.5
03A5:  BSF    06.5
....................    delay_us(2); 
03A6:  MOVLW  02
03A7:  MOVWF  77
03A8:  DECFSZ 77,F
03A9:  GOTO   3A8
03AA:  NOP
....................    data = input_d();          // Get the data from the display's output register 
03AB:  MOVLW  FF
03AC:  BSF    03.5
03AD:  MOVWF  08
03AE:  BCF    03.5
03AF:  MOVF   08,W
03B0:  BSF    03.5
03B1:  BSF    03.6
03B2:  MOVWF  5C
....................    output_low(GLCD_E); 
03B3:  BCF    03.6
03B4:  BCF    06.5
03B5:  BCF    03.5
03B6:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
03B7:  BSF    03.5
03B8:  BCF    06.0
03B9:  BCF    03.5
03BA:  BCF    06.0
....................    output_low(GLCD_CS2); 
03BB:  BSF    03.5
03BC:  BCF    06.1
03BD:  BCF    03.5
03BE:  BCF    06.1
....................    return data;               // Return the read data 
03BF:  BSF    03.5
03C0:  BSF    03.6
03C1:  MOVF   5C,W
03C2:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define uchar unsigned char 
....................  
.................... #define GRID_SIZE     6 
.................... #define GRID_COLS     10 
.................... #define GRID_ROWS     10 
.................... #define GRID_ORIGIN_X 0 
.................... #define GRID_ORIGIN_Y 0 
....................  
.................... uchar snakeX[50]; 
.................... uchar snakeY[50]; 
.................... uchar snakeX2[50]; 
.................... uchar snakeY2[50]; 
....................  
.................... #define getX(i) ((i < 50) ? snakeX[i] : snakeX2[(i)-50]) 
.................... #define getY(i) ((i < 50) ? snakeY[i] : snakeY2[(i)-50]) 
.................... #define setX(i,val) ((i < 50) ? (snakeX[i]=(val)) : (snakeX2[(i)-50]=(val))) 
.................... #define setY(i,val) ((i < 50) ? (snakeY[i]=(val)) : (snakeY2[(i)-50]=(val))) 
....................  
.................... uchar dir = 2; 
.................... uchar food[2], LENGTH_SNAKE = 5; 
.................... uchar posX = 0, posY = 2; 
.................... uchar score = 0; 
.................... uchar best_score = 0; 
.................... char score_txt[11] = "Score: 00"; 
*
0906:  MOVLW  53
0907:  MOVWF  61
0908:  MOVLW  63
0909:  MOVWF  62
090A:  MOVLW  6F
090B:  MOVWF  63
090C:  MOVLW  72
090D:  MOVWF  64
090E:  MOVLW  65
090F:  MOVWF  65
0910:  MOVLW  3A
0911:  MOVWF  66
0912:  MOVLW  20
0913:  MOVWF  67
0914:  MOVLW  30
0915:  MOVWF  68
0916:  MOVWF  69
0917:  CLRF   6A
.................... char best_score_txt[10] = "Best: 00"; 
0918:  MOVLW  42
0919:  MOVWF  6C
091A:  MOVLW  65
091B:  MOVWF  6D
091C:  MOVLW  73
091D:  MOVWF  6E
091E:  MOVLW  74
091F:  MOVWF  6F
0920:  MOVLW  3A
0921:  MOVWF  70
0922:  MOVLW  20
0923:  MOVWF  71
0924:  MOVLW  30
0925:  MOVWF  72
0926:  MOVWF  73
0927:  CLRF   74
.................... char gameover_msg[14] = "GAMEOVER !!!"; 
0928:  MOVLW  47
0929:  BSF    03.5
092A:  MOVWF  52
092B:  MOVLW  41
092C:  MOVWF  53
092D:  MOVLW  4D
092E:  MOVWF  54
092F:  MOVLW  45
0930:  MOVWF  55
0931:  MOVLW  4F
0932:  MOVWF  56
0933:  MOVLW  56
0934:  MOVWF  57
0935:  MOVLW  45
0936:  MOVWF  58
0937:  MOVLW  52
0938:  MOVWF  59
0939:  MOVLW  20
093A:  MOVWF  5A
093B:  MOVLW  21
093C:  MOVWF  5B
093D:  MOVWF  5C
093E:  MOVWF  5D
093F:  CLRF   5E
.................... char win_msg[] = "YOU WON!"; 
0940:  MOVLW  59
0941:  MOVWF  60
0942:  MOVLW  4F
0943:  MOVWF  61
0944:  MOVLW  55
0945:  MOVWF  62
0946:  MOVLW  20
0947:  MOVWF  63
0948:  MOVLW  57
0949:  MOVWF  64
094A:  MOVLW  4F
094B:  MOVWF  65
094C:  MOVLW  4E
094D:  MOVWF  66
094E:  MOVLW  21
094F:  MOVWF  67
0950:  CLRF   68
.................... char splash_text[] = "SNAKE GAME"; 
0951:  MOVLW  53
0952:  BCF    03.5
0953:  BSF    03.6
0954:  MOVWF  42
0955:  MOVLW  4E
0956:  MOVWF  43
0957:  MOVLW  41
0958:  MOVWF  44
0959:  MOVLW  4B
095A:  MOVWF  45
095B:  MOVLW  45
095C:  MOVWF  46
095D:  MOVLW  20
095E:  MOVWF  47
095F:  MOVLW  47
0960:  MOVWF  48
0961:  MOVLW  41
0962:  MOVWF  49
0963:  MOVLW  4D
0964:  MOVWF  4A
0965:  MOVLW  45
0966:  MOVWF  4B
0967:  CLRF   4C
.................... uchar i; 
....................  
.................... int1 isFirstStart = 1; 
....................  
.................... void fillCell(signed int gx, signed int gy, int1 color) { 
....................    if (gx < 0 || gx >= GRID_COLS || gy < 0 || gy >= GRID_ROWS) return; 
*
076B:  BSF    03.5
076C:  BSF    03.6
076D:  BTFSC  46.7
076E:  GOTO   77C
076F:  BTFSC  46.7
0770:  GOTO   775
0771:  MOVF   46,W
0772:  SUBLW  09
0773:  BTFSS  03.0
0774:  GOTO   77C
0775:  BTFSC  47.7
0776:  GOTO   77C
0777:  BTFSC  47.7
0778:  GOTO   77D
0779:  MOVF   47,W
077A:  SUBLW  09
077B:  BTFSS  03.0
077C:  GOTO   7B4
....................    uchar px = GRID_ORIGIN_X + gx * GRID_SIZE + 1; 
....................    uchar py = GRID_ORIGIN_Y + gy * GRID_SIZE + 1; 
077D:  MOVF   46,W
077E:  MOVWF  57
077F:  MOVLW  06
0780:  MOVWF  58
0781:  BCF    03.5
0782:  BCF    03.6
0783:  CALL   21C
0784:  MOVLW  01
0785:  ADDWF  78,W
0786:  BSF    03.5
0787:  BSF    03.6
0788:  MOVWF  49
0789:  MOVF   47,W
078A:  MOVWF  57
078B:  MOVLW  06
078C:  MOVWF  58
078D:  BCF    03.5
078E:  BCF    03.6
078F:  CALL   21C
0790:  MOVLW  01
0791:  ADDWF  78,W
0792:  BSF    03.5
0793:  BSF    03.6
0794:  MOVWF  4A
....................    for (uchar dx = 0; dx < GRID_SIZE - 1; dx++) 
0795:  CLRF   4B
0796:  MOVF   4B,W
0797:  SUBLW  04
0798:  BTFSS  03.0
0799:  GOTO   7B4
....................       for (uchar dy = 0; dy < GRID_SIZE - 1; dy++) 
079A:  CLRF   4C
079B:  MOVF   4C,W
079C:  SUBLW  04
079D:  BTFSS  03.0
079E:  GOTO   7B2
....................          glcd_pixel(px + dx, py + dy, color); 
079F:  MOVF   4B,W
07A0:  ADDWF  49,W
07A1:  MOVWF  4D
07A2:  MOVF   4C,W
07A3:  ADDWF  4A,W
07A4:  MOVWF  4E
07A5:  MOVF   4D,W
07A6:  MOVWF  56
07A7:  MOVF   4E,W
07A8:  MOVWF  57
07A9:  MOVF   48,W
07AA:  MOVWF  58
07AB:  BCF    03.5
07AC:  BCF    03.6
07AD:  CALL   345
07AE:  BSF    03.5
07AF:  BSF    03.6
07B0:  INCF   4C,F
07B1:  GOTO   79B
07B2:  INCF   4B,F
07B3:  GOTO   796
07B4:  BCF    03.5
07B5:  BCF    03.6
07B6:  RETURN
.................... } 
....................  
.................... void screenWipeDown() { 
....................    for (uchar y = 0; y < 64; y++) { 
*
0519:  BSF    03.5
051A:  BSF    03.6
051B:  CLRF   44
051C:  MOVF   44,W
051D:  SUBLW  3F
051E:  BTFSS  03.0
051F:  GOTO   53B
....................       for (uchar x = 0; x < 128; x++) { 
0520:  CLRF   45
0521:  MOVF   45,W
0522:  SUBLW  7F
0523:  BTFSS  03.0
0524:  GOTO   532
....................          glcd_pixel(x, y, 1); 
0525:  MOVF   45,W
0526:  MOVWF  56
0527:  MOVF   44,W
0528:  MOVWF  57
0529:  MOVLW  01
052A:  MOVWF  58
052B:  BCF    03.5
052C:  BCF    03.6
052D:  CALL   345
052E:  BSF    03.5
052F:  BSF    03.6
0530:  INCF   45,F
0531:  GOTO   521
....................       } 
....................       delay_ms(5); 
0532:  MOVLW  05
0533:  MOVWF  46
0534:  BCF    03.5
0535:  BCF    03.6
0536:  CALL   330
0537:  BSF    03.5
0538:  BSF    03.6
0539:  INCF   44,F
053A:  GOTO   51C
....................    } 
053B:  BCF    03.5
053C:  BCF    03.6
053D:  RETURN
.................... } 
....................  
.................... void drawGrid() { 
....................    for (uchar c = 0; c <= GRID_COLS; c++) { 
*
0638:  BSF    03.5
0639:  BSF    03.6
063A:  CLRF   44
063B:  MOVF   44,W
063C:  SUBLW  0A
063D:  BTFSS  03.0
063E:  GOTO   65A
....................       uchar x = GRID_ORIGIN_X + c * GRID_SIZE; 
063F:  MOVF   44,W
0640:  MOVWF  57
0641:  MOVLW  06
0642:  MOVWF  58
0643:  BCF    03.5
0644:  BCF    03.6
0645:  CALL   21C
0646:  MOVF   78,W
0647:  BSF    03.5
0648:  BSF    03.6
0649:  MOVWF  45
....................       glcd_line(x, GRID_ORIGIN_Y, x, GRID_ORIGIN_Y + GRID_ROWS * GRID_SIZE, 1); 
064A:  MOVF   45,W
064B:  MOVWF  48
064C:  CLRF   49
064D:  MOVF   45,W
064E:  MOVWF  4A
064F:  MOVLW  3C
0650:  MOVWF  4B
0651:  MOVLW  01
0652:  MOVWF  4C
0653:  BCF    03.5
0654:  BCF    03.6
0655:  CALL   53E
0656:  BSF    03.5
0657:  BSF    03.6
0658:  INCF   44,F
0659:  GOTO   63B
....................    } 
....................    for (uchar r = 0; r <= GRID_ROWS; r++) { 
065A:  CLRF   46
065B:  MOVF   46,W
065C:  SUBLW  0A
065D:  BTFSS  03.0
065E:  GOTO   67A
....................       uchar y = GRID_ORIGIN_Y + r * GRID_SIZE; 
065F:  MOVF   46,W
0660:  MOVWF  57
0661:  MOVLW  06
0662:  MOVWF  58
0663:  BCF    03.5
0664:  BCF    03.6
0665:  CALL   21C
0666:  MOVF   78,W
0667:  BSF    03.5
0668:  BSF    03.6
0669:  MOVWF  47
....................       glcd_line(GRID_ORIGIN_X, y, GRID_ORIGIN_X + GRID_COLS * GRID_SIZE, y, 1); 
066A:  CLRF   48
066B:  MOVF   47,W
066C:  MOVWF  49
066D:  MOVLW  3C
066E:  MOVWF  4A
066F:  MOVF   47,W
0670:  MOVWF  4B
0671:  MOVLW  01
0672:  MOVWF  4C
0673:  BCF    03.5
0674:  BCF    03.6
0675:  CALL   53E
0676:  BSF    03.5
0677:  BSF    03.6
0678:  INCF   46,F
0679:  GOTO   65B
....................    } 
067A:  BCF    03.5
067B:  BCF    03.6
067C:  RETURN
.................... } 
....................  
.................... void clearScoreArea() { 
....................    for (uchar x = 65; x < 125; x++) { 
067D:  MOVLW  41
067E:  BSF    03.5
067F:  BSF    03.6
0680:  MOVWF  44
0681:  MOVF   44,W
0682:  SUBLW  7C
0683:  BTFSS  03.0
0684:  GOTO   698
....................       for (uchar y = 0; y < 20; y++) { 
0685:  CLRF   45
0686:  MOVF   45,W
0687:  SUBLW  13
0688:  BTFSS  03.0
0689:  GOTO   696
....................          glcd_pixel(x, y, 0); 
068A:  MOVF   44,W
068B:  MOVWF  56
068C:  MOVF   45,W
068D:  MOVWF  57
068E:  CLRF   58
068F:  BCF    03.5
0690:  BCF    03.6
0691:  CALL   345
0692:  BSF    03.5
0693:  BSF    03.6
0694:  INCF   45,F
0695:  GOTO   686
....................       } 
0696:  INCF   44,F
0697:  GOTO   681
....................    } 
.................... } 
....................  
.................... void writeScore() { 
....................    clearScoreArea(); 
....................    glcd_text57(65, 0, score_txt, 1, 1); 
0698:  MOVLW  41
0699:  MOVWF  44
069A:  CLRF   45
069B:  CLRF   47
069C:  MOVLW  61
069D:  MOVWF  46
069E:  MOVLW  01
069F:  MOVWF  48
06A0:  MOVWF  49
06A1:  BCF    03.5
06A2:  BCF    03.6
06A3:  CALL   402
....................    glcd_text57(65, 10, best_score_txt, 1, 1); 
06A4:  MOVLW  41
06A5:  BSF    03.5
06A6:  BSF    03.6
06A7:  MOVWF  44
06A8:  MOVLW  0A
06A9:  MOVWF  45
06AA:  CLRF   47
06AB:  MOVLW  6C
06AC:  MOVWF  46
06AD:  MOVLW  01
06AE:  MOVWF  48
06AF:  MOVWF  49
06B0:  BCF    03.5
06B1:  BCF    03.6
06B2:  CALL   402
06B3:  RETURN
.................... } 
....................  
.................... void criar_comida() { 
*
0800:  BSF    03.5
0801:  BSF    03.6
0802:  CLRF   44
....................    uchar valid = 0; 
....................    while (!valid) { 
0803:  MOVF   44,F
0804:  BTFSS  03.2
0805:  GOTO   07A
....................       food[0] = rand() % GRID_COLS; 
0806:  BCF    0A.3
0807:  BCF    03.5
0808:  BCF    03.6
0809:  CALL   6DD
080A:  BSF    0A.3
080B:  MOVF   79,W
080C:  BSF    03.5
080D:  BSF    03.6
080E:  MOVWF  47
080F:  MOVF   78,W
0810:  MOVWF  46
0811:  MOVF   47,W
0812:  MOVWF  4A
0813:  MOVF   46,W
0814:  MOVWF  49
0815:  CLRF   4C
0816:  MOVLW  0A
0817:  MOVWF  4B
0818:  BCF    0A.3
0819:  BCF    03.5
081A:  BCF    03.6
081B:  CALL   6B4
081C:  BSF    0A.3
081D:  MOVF   77,W
081E:  MOVWF  5A
....................       food[1] = rand() % GRID_ROWS; 
081F:  BCF    0A.3
0820:  CALL   6DD
0821:  BSF    0A.3
0822:  MOVF   79,W
0823:  BSF    03.5
0824:  BSF    03.6
0825:  MOVWF  47
0826:  MOVF   78,W
0827:  MOVWF  46
0828:  MOVF   47,W
0829:  MOVWF  4A
082A:  MOVF   46,W
082B:  MOVWF  49
082C:  CLRF   4C
082D:  MOVLW  0A
082E:  MOVWF  4B
082F:  BCF    0A.3
0830:  BCF    03.5
0831:  BCF    03.6
0832:  CALL   6B4
0833:  BSF    0A.3
0834:  MOVF   77,W
0835:  MOVWF  5B
....................       valid = 1; 
0836:  MOVLW  01
0837:  BSF    03.5
0838:  BSF    03.6
0839:  MOVWF  44
....................       for (uchar j = 0; j < LENGTH_SNAKE; j++) { 
083A:  CLRF   45
083B:  BCF    03.5
083C:  BCF    03.6
083D:  MOVF   5C,W
083E:  BSF    03.5
083F:  BSF    03.6
0840:  SUBWF  45,W
0841:  BTFSC  03.0
0842:  GOTO   079
....................          if (getX(j) == food[0] && getY(j) == food[1]) { 
0843:  MOVF   45,W
0844:  SUBLW  31
0845:  BTFSS  03.0
0846:  GOTO   04D
0847:  MOVLW  27
0848:  ADDWF  45,W
0849:  MOVWF  04
084A:  BCF    03.7
084B:  MOVF   00,W
084C:  GOTO   053
084D:  MOVLW  32
084E:  SUBWF  45,W
084F:  ADDLW  10
0850:  MOVWF  04
0851:  BSF    03.7
0852:  MOVF   00,W
0853:  BCF    03.5
0854:  BCF    03.6
0855:  SUBWF  5A,W
0856:  BTFSS  03.2
0857:  GOTO   075
0858:  BSF    03.5
0859:  BSF    03.6
085A:  MOVF   45,W
085B:  SUBLW  31
085C:  BTFSS  03.0
085D:  GOTO   064
085E:  MOVLW  A0
085F:  ADDWF  45,W
0860:  MOVWF  04
0861:  BCF    03.7
0862:  MOVF   00,W
0863:  GOTO   06A
0864:  MOVLW  32
0865:  SUBWF  45,W
0866:  ADDLW  90
0867:  MOVWF  04
0868:  BSF    03.7
0869:  MOVF   00,W
086A:  BCF    03.5
086B:  BCF    03.6
086C:  SUBWF  5B,W
086D:  BTFSS  03.2
086E:  GOTO   075
....................             valid = 0; 
086F:  BSF    03.5
0870:  BSF    03.6
0871:  CLRF   44
....................             break; 
0872:  GOTO   079
0873:  BCF    03.5
0874:  BCF    03.6
....................          } 
0875:  BSF    03.5
0876:  BSF    03.6
0877:  INCF   45,F
0878:  GOTO   03B
....................       } 
0879:  GOTO   003
....................    } 
....................    fillCell(food[0], food[1], 1); 
087A:  BCF    03.5
087B:  BCF    03.6
087C:  MOVF   5A,W
087D:  BSF    03.5
087E:  BSF    03.6
087F:  MOVWF  46
0880:  BCF    03.5
0881:  BCF    03.6
0882:  MOVF   5B,W
0883:  BSF    03.5
0884:  BSF    03.6
0885:  MOVWF  47
0886:  MOVLW  01
0887:  MOVWF  48
0888:  BCF    0A.3
0889:  BCF    03.5
088A:  BCF    03.6
088B:  CALL   76B
088C:  BSF    0A.3
088D:  RETURN
.................... } 
....................  
.................... void gameover() { 
....................    LENGTH_SNAKE = 5; 
*
07B7:  MOVLW  05
07B8:  MOVWF  5C
....................    posX = 0; 
07B9:  CLRF   5D
....................    posY = 2; 
07BA:  MOVLW  02
07BB:  MOVWF  5E
....................    score = 0; 
07BC:  CLRF   5F
....................    score_txt[7] = '0'; 
07BD:  MOVLW  30
07BE:  MOVWF  68
....................    score_txt[8] = '0'; 
07BF:  MOVWF  69
....................    dir = 2; 
07C0:  MOVLW  02
07C1:  MOVWF  59
....................  
....................    glcd_fillScreen(0); 
07C2:  BSF    03.5
07C3:  BSF    03.6
07C4:  CLRF   45
07C5:  BCF    03.5
07C6:  BCF    03.6
07C7:  CALL   245
....................    glcd_text57(25, 30, gameover_msg, 1, 1); 
07C8:  MOVLW  19
07C9:  BSF    03.5
07CA:  BSF    03.6
07CB:  MOVWF  44
07CC:  MOVLW  1E
07CD:  MOVWF  45
07CE:  CLRF   47
07CF:  MOVLW  D2
07D0:  MOVWF  46
07D1:  MOVLW  01
07D2:  MOVWF  48
07D3:  MOVWF  49
07D4:  BCF    03.5
07D5:  BCF    03.6
07D6:  CALL   402
....................    delay_ms(1500); 
07D7:  MOVLW  06
07D8:  BSF    03.5
07D9:  BSF    03.6
07DA:  MOVWF  44
07DB:  MOVLW  FA
07DC:  MOVWF  46
07DD:  BCF    03.5
07DE:  BCF    03.6
07DF:  CALL   330
07E0:  BSF    03.5
07E1:  BSF    03.6
07E2:  DECFSZ 44,F
07E3:  GOTO   7DB
....................    screenWipeDown(); 
07E4:  BCF    03.5
07E5:  BCF    03.6
07E6:  CALL   519
....................    glcd_fillScreen(0); 
07E7:  BSF    03.5
07E8:  BSF    03.6
07E9:  CLRF   45
07EA:  BCF    03.5
07EB:  BCF    03.6
07EC:  CALL   245
....................    drawGrid(); 
07ED:  CALL   638
07EE:  RETURN
.................... } 
....................  
.................... void winScreen() { 
....................    glcd_fillScreen(0); 
*
088E:  BSF    03.5
088F:  BSF    03.6
0890:  CLRF   45
0891:  BCF    0A.3
0892:  BCF    03.5
0893:  BCF    03.6
0894:  CALL   245
0895:  BSF    0A.3
....................    glcd_text57(35, 35, win_msg, 1, 1); 
0896:  MOVLW  23
0897:  BSF    03.5
0898:  BSF    03.6
0899:  MOVWF  44
089A:  MOVWF  45
089B:  CLRF   47
089C:  MOVLW  E0
089D:  MOVWF  46
089E:  MOVLW  01
089F:  MOVWF  48
08A0:  MOVWF  49
08A1:  BCF    0A.3
08A2:  BCF    03.5
08A3:  BCF    03.6
08A4:  CALL   402
08A5:  BSF    0A.3
....................    delay_ms(2500); 
08A6:  MOVLW  0A
08A7:  BSF    03.5
08A8:  BSF    03.6
08A9:  MOVWF  44
08AA:  MOVLW  FA
08AB:  MOVWF  46
08AC:  BCF    0A.3
08AD:  BCF    03.5
08AE:  BCF    03.6
08AF:  CALL   330
08B0:  BSF    0A.3
08B1:  BSF    03.5
08B2:  BSF    03.6
08B3:  DECFSZ 44,F
08B4:  GOTO   0AA
....................    screenWipeDown(); 
08B5:  BCF    0A.3
08B6:  BCF    03.5
08B7:  BCF    03.6
08B8:  CALL   519
08B9:  BSF    0A.3
....................    glcd_fillScreen(0); 
08BA:  BSF    03.5
08BB:  BSF    03.6
08BC:  CLRF   45
08BD:  BCF    0A.3
08BE:  BCF    03.5
08BF:  BCF    03.6
08C0:  CALL   245
08C1:  BSF    0A.3
....................    drawGrid(); 
08C2:  BCF    0A.3
08C3:  CALL   638
08C4:  BSF    0A.3
....................    LENGTH_SNAKE = 5; 
08C5:  MOVLW  05
08C6:  MOVWF  5C
....................    posX = 0; 
08C7:  CLRF   5D
....................    posY = 2; 
08C8:  MOVLW  02
08C9:  MOVWF  5E
....................    score = 0; 
08CA:  CLRF   5F
....................    score_txt[7] = '0'; 
08CB:  MOVLW  30
08CC:  MOVWF  68
....................    score_txt[8] = '0'; 
08CD:  MOVWF  69
....................    dir = 2; 
08CE:  MOVLW  02
08CF:  MOVWF  59
08D0:  BSF    0A.3
08D1:  BCF    0A.4
08D2:  GOTO   3D7 (RETURN)
.................... } 
....................  
.................... void showSplashScreen() { 
....................    glcd_fillScreen(0); 
*
04F1:  BSF    03.5
04F2:  BSF    03.6
04F3:  CLRF   45
04F4:  BCF    03.5
04F5:  BCF    03.6
04F6:  CALL   245
....................    glcd_text57(20, 25, splash_text, 1, 1); 
04F7:  MOVLW  14
04F8:  BSF    03.5
04F9:  BSF    03.6
04FA:  MOVWF  44
04FB:  MOVLW  19
04FC:  MOVWF  45
04FD:  MOVLW  01
04FE:  MOVWF  47
04FF:  MOVLW  42
0500:  MOVWF  46
0501:  MOVLW  01
0502:  MOVWF  48
0503:  MOVWF  49
0504:  BCF    03.5
0505:  BCF    03.6
0506:  CALL   402
....................    delay_ms(2000); 
0507:  MOVLW  08
0508:  BSF    03.5
0509:  BSF    03.6
050A:  MOVWF  44
050B:  MOVLW  FA
050C:  MOVWF  46
050D:  BCF    03.5
050E:  BCF    03.6
050F:  CALL   330
0510:  BSF    03.5
0511:  BSF    03.6
0512:  DECFSZ 44,F
0513:  GOTO   50B
0514:  BCF    03.6
0515:  BCF    03.5
0516:  BSF    0A.3
0517:  BCF    0A.4
0518:  GOTO   18D (RETURN)
.................... } 
....................  
.................... void main() { 
*
08EC:  MOVF   03,W
08ED:  ANDLW  1F
08EE:  MOVWF  03
08EF:  MOVLW  FF
08F0:  MOVWF  26
08F1:  MOVLW  02
08F2:  MOVWF  59
08F3:  MOVLW  05
08F4:  MOVWF  5C
08F5:  CLRF   5D
08F6:  MOVLW  02
08F7:  MOVWF  5E
08F8:  CLRF   5F
08F9:  CLRF   60
08FA:  BSF    7B.0
08FB:  BSF    03.5
08FC:  BSF    1F.0
08FD:  BSF    1F.1
08FE:  BSF    1F.2
08FF:  BCF    1F.3
0900:  MOVLW  07
0901:  MOVWF  1C
0902:  BCF    03.7
....................    glcd_init(ON); 
*
0968:  MOVLW  01
0969:  BSF    03.5
096A:  MOVWF  44
096B:  BCF    0A.3
096C:  BCF    03.5
096D:  BCF    03.6
096E:  GOTO   2B4
096F:  BSF    0A.3
....................    glcd_fillScreen(0); 
0970:  BSF    03.5
0971:  BSF    03.6
0972:  CLRF   45
0973:  BCF    0A.3
0974:  BCF    03.5
0975:  BCF    03.6
0976:  CALL   245
0977:  BSF    0A.3
....................    delay_ms(500); 
0978:  MOVLW  02
0979:  BSF    03.5
097A:  BSF    03.6
097B:  MOVWF  44
097C:  MOVLW  FA
097D:  MOVWF  46
097E:  BCF    0A.3
097F:  BCF    03.5
0980:  BCF    03.6
0981:  CALL   330
0982:  BSF    0A.3
0983:  BSF    03.5
0984:  BSF    03.6
0985:  DECFSZ 44,F
0986:  GOTO   17C
....................  
.................... Start: 
....................    if (isFirstStart) { 
0987:  BTFSS  7B.0
0988:  GOTO   194
....................       showSplashScreen(); 
0989:  BCF    0A.3
098A:  BCF    03.5
098B:  BCF    03.6
098C:  GOTO   4F1
098D:  BSF    0A.3
....................       screenWipeDown(); 
098E:  BCF    0A.3
098F:  CALL   519
0990:  BSF    0A.3
....................       isFirstStart = 0; 
0991:  BCF    7B.0
0992:  BSF    03.5
0993:  BSF    03.6
....................    } 
....................  
....................    glcd_fillScreen(0); 
0994:  CLRF   45
0995:  BCF    0A.3
0996:  BCF    03.5
0997:  BCF    03.6
0998:  CALL   245
0999:  BSF    0A.3
....................    drawGrid(); 
099A:  BCF    0A.3
099B:  CALL   638
099C:  BSF    0A.3
....................    writeScore(); 
099D:  BCF    0A.3
099E:  CALL   67D
099F:  BSF    0A.3
....................    criar_comida(); 
09A0:  CALL   000
....................  
....................    for (i = 0; i < LENGTH_SNAKE; i++) { 
09A1:  CLRF   76
09A2:  MOVF   5C,W
09A3:  SUBWF  76,W
09A4:  BTFSC  03.0
09A5:  GOTO   1FE
....................       setX(i, posX - i); 
09A6:  MOVF   76,W
09A7:  SUBLW  31
09A8:  BTFSS  03.0
09A9:  GOTO   1B2
09AA:  MOVLW  27
09AB:  ADDWF  76,W
09AC:  MOVWF  04
09AD:  BCF    03.7
09AE:  MOVF   76,W
09AF:  SUBWF  5D,W
09B0:  MOVWF  00
09B1:  GOTO   1BA
09B2:  MOVLW  32
09B3:  SUBWF  76,W
09B4:  ADDLW  10
09B5:  MOVWF  04
09B6:  BSF    03.7
09B7:  MOVF   76,W
09B8:  SUBWF  5D,W
09B9:  MOVWF  00
....................       setY(i, posY); 
09BA:  MOVF   76,W
09BB:  SUBLW  31
09BC:  BTFSS  03.0
09BD:  GOTO   1C6
09BE:  MOVLW  A0
09BF:  ADDWF  76,W
09C0:  MOVWF  04
09C1:  BCF    03.7
09C2:  MOVF   5E,W
09C3:  MOVWF  00
09C4:  MOVF   5E,W
09C5:  GOTO   1CD
09C6:  MOVLW  32
09C7:  SUBWF  76,W
09C8:  ADDLW  90
09C9:  MOVWF  04
09CA:  BSF    03.7
09CB:  MOVF   5E,W
09CC:  MOVWF  00
....................       fillCell(getX(i), getY(i), 1); 
09CD:  MOVF   76,W
09CE:  SUBLW  31
09CF:  BTFSS  03.0
09D0:  GOTO   1D7
09D1:  MOVLW  27
09D2:  ADDWF  76,W
09D3:  MOVWF  04
09D4:  BCF    03.7
09D5:  MOVF   00,W
09D6:  GOTO   1DD
09D7:  MOVLW  32
09D8:  SUBWF  76,W
09D9:  ADDLW  10
09DA:  MOVWF  04
09DB:  BSF    03.7
09DC:  MOVF   00,W
09DD:  BSF    03.5
09DE:  BSF    03.6
09DF:  MOVWF  44
09E0:  MOVF   76,W
09E1:  SUBLW  31
09E2:  BTFSS  03.0
09E3:  GOTO   1EA
09E4:  MOVLW  A0
09E5:  ADDWF  76,W
09E6:  MOVWF  04
09E7:  BCF    03.7
09E8:  MOVF   00,W
09E9:  GOTO   1F0
09EA:  MOVLW  32
09EB:  SUBWF  76,W
09EC:  ADDLW  90
09ED:  MOVWF  04
09EE:  BSF    03.7
09EF:  MOVF   00,W
09F0:  MOVWF  45
09F1:  MOVF   44,W
09F2:  MOVWF  46
09F3:  MOVF   45,W
09F4:  MOVWF  47
09F5:  MOVLW  01
09F6:  MOVWF  48
09F7:  BCF    0A.3
09F8:  BCF    03.5
09F9:  BCF    03.6
09FA:  CALL   76B
09FB:  BSF    0A.3
09FC:  INCF   76,F
09FD:  GOTO   1A2
....................    } 
....................  
....................    while (TRUE) { 
....................       if (input(PIN_C3) && dir != 0) dir = 3; 
09FE:  BSF    26.3
09FF:  MOVF   26,W
0A00:  BSF    03.5
0A01:  MOVWF  07
0A02:  BCF    03.5
0A03:  BTFSS  07.3
0A04:  GOTO   20A
0A05:  MOVF   59,F
0A06:  BTFSC  03.2
0A07:  GOTO   20A
0A08:  MOVLW  03
0A09:  MOVWF  59
....................       if (input(PIN_C2) && dir != 1) dir = 2; 
0A0A:  BSF    26.2
0A0B:  MOVF   26,W
0A0C:  BSF    03.5
0A0D:  MOVWF  07
0A0E:  BCF    03.5
0A0F:  BTFSS  07.2
0A10:  GOTO   216
0A11:  DECFSZ 59,W
0A12:  GOTO   214
0A13:  GOTO   216
0A14:  MOVLW  02
0A15:  MOVWF  59
....................       if (input(PIN_C1) && dir != 2) dir = 1; 
0A16:  BSF    26.1
0A17:  MOVF   26,W
0A18:  BSF    03.5
0A19:  MOVWF  07
0A1A:  BCF    03.5
0A1B:  BTFSS  07.1
0A1C:  GOTO   223
0A1D:  MOVF   59,W
0A1E:  SUBLW  02
0A1F:  BTFSC  03.2
0A20:  GOTO   223
0A21:  MOVLW  01
0A22:  MOVWF  59
....................       if (input(PIN_C4) && dir != 3) dir = 0; 
0A23:  BSF    26.4
0A24:  MOVF   26,W
0A25:  BSF    03.5
0A26:  MOVWF  07
0A27:  BCF    03.5
0A28:  BTFSS  07.4
0A29:  GOTO   22E
0A2A:  MOVF   59,W
0A2B:  SUBLW  03
0A2C:  BTFSS  03.2
0A2D:  CLRF   59
....................       if (input(PIN_C5)) { gameover(); goto Start; } 
0A2E:  BSF    26.5
0A2F:  MOVF   26,W
0A30:  BSF    03.5
0A31:  MOVWF  07
0A32:  BCF    03.5
0A33:  BTFSS  07.5
0A34:  GOTO   23D
0A35:  BCF    0A.3
0A36:  CALL   7B7
0A37:  BSF    0A.3
0A38:  BSF    03.5
0A39:  BSF    03.6
0A3A:  GOTO   187
0A3B:  BCF    03.5
0A3C:  BCF    03.6
....................  
....................       switch(dir) { 
0A3D:  MOVF   59,W
0A3E:  ADDLW  FC
0A3F:  BTFSC  03.0
0A40:  GOTO   28C
0A41:  ADDLW  04
0A42:  GOTO   42A
....................          case 0: if (posX == 0) { gameover(); goto Start; } else posX--; break; 
0A43:  MOVF   5D,F
0A44:  BTFSS  03.2
0A45:  GOTO   24F
0A46:  BCF    0A.3
0A47:  CALL   7B7
0A48:  BSF    0A.3
0A49:  BSF    03.5
0A4A:  BSF    03.6
0A4B:  GOTO   187
0A4C:  GOTO   252
0A4D:  BCF    03.5
0A4E:  BCF    03.6
0A4F:  DECF   5D,F
0A50:  BSF    03.5
0A51:  BSF    03.6
0A52:  BCF    03.5
0A53:  BCF    03.6
0A54:  GOTO   28C
....................          case 1: if (posY == 0) { gameover(); goto Start; } else posY--; break; 
0A55:  MOVF   5E,F
0A56:  BTFSS  03.2
0A57:  GOTO   261
0A58:  BCF    0A.3
0A59:  CALL   7B7
0A5A:  BSF    0A.3
0A5B:  BSF    03.5
0A5C:  BSF    03.6
0A5D:  GOTO   187
0A5E:  GOTO   264
0A5F:  BCF    03.5
0A60:  BCF    03.6
0A61:  DECF   5E,F
0A62:  BSF    03.5
0A63:  BSF    03.6
0A64:  BCF    03.5
0A65:  BCF    03.6
0A66:  GOTO   28C
....................          case 2: if (posY == GRID_ROWS - 1) { gameover(); goto Start; } else posY++; break; 
0A67:  MOVF   5E,W
0A68:  SUBLW  09
0A69:  BTFSS  03.2
0A6A:  GOTO   274
0A6B:  BCF    0A.3
0A6C:  CALL   7B7
0A6D:  BSF    0A.3
0A6E:  BSF    03.5
0A6F:  BSF    03.6
0A70:  GOTO   187
0A71:  GOTO   277
0A72:  BCF    03.5
0A73:  BCF    03.6
0A74:  INCF   5E,F
0A75:  BSF    03.5
0A76:  BSF    03.6
0A77:  BCF    03.5
0A78:  BCF    03.6
0A79:  GOTO   28C
....................          case 3: if (posX == GRID_COLS - 1) { gameover(); goto Start; } else posX++; break; 
0A7A:  MOVF   5D,W
0A7B:  SUBLW  09
0A7C:  BTFSS  03.2
0A7D:  GOTO   287
0A7E:  BCF    0A.3
0A7F:  CALL   7B7
0A80:  BSF    0A.3
0A81:  BSF    03.5
0A82:  BSF    03.6
0A83:  GOTO   187
0A84:  GOTO   28A
0A85:  BCF    03.5
0A86:  BCF    03.6
0A87:  INCF   5D,F
0A88:  BSF    03.5
0A89:  BSF    03.6
0A8A:  BCF    03.5
0A8B:  BCF    03.6
....................       } 
....................  
....................       uchar tailX = getX(0), tailY = getY(0); 
0A8C:  MOVF   27,W
0A8D:  BSF    03.5
0A8E:  BSF    03.6
0A8F:  MOVWF  42
0A90:  BCF    03.6
0A91:  MOVF   20,W
0A92:  BSF    03.6
0A93:  MOVWF  43
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
0A94:  CLRF   76
0A95:  MOVLW  01
0A96:  BCF    03.5
0A97:  BCF    03.6
0A98:  SUBWF  5C,W
0A99:  SUBWF  76,W
0A9A:  BTFSC  03.0
0A9B:  GOTO   34A
....................          setX(i, getX(i + 1)); 
0A9C:  MOVF   76,W
0A9D:  SUBLW  31
0A9E:  BTFSS  03.0
0A9F:  GOTO   2CB
0AA0:  MOVLW  27
0AA1:  ADDWF  76,W
0AA2:  MOVWF  78
0AA3:  CLRF   7A
0AA4:  BTFSC  03.0
0AA5:  INCF   7A,F
0AA6:  MOVF   78,W
0AA7:  BSF    03.5
0AA8:  BSF    03.6
0AA9:  MOVWF  44
0AAA:  MOVF   7A,W
0AAB:  MOVWF  45
0AAC:  MOVLW  01
0AAD:  ADDWF  76,W
0AAE:  SUBLW  31
0AAF:  BTFSS  03.0
0AB0:  GOTO   2B8
0AB1:  MOVLW  01
0AB2:  ADDWF  76,W
0AB3:  ADDLW  27
0AB4:  MOVWF  04
0AB5:  BCF    03.7
0AB6:  MOVF   00,W
0AB7:  GOTO   2BF
0AB8:  MOVLW  01
0AB9:  ADDWF  76,W
0ABA:  ADDLW  CE
0ABB:  ADDLW  10
0ABC:  MOVWF  04
0ABD:  BSF    03.7
0ABE:  MOVF   00,W
0ABF:  MOVWF  46
0AC0:  MOVF   44,W
0AC1:  MOVWF  04
0AC2:  BCF    03.7
0AC3:  BTFSC  45.0
0AC4:  BSF    03.7
0AC5:  MOVF   46,W
0AC6:  MOVWF  00
0AC7:  MOVF   46,W
0AC8:  GOTO   2F4
0AC9:  BCF    03.5
0ACA:  BCF    03.6
0ACB:  MOVLW  32
0ACC:  SUBWF  76,W
0ACD:  ADDLW  10
0ACE:  MOVWF  78
0ACF:  MOVLW  01
0AD0:  MOVWF  7A
0AD1:  BTFSC  03.0
0AD2:  INCF   7A,F
0AD3:  MOVF   78,W
0AD4:  BSF    03.5
0AD5:  BSF    03.6
0AD6:  MOVWF  46
0AD7:  MOVF   7A,W
0AD8:  MOVWF  47
0AD9:  MOVLW  01
0ADA:  ADDWF  76,W
0ADB:  SUBLW  31
0ADC:  BTFSS  03.0
0ADD:  GOTO   2E5
0ADE:  MOVLW  01
0ADF:  ADDWF  76,W
0AE0:  ADDLW  27
0AE1:  MOVWF  04
0AE2:  BCF    03.7
0AE3:  MOVF   00,W
0AE4:  GOTO   2EC
0AE5:  MOVLW  01
0AE6:  ADDWF  76,W
0AE7:  ADDLW  CE
0AE8:  ADDLW  10
0AE9:  MOVWF  04
0AEA:  BSF    03.7
0AEB:  MOVF   00,W
0AEC:  MOVWF  44
0AED:  MOVF   46,W
0AEE:  MOVWF  04
0AEF:  BCF    03.7
0AF0:  BTFSC  47.0
0AF1:  BSF    03.7
0AF2:  MOVF   44,W
0AF3:  MOVWF  00
....................          setY(i, getY(i + 1)); 
0AF4:  MOVF   76,W
0AF5:  SUBLW  31
0AF6:  BTFSS  03.0
0AF7:  GOTO   31F
0AF8:  MOVLW  A0
0AF9:  ADDWF  76,W
0AFA:  MOVWF  78
0AFB:  CLRF   7A
0AFC:  BTFSC  03.0
0AFD:  INCF   7A,F
0AFE:  MOVF   78,W
0AFF:  MOVWF  44
0B00:  MOVF   7A,W
0B01:  MOVWF  45
0B02:  MOVLW  01
0B03:  ADDWF  76,W
0B04:  SUBLW  31
0B05:  BTFSS  03.0
0B06:  GOTO   30E
0B07:  MOVLW  01
0B08:  ADDWF  76,W
0B09:  ADDLW  A0
0B0A:  MOVWF  04
0B0B:  BCF    03.7
0B0C:  MOVF   00,W
0B0D:  GOTO   315
0B0E:  MOVLW  01
0B0F:  ADDWF  76,W
0B10:  ADDLW  CE
0B11:  ADDLW  90
0B12:  MOVWF  04
0B13:  BSF    03.7
0B14:  MOVF   00,W
0B15:  MOVWF  46
0B16:  MOVF   44,W
0B17:  MOVWF  04
0B18:  BCF    03.7
0B19:  BTFSC  45.0
0B1A:  BSF    03.7
0B1B:  MOVF   46,W
0B1C:  MOVWF  00
0B1D:  MOVF   46,W
0B1E:  GOTO   346
0B1F:  MOVLW  32
0B20:  SUBWF  76,W
0B21:  ADDLW  90
0B22:  MOVWF  78
0B23:  MOVLW  01
0B24:  MOVWF  7A
0B25:  BTFSC  03.0
0B26:  INCF   7A,F
0B27:  MOVF   78,W
0B28:  MOVWF  46
0B29:  MOVF   7A,W
0B2A:  MOVWF  47
0B2B:  MOVLW  01
0B2C:  ADDWF  76,W
0B2D:  SUBLW  31
0B2E:  BTFSS  03.0
0B2F:  GOTO   337
0B30:  MOVLW  01
0B31:  ADDWF  76,W
0B32:  ADDLW  A0
0B33:  MOVWF  04
0B34:  BCF    03.7
0B35:  MOVF   00,W
0B36:  GOTO   33E
0B37:  MOVLW  01
0B38:  ADDWF  76,W
0B39:  ADDLW  CE
0B3A:  ADDLW  90
0B3B:  MOVWF  04
0B3C:  BSF    03.7
0B3D:  MOVF   00,W
0B3E:  MOVWF  44
0B3F:  MOVF   46,W
0B40:  MOVWF  04
0B41:  BCF    03.7
0B42:  BTFSC  47.0
0B43:  BSF    03.7
0B44:  MOVF   44,W
0B45:  MOVWF  00
0B46:  INCF   76,F
0B47:  GOTO   295
0B48:  BCF    03.5
0B49:  BCF    03.6
....................       } 
....................       setX(LENGTH_SNAKE - 1, posX); 
0B4A:  MOVLW  01
0B4B:  SUBWF  5C,W
0B4C:  SUBLW  31
0B4D:  BTFSS  03.0
0B4E:  GOTO   358
0B4F:  MOVLW  01
0B50:  SUBWF  5C,W
0B51:  ADDLW  27
0B52:  MOVWF  04
0B53:  BCF    03.7
0B54:  MOVF   5D,W
0B55:  MOVWF  00
0B56:  MOVF   5D,W
0B57:  GOTO   360
0B58:  MOVLW  01
0B59:  SUBWF  5C,W
0B5A:  ADDLW  CE
0B5B:  ADDLW  10
0B5C:  MOVWF  04
0B5D:  BSF    03.7
0B5E:  MOVF   5D,W
0B5F:  MOVWF  00
....................       setY(LENGTH_SNAKE - 1, posY); 
0B60:  MOVLW  01
0B61:  SUBWF  5C,W
0B62:  SUBLW  31
0B63:  BTFSS  03.0
0B64:  GOTO   36E
0B65:  MOVLW  01
0B66:  SUBWF  5C,W
0B67:  ADDLW  A0
0B68:  MOVWF  04
0B69:  BCF    03.7
0B6A:  MOVF   5E,W
0B6B:  MOVWF  00
0B6C:  MOVF   5E,W
0B6D:  GOTO   376
0B6E:  MOVLW  01
0B6F:  SUBWF  5C,W
0B70:  ADDLW  CE
0B71:  ADDLW  90
0B72:  MOVWF  04
0B73:  BSF    03.7
0B74:  MOVF   5E,W
0B75:  MOVWF  00
....................  
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
0B76:  CLRF   76
0B77:  MOVLW  01
0B78:  SUBWF  5C,W
0B79:  SUBWF  76,W
0B7A:  BTFSC  03.0
0B7B:  GOTO   3AC
....................          if (getX(i) == posX && getY(i) == posY) { 
0B7C:  MOVF   76,W
0B7D:  SUBLW  31
0B7E:  BTFSS  03.0
0B7F:  GOTO   386
0B80:  MOVLW  27
0B81:  ADDWF  76,W
0B82:  MOVWF  04
0B83:  BCF    03.7
0B84:  MOVF   00,W
0B85:  GOTO   38C
0B86:  MOVLW  32
0B87:  SUBWF  76,W
0B88:  ADDLW  10
0B89:  MOVWF  04
0B8A:  BSF    03.7
0B8B:  MOVF   00,W
0B8C:  SUBWF  5D,W
0B8D:  BTFSS  03.2
0B8E:  GOTO   3AA
0B8F:  MOVF   76,W
0B90:  SUBLW  31
0B91:  BTFSS  03.0
0B92:  GOTO   399
0B93:  MOVLW  A0
0B94:  ADDWF  76,W
0B95:  MOVWF  04
0B96:  BCF    03.7
0B97:  MOVF   00,W
0B98:  GOTO   39F
0B99:  MOVLW  32
0B9A:  SUBWF  76,W
0B9B:  ADDLW  90
0B9C:  MOVWF  04
0B9D:  BSF    03.7
0B9E:  MOVF   00,W
0B9F:  SUBWF  5E,W
0BA0:  BTFSS  03.2
0BA1:  GOTO   3AA
....................             gameover(); goto Start; 
0BA2:  BCF    0A.3
0BA3:  CALL   7B7
0BA4:  BSF    0A.3
0BA5:  BSF    03.5
0BA6:  BSF    03.6
0BA7:  GOTO   187
0BA8:  BCF    03.5
0BA9:  BCF    03.6
....................          } 
0BAA:  INCF   76,F
0BAB:  GOTO   377
....................       } 
....................  
....................       fillCell(posX, posY, 1); 
0BAC:  MOVF   5D,W
0BAD:  BSF    03.5
0BAE:  BSF    03.6
0BAF:  MOVWF  46
0BB0:  BCF    03.5
0BB1:  BCF    03.6
0BB2:  MOVF   5E,W
0BB3:  BSF    03.5
0BB4:  BSF    03.6
0BB5:  MOVWF  47
0BB6:  MOVLW  01
0BB7:  MOVWF  48
0BB8:  BCF    0A.3
0BB9:  BCF    03.5
0BBA:  BCF    03.6
0BBB:  CALL   76B
0BBC:  BSF    0A.3
....................       fillCell(tailX, tailY, 0); 
0BBD:  BSF    03.5
0BBE:  BSF    03.6
0BBF:  MOVF   42,W
0BC0:  MOVWF  46
0BC1:  MOVF   43,W
0BC2:  MOVWF  47
0BC3:  CLRF   48
0BC4:  BCF    0A.3
0BC5:  BCF    03.5
0BC6:  BCF    03.6
0BC7:  CALL   76B
0BC8:  BSF    0A.3
....................  
....................       if (posX == food[0] && posY == food[1]) { 
0BC9:  MOVF   5A,W
0BCA:  SUBWF  5D,W
0BCB:  BTFSS  03.2
0BCC:  GOTO   417
0BCD:  MOVF   5B,W
0BCE:  SUBWF  5E,W
0BCF:  BTFSS  03.2
0BD0:  GOTO   417
....................          LENGTH_SNAKE++; 
0BD1:  INCF   5C,F
....................          if (LENGTH_SNAKE >= 100) { 
0BD2:  MOVF   5C,W
0BD3:  SUBLW  63
0BD4:  BTFSC  03.0
0BD5:  GOTO   3DC
....................             winScreen(); goto Start; 
0BD6:  GOTO   08E
0BD7:  BSF    03.5
0BD8:  BSF    03.6
0BD9:  GOTO   187
0BDA:  BCF    03.5
0BDB:  BCF    03.6
....................          } 
....................          criar_comida(); 
0BDC:  CALL   000
....................          score++; 
0BDD:  INCF   5F,F
....................          score_txt[7] = '0' + (score / 10); 
0BDE:  MOVF   5F,W
0BDF:  BSF    03.5
0BE0:  BSF    03.6
0BE1:  MOVWF  44
0BE2:  MOVLW  0A
0BE3:  MOVWF  45
0BE4:  BCF    03.5
0BE5:  BCF    03.6
0BE6:  CALL   0D3
0BE7:  MOVF   78,W
0BE8:  ADDLW  30
0BE9:  MOVWF  68
....................          score_txt[8] = '0' + (score % 10); 
0BEA:  MOVF   5F,W
0BEB:  BSF    03.5
0BEC:  BSF    03.6
0BED:  MOVWF  44
0BEE:  MOVLW  0A
0BEF:  MOVWF  45
0BF0:  BCF    03.5
0BF1:  BCF    03.6
0BF2:  CALL   0D3
0BF3:  MOVF   77,W
0BF4:  ADDLW  30
0BF5:  MOVWF  69
....................  
....................          if (score > best_score) { 
0BF6:  MOVF   5F,W
0BF7:  SUBWF  60,W
0BF8:  BTFSC  03.0
0BF9:  GOTO   414
....................             best_score = score; 
0BFA:  MOVF   5F,W
0BFB:  MOVWF  60
....................             best_score_txt[7] = '0' + (best_score / 10); 
0BFC:  MOVF   60,W
0BFD:  BSF    03.5
0BFE:  BSF    03.6
0BFF:  MOVWF  44
0C00:  MOVLW  0A
0C01:  MOVWF  45
0C02:  BCF    03.5
0C03:  BCF    03.6
0C04:  CALL   0D3
0C05:  MOVF   78,W
0C06:  ADDLW  30
0C07:  MOVWF  73
....................             best_score_txt[8] = '0' + (best_score % 10); 
0C08:  MOVF   60,W
0C09:  BSF    03.5
0C0A:  BSF    03.6
0C0B:  MOVWF  44
0C0C:  MOVLW  0A
0C0D:  MOVWF  45
0C0E:  BCF    03.5
0C0F:  BCF    03.6
0C10:  CALL   0D3
0C11:  MOVF   77,W
0C12:  ADDLW  30
0C13:  MOVWF  74
....................          } 
....................  
....................          writeScore(); 
0C14:  BCF    0A.3
0C15:  CALL   67D
0C16:  BSF    0A.3
....................       } 
....................  
....................       delay_ms(600); 
0C17:  MOVLW  03
0C18:  BSF    03.5
0C19:  BSF    03.6
0C1A:  MOVWF  44
0C1B:  MOVLW  C8
0C1C:  MOVWF  46
0C1D:  BCF    0A.3
0C1E:  BCF    03.5
0C1F:  BCF    03.6
0C20:  CALL   330
0C21:  BSF    0A.3
0C22:  BSF    03.5
0C23:  BSF    03.6
0C24:  DECFSZ 44,F
0C25:  GOTO   41B
0C26:  BCF    03.5
0C27:  BCF    03.6
0C28:  GOTO   1FE
....................    } 
.................... } 
....................  
0C29:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
