CCS PCM C Compiler, Version 5.025, 5967               30-May-25 22:41

               Filename:   C:\Users\Eren\Documents\CCS C Projects\snake_project\main.lst

               ROM used:   3571 words (44%)
                           Largest free fragment is 2048
               RAM used:   228 (62%) at main() level
                           274 (74%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   2A7
0003:  NOP
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDLW  0B
0008:  BTFSC  03.0
0009:  INCF   0A,F
000A:  MOVWF  02
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  5F
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  03
0017:  RETLW  00
0018:  RETLW  03
0019:  RETLW  00
001A:  RETLW  14
001B:  RETLW  3E
001C:  RETLW  14
001D:  RETLW  3E
001E:  RETLW  14
001F:  RETLW  24
0020:  RETLW  2A
0021:  RETLW  7F
0022:  RETLW  2A
0023:  RETLW  12
0024:  RETLW  43
0025:  RETLW  33
0026:  RETLW  08
0027:  RETLW  66
0028:  RETLW  61
0029:  RETLW  36
002A:  RETLW  49
002B:  RETLW  55
002C:  RETLW  22
002D:  RETLW  50
002E:  RETLW  00
002F:  RETLW  05
0030:  RETLW  03
0031:  RETLW  00
0032:  RETLW  00
0033:  RETLW  00
0034:  RETLW  1C
0035:  RETLW  22
0036:  RETLW  41
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  41
003A:  RETLW  22
003B:  RETLW  1C
003C:  RETLW  00
003D:  RETLW  14
003E:  RETLW  08
003F:  RETLW  3E
0040:  RETLW  08
0041:  RETLW  14
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  3E
0045:  RETLW  08
0046:  RETLW  08
0047:  RETLW  00
0048:  RETLW  50
0049:  RETLW  30
004A:  RETLW  00
004B:  RETLW  00
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  08
004F:  RETLW  08
0050:  RETLW  08
0051:  RETLW  00
0052:  RETLW  60
0053:  RETLW  60
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  20
0057:  RETLW  10
0058:  RETLW  08
0059:  RETLW  04
005A:  RETLW  02
005B:  RETLW  3E
005C:  RETLW  51
005D:  RETLW  49
005E:  RETLW  45
005F:  RETLW  3E
0060:  RETLW  04
0061:  RETLW  02
0062:  RETLW  7F
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  61
0067:  RETLW  51
0068:  RETLW  49
0069:  RETLW  46
006A:  RETLW  22
006B:  RETLW  41
006C:  RETLW  49
006D:  RETLW  49
006E:  RETLW  36
006F:  RETLW  18
0070:  RETLW  14
0071:  RETLW  12
0072:  RETLW  7F
0073:  RETLW  10
0074:  RETLW  27
0075:  RETLW  45
0076:  RETLW  45
0077:  RETLW  45
0078:  RETLW  39
0079:  RETLW  3E
007A:  RETLW  49
007B:  RETLW  49
007C:  RETLW  49
007D:  RETLW  32
007E:  RETLW  01
007F:  RETLW  01
0080:  RETLW  71
0081:  RETLW  09
0082:  RETLW  07
0083:  RETLW  36
0084:  RETLW  49
0085:  RETLW  49
0086:  RETLW  49
0087:  RETLW  36
0088:  RETLW  26
0089:  RETLW  49
008A:  RETLW  49
008B:  RETLW  49
008C:  RETLW  3E
008D:  RETLW  00
008E:  RETLW  36
008F:  RETLW  36
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  56
0094:  RETLW  36
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  08
0098:  RETLW  14
0099:  RETLW  22
009A:  RETLW  41
009B:  RETLW  00
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  14
009F:  RETLW  14
00A0:  RETLW  14
00A1:  RETLW  00
00A2:  RETLW  41
00A3:  RETLW  22
00A4:  RETLW  14
00A5:  RETLW  08
00A6:  RETLW  02
00A7:  RETLW  01
00A8:  RETLW  51
00A9:  RETLW  09
00AA:  RETLW  06
00AB:  RETLW  3E
00AC:  RETLW  41
00AD:  RETLW  59
00AE:  RETLW  55
00AF:  RETLW  5E
00B0:  RETLW  7E
00B1:  RETLW  09
00B2:  RETLW  09
00B3:  RETLW  09
00B4:  RETLW  7E
00B5:  RETLW  7F
00B6:  RETLW  49
00B7:  RETLW  49
00B8:  RETLW  49
00B9:  RETLW  36
00BA:  RETLW  3E
00BB:  RETLW  41
00BC:  RETLW  41
00BD:  RETLW  41
00BE:  RETLW  22
00BF:  RETLW  7F
00C0:  RETLW  41
00C1:  RETLW  41
00C2:  RETLW  41
00C3:  RETLW  3E
00C4:  RETLW  7F
00C5:  RETLW  49
00C6:  RETLW  49
00C7:  RETLW  49
00C8:  RETLW  41
00C9:  RETLW  7F
00CA:  RETLW  09
00CB:  RETLW  09
00CC:  RETLW  09
00CD:  RETLW  01
00CE:  RETLW  3E
00CF:  RETLW  41
00D0:  RETLW  41
00D1:  RETLW  49
00D2:  RETLW  3A
00D3:  RETLW  7F
00D4:  RETLW  08
00D5:  RETLW  08
00D6:  RETLW  08
00D7:  RETLW  7F
00D8:  RETLW  00
00D9:  RETLW  41
00DA:  RETLW  7F
00DB:  RETLW  41
00DC:  RETLW  00
00DD:  RETLW  30
00DE:  RETLW  40
00DF:  RETLW  40
00E0:  RETLW  40
00E1:  RETLW  3F
00E2:  RETLW  7F
00E3:  RETLW  08
00E4:  RETLW  14
00E5:  RETLW  22
00E6:  RETLW  41
00E7:  RETLW  7F
00E8:  RETLW  40
00E9:  RETLW  40
00EA:  RETLW  40
00EB:  RETLW  40
00EC:  RETLW  7F
00ED:  RETLW  02
00EE:  RETLW  0C
00EF:  RETLW  02
00F0:  RETLW  7F
00F1:  RETLW  7F
00F2:  RETLW  02
00F3:  RETLW  04
00F4:  RETLW  08
00F5:  RETLW  7F
00F6:  RETLW  3E
00F7:  RETLW  41
00F8:  RETLW  41
00F9:  RETLW  41
00FA:  RETLW  3E
00FB:  RETLW  7F
00FC:  RETLW  09
00FD:  RETLW  09
00FE:  RETLW  09
00FF:  RETLW  06
0100:  RETLW  1E
0101:  RETLW  21
0102:  RETLW  21
0103:  RETLW  21
0104:  RETLW  5E
0105:  RETLW  7F
0106:  RETLW  09
0107:  RETLW  09
0108:  RETLW  09
0109:  RETLW  76
010A:  BSF    0A.0
010B:  BCF    0A.1
010C:  BCF    0A.2
010D:  ADDWF  02,F
010E:  RETLW  26
010F:  RETLW  49
0110:  RETLW  49
0111:  RETLW  49
0112:  RETLW  32
0113:  RETLW  01
0114:  RETLW  01
0115:  RETLW  7F
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  3F
0119:  RETLW  40
011A:  RETLW  40
011B:  RETLW  40
011C:  RETLW  3F
011D:  RETLW  1F
011E:  RETLW  20
011F:  RETLW  40
0120:  RETLW  20
0121:  RETLW  1F
0122:  RETLW  7F
0123:  RETLW  20
0124:  RETLW  10
0125:  RETLW  20
0126:  RETLW  7F
0127:  RETLW  41
0128:  RETLW  22
0129:  RETLW  1C
012A:  RETLW  22
012B:  RETLW  41
012C:  RETLW  07
012D:  RETLW  08
012E:  RETLW  70
012F:  RETLW  08
0130:  RETLW  07
0131:  RETLW  61
0132:  RETLW  51
0133:  RETLW  49
0134:  RETLW  45
0135:  RETLW  43
0136:  RETLW  00
0137:  RETLW  7F
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  02
013C:  RETLW  04
013D:  RETLW  08
013E:  RETLW  10
013F:  RETLW  20
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  41
0143:  RETLW  7F
0144:  RETLW  00
0145:  RETLW  04
0146:  RETLW  02
0147:  RETLW  01
0148:  RETLW  02
0149:  RETLW  04
014A:  RETLW  40
014B:  RETLW  40
014C:  RETLW  40
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  00
0150:  RETLW  01
0151:  RETLW  02
0152:  RETLW  04
0153:  RETLW  00
0154:  RETLW  20
0155:  RETLW  54
0156:  RETLW  54
0157:  RETLW  54
0158:  RETLW  78
0159:  RETLW  7F
015A:  RETLW  44
015B:  RETLW  44
015C:  RETLW  44
015D:  RETLW  38
015E:  RETLW  38
015F:  RETLW  44
0160:  RETLW  44
0161:  RETLW  44
0162:  RETLW  44
0163:  RETLW  38
0164:  RETLW  44
0165:  RETLW  44
0166:  RETLW  44
0167:  RETLW  7F
0168:  RETLW  38
0169:  RETLW  54
016A:  RETLW  54
016B:  RETLW  54
016C:  RETLW  18
016D:  RETLW  04
016E:  RETLW  04
016F:  RETLW  7E
0170:  RETLW  05
0171:  RETLW  05
0172:  RETLW  08
0173:  RETLW  54
0174:  RETLW  54
0175:  RETLW  54
0176:  RETLW  3C
0177:  RETLW  7F
0178:  RETLW  08
0179:  RETLW  04
017A:  RETLW  04
017B:  RETLW  78
017C:  RETLW  00
017D:  RETLW  44
017E:  RETLW  7D
017F:  RETLW  40
0180:  RETLW  00
0181:  RETLW  20
0182:  RETLW  40
0183:  RETLW  44
0184:  RETLW  3D
0185:  RETLW  00
0186:  RETLW  7F
0187:  RETLW  10
0188:  RETLW  28
0189:  RETLW  44
018A:  RETLW  00
018B:  RETLW  00
018C:  RETLW  41
018D:  RETLW  7F
018E:  RETLW  40
018F:  RETLW  00
0190:  RETLW  7C
0191:  RETLW  04
0192:  RETLW  78
0193:  RETLW  04
0194:  RETLW  78
0195:  RETLW  7C
0196:  RETLW  08
0197:  RETLW  04
0198:  RETLW  04
0199:  RETLW  78
019A:  RETLW  38
019B:  RETLW  44
019C:  RETLW  44
019D:  RETLW  44
019E:  RETLW  38
019F:  RETLW  7C
01A0:  RETLW  14
01A1:  RETLW  14
01A2:  RETLW  14
01A3:  RETLW  08
01A4:  RETLW  08
01A5:  RETLW  14
01A6:  RETLW  14
01A7:  RETLW  14
01A8:  RETLW  7C
01A9:  RETLW  00
01AA:  RETLW  7C
01AB:  RETLW  08
01AC:  RETLW  04
01AD:  RETLW  04
01AE:  RETLW  48
01AF:  RETLW  54
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  20
01B3:  RETLW  04
01B4:  RETLW  04
01B5:  RETLW  3F
01B6:  RETLW  44
01B7:  RETLW  44
01B8:  RETLW  3C
01B9:  RETLW  40
01BA:  RETLW  40
01BB:  RETLW  20
01BC:  RETLW  7C
01BD:  RETLW  1C
01BE:  RETLW  20
01BF:  RETLW  40
01C0:  RETLW  20
01C1:  RETLW  1C
01C2:  RETLW  3C
01C3:  RETLW  40
01C4:  RETLW  30
01C5:  RETLW  40
01C6:  RETLW  3C
01C7:  RETLW  44
01C8:  RETLW  28
01C9:  RETLW  10
01CA:  RETLW  28
01CB:  RETLW  44
01CC:  RETLW  0C
01CD:  RETLW  50
01CE:  RETLW  50
01CF:  RETLW  50
01D0:  RETLW  3C
01D1:  RETLW  44
01D2:  RETLW  64
01D3:  RETLW  54
01D4:  RETLW  4C
01D5:  RETLW  44
01D6:  RETLW  00
01D7:  RETLW  08
01D8:  RETLW  36
01D9:  RETLW  41
01DA:  RETLW  41
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  7F
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  41
01E1:  RETLW  41
01E2:  RETLW  36
01E3:  RETLW  08
01E4:  RETLW  00
01E5:  RETLW  02
01E6:  RETLW  01
01E7:  RETLW  02
01E8:  RETLW  04
01E9:  RETLW  02
*
021C:  CLRF   77
021D:  CLRF   78
021E:  BSF    03.5
021F:  BSF    03.6
0220:  MOVF   12,W
0221:  BCF    03.0
0222:  BTFSC  13.0
0223:  ADDWF  77,F
0224:  RRF    77,F
0225:  RRF    78,F
0226:  BTFSC  13.1
0227:  ADDWF  77,F
0228:  RRF    77,F
0229:  RRF    78,F
022A:  BTFSC  13.2
022B:  ADDWF  77,F
022C:  RRF    77,F
022D:  RRF    78,F
022E:  BTFSC  13.3
022F:  ADDWF  77,F
0230:  RRF    77,F
0231:  RRF    78,F
0232:  BTFSC  13.4
0233:  ADDWF  77,F
0234:  RRF    77,F
0235:  RRF    78,F
0236:  BTFSC  13.5
0237:  ADDWF  77,F
0238:  RRF    77,F
0239:  RRF    78,F
023A:  BTFSC  13.6
023B:  ADDWF  77,F
023C:  RRF    77,F
023D:  RRF    78,F
023E:  BTFSC  13.7
023F:  ADDWF  77,F
0240:  RRF    77,F
0241:  RRF    78,F
0242:  BCF    03.5
0243:  BCF    03.6
0244:  RETURN
*
034D:  MOVLW  10
034E:  BSF    03.6
034F:  MOVWF  63
0350:  CLRF   77
0351:  CLRF   7A
0352:  RRF    60,F
0353:  RRF    5F,F
0354:  BTFSS  03.0
0355:  GOTO   35C
0356:  MOVF   61,W
0357:  ADDWF  77,F
0358:  BTFSC  03.0
0359:  INCF   7A,F
035A:  MOVF   62,W
035B:  ADDWF  7A,F
035C:  RRF    7A,F
035D:  RRF    77,F
035E:  RRF    79,F
035F:  RRF    78,F
0360:  DECFSZ 63,F
0361:  GOTO   352
0362:  BCF    03.6
0363:  RETURN
0364:  CLRF   78
0365:  CLRF   79
0366:  CLRF   77
0367:  CLRF   7A
0368:  BSF    03.6
0369:  MOVF   64,W
036A:  BTFSS  03.2
036B:  GOTO   36F
036C:  MOVF   63,W
036D:  BTFSC  03.2
036E:  GOTO   389
036F:  MOVLW  10
0370:  MOVWF  65
0371:  BCF    03.0
0372:  RLF    61,F
0373:  RLF    62,F
0374:  RLF    77,F
0375:  RLF    7A,F
0376:  MOVF   64,W
0377:  SUBWF  7A,W
0378:  BTFSS  03.2
0379:  GOTO   37C
037A:  MOVF   63,W
037B:  SUBWF  77,W
037C:  BTFSS  03.0
037D:  GOTO   385
037E:  MOVF   63,W
037F:  SUBWF  77,F
0380:  BTFSS  03.0
0381:  DECF   7A,F
0382:  MOVF   64,W
0383:  SUBWF  7A,F
0384:  BSF    03.0
0385:  RLF    78,F
0386:  RLF    79,F
0387:  DECFSZ 65,F
0388:  GOTO   371
0389:  BCF    03.6
038A:  RETURN
*
07D3:  BSF    03.6
07D4:  MOVF   4B,W
07D5:  CLRF   78
07D6:  SUBWF  4A,W
07D7:  BTFSC  03.0
07D8:  GOTO   7DC
07D9:  MOVF   4A,W
07DA:  MOVWF  77
07DB:  GOTO   7E8
07DC:  CLRF   77
07DD:  MOVLW  08
07DE:  MOVWF  4C
07DF:  RLF    4A,F
07E0:  RLF    77,F
07E1:  MOVF   4B,W
07E2:  SUBWF  77,W
07E3:  BTFSC  03.0
07E4:  MOVWF  77
07E5:  RLF    78,F
07E6:  DECFSZ 4C,F
07E7:  GOTO   7DF
07E8:  BCF    03.6
07E9:  RETURN
*
089A:  MOVLW  20
089B:  MOVWF  58
089C:  CLRF   54
089D:  CLRF   55
089E:  CLRF   56
089F:  CLRF   57
08A0:  MOVF   4F,W
08A1:  MOVWF  7A
08A2:  MOVF   4E,W
08A3:  MOVWF  79
08A4:  MOVF   4D,W
08A5:  MOVWF  78
08A6:  MOVF   4C,W
08A7:  MOVWF  77
08A8:  BCF    03.0
08A9:  BTFSS  77.0
08AA:  GOTO   0B9
08AB:  MOVF   50,W
08AC:  ADDWF  54,F
08AD:  MOVF   51,W
08AE:  BTFSC  03.0
08AF:  INCFSZ 51,W
08B0:  ADDWF  55,F
08B1:  MOVF   52,W
08B2:  BTFSC  03.0
08B3:  INCFSZ 52,W
08B4:  ADDWF  56,F
08B5:  MOVF   53,W
08B6:  BTFSC  03.0
08B7:  INCFSZ 53,W
08B8:  ADDWF  57,F
08B9:  RRF    57,F
08BA:  RRF    56,F
08BB:  RRF    55,F
08BC:  RRF    54,F
08BD:  RRF    7A,F
08BE:  RRF    79,F
08BF:  RRF    78,F
08C0:  RRF    77,F
08C1:  DECFSZ 58,F
08C2:  GOTO   0A8
*
0E01:  BCF    0A.0
0E02:  BSF    0A.1
0E03:  BSF    0A.2
0E04:  ADDWF  02,F
0E05:  GOTO   42A
0E06:  GOTO   436
0E07:  GOTO   442
0E08:  GOTO   44F
....................  
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=16000000) 
*
0338:  MOVLW  5F
0339:  MOVWF  04
033A:  BSF    03.7
033B:  MOVF   00,W
033C:  BTFSC  03.2
033D:  GOTO   34C
033E:  MOVLW  05
033F:  MOVWF  78
0340:  CLRF   77
0341:  DECFSZ 77,F
0342:  GOTO   341
0343:  DECFSZ 78,F
0344:  GOTO   340
0345:  MOVLW  2E
0346:  MOVWF  77
0347:  DECFSZ 77,F
0348:  GOTO   347
0349:  GOTO   34A
034A:  DECFSZ 00,F
034B:  GOTO   33E
034C:  RETURN
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0ABF:  BCF    03.5
0AC0:  CLRF   20
0AC1:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
0883:  MOVF   25,W
0884:  BSF    03.6
0885:  MOVWF  4F
0886:  BCF    03.6
0887:  MOVF   24,W
0888:  BSF    03.6
0889:  MOVWF  4E
088A:  BCF    03.6
088B:  MOVF   23,W
088C:  BSF    03.6
088D:  MOVWF  4D
088E:  BCF    03.6
088F:  MOVF   22,W
0890:  BSF    03.6
0891:  MOVWF  4C
0892:  MOVLW  41
0893:  MOVWF  53
0894:  MOVLW  C6
0895:  MOVWF  52
0896:  MOVLW  4E
0897:  MOVWF  51
0898:  MOVLW  6D
0899:  MOVWF  50
*
08C3:  MOVF   7A,W
08C4:  MOVWF  4F
08C5:  MOVF   79,W
08C6:  MOVWF  4E
08C7:  MOVF   78,W
08C8:  MOVWF  4D
08C9:  MOVF   77,W
08CA:  MOVWF  4C
08CB:  MOVLW  39
08CC:  ADDWF  4C,W
08CD:  BCF    03.6
08CE:  MOVWF  22
08CF:  BSF    03.6
08D0:  MOVF   4D,W
08D1:  BCF    03.6
08D2:  MOVWF  23
08D3:  MOVLW  30
08D4:  BTFSC  03.0
08D5:  MOVLW  31
08D6:  ADDWF  23,F
08D7:  BSF    03.6
08D8:  MOVF   4E,W
08D9:  BCF    03.6
08DA:  MOVWF  24
08DB:  MOVLW  00
08DC:  BTFSC  03.0
08DD:  MOVLW  01
08DE:  ADDWF  24,F
08DF:  BSF    03.6
08E0:  MOVF   4F,W
08E1:  BCF    03.6
08E2:  MOVWF  25
08E3:  MOVLW  00
08E4:  BTFSC  03.0
08E5:  MOVLW  01
08E6:  ADDWF  25,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
08E7:  MOVF   24,W
08E8:  MOVWF  77
08E9:  MOVF   25,W
08EA:  MOVWF  78
08EB:  CLRF   79
08EC:  CLRF   7A
08ED:  MOVF   25,W
08EE:  BSF    03.6
08EF:  MOVWF  4E
08F0:  MOVF   77,W
08F1:  MOVWF  4D
08F2:  MOVF   4E,W
08F3:  MOVWF  62
08F4:  MOVF   4D,W
08F5:  MOVWF  61
08F6:  MOVLW  7F
08F7:  MOVWF  64
08F8:  MOVLW  FF
08F9:  MOVWF  63
08FA:  BCF    0A.3
08FB:  BCF    03.6
08FC:  CALL   364
08FD:  BSF    0A.3
08FE:  MOVF   77,W
08FF:  MOVWF  78
0900:  MOVF   7A,W
0901:  MOVWF  79
0902:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <glcd.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
02BE:  BCF    26.0
02BF:  MOVF   26,W
02C0:  BSF    03.5
02C1:  MOVWF  07
02C2:  BCF    03.5
02C3:  BSF    07.0
....................    output_low(GLCD_E); 
02C4:  BSF    03.5
02C5:  BCF    06.5
02C6:  BCF    03.5
02C7:  BCF    06.5
....................    output_low(GLCD_CS1); 
02C8:  BSF    03.5
02C9:  BCF    06.0
02CA:  BCF    03.5
02CB:  BCF    06.0
....................    output_low(GLCD_CS2); 
02CC:  BSF    03.5
02CD:  BCF    06.1
02CE:  BCF    03.5
02CF:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
02D0:  BSF    03.5
02D1:  BCF    06.2
02D2:  BCF    03.5
02D3:  BCF    06.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
02D4:  MOVLW  30
02D5:  BSF    03.5
02D6:  BSF    03.6
02D7:  MOVWF  18
02D8:  MOVLW  C0
02D9:  MOVWF  19
02DA:  BCF    03.5
02DB:  BCF    03.6
02DC:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
02DD:  MOVLW  31
02DE:  BSF    03.5
02DF:  BSF    03.6
02E0:  MOVWF  18
02E1:  MOVLW  C0
02E2:  MOVWF  19
02E3:  BCF    03.5
02E4:  BCF    03.6
02E5:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
02E6:  MOVLW  30
02E7:  BSF    03.5
02E8:  BSF    03.6
02E9:  MOVWF  18
02EA:  MOVLW  40
02EB:  MOVWF  19
02EC:  BCF    03.5
02ED:  BCF    03.6
02EE:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0x40); 
02EF:  MOVLW  31
02F0:  BSF    03.5
02F1:  BSF    03.6
02F2:  MOVWF  18
02F3:  MOVLW  40
02F4:  MOVWF  19
02F5:  BCF    03.5
02F6:  BCF    03.6
02F7:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
02F8:  MOVLW  30
02F9:  BSF    03.5
02FA:  BSF    03.6
02FB:  MOVWF  18
02FC:  MOVLW  B8
02FD:  MOVWF  19
02FE:  BCF    03.5
02FF:  BCF    03.6
0300:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
0301:  MOVLW  31
0302:  BSF    03.5
0303:  BSF    03.6
0304:  MOVWF  18
0305:  MOVLW  B8
0306:  MOVWF  19
0307:  BCF    03.5
0308:  BCF    03.6
0309:  CALL   1EA
....................    if(mode == ON) 
030A:  BSF    03.6
030B:  DECFSZ 4A,W
030C:  GOTO   320
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
030D:  MOVLW  30
030E:  BSF    03.5
030F:  MOVWF  18
0310:  MOVLW  3F
0311:  MOVWF  19
0312:  BCF    03.5
0313:  BCF    03.6
0314:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
0315:  MOVLW  31
0316:  BSF    03.5
0317:  BSF    03.6
0318:  MOVWF  18
0319:  MOVLW  3F
031A:  MOVWF  19
031B:  BCF    03.5
031C:  BCF    03.6
031D:  CALL   1EA
....................    } 
031E:  GOTO   331
031F:  BSF    03.6
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
0320:  MOVLW  30
0321:  BSF    03.5
0322:  MOVWF  18
0323:  MOVLW  3E
0324:  MOVWF  19
0325:  BCF    03.5
0326:  BCF    03.6
0327:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
0328:  MOVLW  31
0329:  BSF    03.5
032A:  BSF    03.6
032B:  MOVWF  18
032C:  MOVLW  3E
032D:  MOVWF  19
032E:  BCF    03.5
032F:  BCF    03.6
0330:  CALL   1EA
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
0331:  BSF    03.6
0332:  CLRF   5C
0333:  BCF    03.6
0334:  CALL   245
0335:  BSF    0A.3
0336:  BCF    0A.4
0337:  GOTO   353 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
*
03C8:  MOVLW  30
03C9:  BSF    03.5
03CA:  BSF    03.6
03CB:  MOVWF  16
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
03CC:  MOVF   12,W
03CD:  SUBLW  3F
03CE:  BTFSC  03.0
03CF:  GOTO   3D4
....................    { 
....................       x -= 64; 
03D0:  MOVLW  40
03D1:  SUBWF  12,F
....................       chip = GLCD_CS2; 
03D2:  MOVLW  31
03D3:  MOVWF  16
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
03D4:  BCF    03.6
03D5:  BCF    06.2
03D6:  BCF    03.5
03D7:  BCF    06.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
03D8:  BSF    03.5
03D9:  BSF    03.6
03DA:  BCF    12.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
03DB:  BSF    12.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
03DC:  MOVF   16,W
03DD:  MOVWF  18
03DE:  MOVF   12,W
03DF:  MOVWF  19
03E0:  BCF    03.5
03E1:  BCF    03.6
03E2:  CALL   1EA
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
03E3:  BSF    03.5
03E4:  BSF    03.6
03E5:  RRF    13,W
03E6:  MOVWF  77
03E7:  RRF    77,F
03E8:  RRF    77,F
03E9:  MOVLW  1F
03EA:  ANDWF  77,F
03EB:  MOVF   77,W
03EC:  ANDLW  BF
03ED:  IORLW  B8
03EE:  MOVWF  17
03EF:  MOVF   16,W
03F0:  MOVWF  18
03F1:  MOVF   17,W
03F2:  MOVWF  19
03F3:  BCF    03.5
03F4:  BCF    03.6
03F5:  CALL   1EA
....................    output_high(GLCD_DI);                                    // Set for data 
03F6:  BSF    03.5
03F7:  BCF    06.2
03F8:  BCF    03.5
03F9:  BSF    06.2
....................    data = glcd_readByte(chip); 
03FA:  BSF    03.5
03FB:  BSF    03.6
03FC:  MOVF   16,W
03FD:  MOVWF  17
*
0446:  MOVF   78,W
0447:  MOVWF  15
....................  
....................    if(color == ON) 
0448:  DECFSZ 14,W
0449:  GOTO   45A
....................       bit_set(data, y%8);        // Turn the pixel on 
044A:  MOVF   13,W
044B:  ANDLW  07
044C:  MOVWF  17
044D:  MOVLW  01
044E:  MOVWF  77
044F:  MOVF   17,W
0450:  MOVWF  78
0451:  BTFSC  03.2
0452:  GOTO   457
0453:  BCF    03.0
0454:  RLF    77,F
0455:  DECFSZ 78,F
0456:  GOTO   453
0457:  MOVF   77,W
0458:  IORWF  15,F
0459:  GOTO   46A
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
045A:  MOVF   13,W
045B:  ANDLW  07
045C:  MOVWF  17
045D:  MOVLW  01
045E:  MOVWF  77
045F:  MOVF   17,W
0460:  MOVWF  78
0461:  BTFSC  03.2
0462:  GOTO   467
0463:  BCF    03.0
0464:  RLF    77,F
0465:  DECFSZ 78,F
0466:  GOTO   463
0467:  MOVF   77,W
0468:  XORLW  FF
0469:  ANDWF  15,F
....................    output_low(GLCD_DI);          // Set for instruction 
046A:  BCF    03.6
046B:  BCF    06.2
046C:  BCF    03.5
046D:  BCF    06.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
046E:  BSF    03.5
046F:  BSF    03.6
0470:  MOVF   16,W
0471:  MOVWF  18
0472:  MOVF   12,W
0473:  MOVWF  19
0474:  BCF    03.5
0475:  BCF    03.6
0476:  CALL   1EA
....................    output_high(GLCD_DI);         // Set for data 
0477:  BSF    03.5
0478:  BCF    06.2
0479:  BCF    03.5
047A:  BSF    06.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
047B:  BSF    03.5
047C:  BSF    03.6
047D:  MOVF   16,W
047E:  MOVWF  18
047F:  MOVF   15,W
0480:  MOVWF  19
0481:  BCF    03.5
0482:  BCF    03.6
0483:  CALL   1EA
0484:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
*
06C3:  BSF    03.6
06C4:  MOVF   4E,W
06C5:  SUBWF  50,W
06C6:  MOVWF  5C
06C7:  MOVF   5C,W
06C8:  BTFSS  5C.7
06C9:  GOTO   6CC
06CA:  MOVF   5C,W
06CB:  SUBLW  00
06CC:  MOVWF  57
....................    dy = abs((signed int)(y2 - y1)); 
06CD:  MOVF   4F,W
06CE:  SUBWF  51,W
06CF:  MOVWF  5C
06D0:  MOVF   5C,W
06D1:  BTFSS  5C.7
06D2:  GOTO   6D5
06D3:  MOVF   5C,W
06D4:  SUBLW  00
06D5:  MOVWF  58
....................    x = x1; 
06D6:  MOVF   4E,W
06D7:  MOVWF  53
....................    y = y1; 
06D8:  MOVF   4F,W
06D9:  MOVWF  54
....................  
....................    if(x1 > x2) 
06DA:  MOVF   4E,W
06DB:  SUBWF  50,W
06DC:  BTFSC  03.0
06DD:  GOTO   6E1
....................       addx = -1; 
06DE:  MOVLW  FF
06DF:  MOVWF  55
06E0:  GOTO   6E3
....................    else 
....................       addx = 1; 
06E1:  MOVLW  01
06E2:  MOVWF  55
....................    if(y1 > y2) 
06E3:  MOVF   4F,W
06E4:  SUBWF  51,W
06E5:  BTFSC  03.0
06E6:  GOTO   6EA
....................       addy = -1; 
06E7:  MOVLW  FF
06E8:  MOVWF  56
06E9:  GOTO   6EC
....................    else 
....................       addy = 1; 
06EA:  MOVLW  01
06EB:  MOVWF  56
....................  
....................    if(dx >= dy) 
06EC:  MOVF   58,W
06ED:  XORLW  80
06EE:  MOVWF  77
06EF:  MOVF   57,W
06F0:  XORLW  80
06F1:  SUBWF  77,W
06F2:  BTFSC  03.2
06F3:  GOTO   6F6
06F4:  BTFSC  03.0
06F5:  GOTO   764
....................    { 
....................       P = 2*dy - dx; 
06F6:  MOVLW  02
06F7:  BSF    03.5
06F8:  MOVWF  12
06F9:  BCF    03.5
06FA:  MOVF   58,W
06FB:  BSF    03.5
06FC:  MOVWF  13
06FD:  BCF    03.5
06FE:  BCF    03.6
06FF:  CALL   21C
0700:  BSF    03.6
0701:  MOVF   57,W
0702:  SUBWF  78,W
0703:  CLRF   7A
0704:  MOVWF  77
0705:  BTFSC  77.7
0706:  DECF   7A,F
0707:  MOVWF  59
0708:  MOVF   7A,W
0709:  MOVWF  5A
....................  
....................       for(i=0; i<=dx; ++i) 
070A:  CLRF   5B
070B:  BTFSC  57.7
070C:  GOTO   763
070D:  MOVF   5B,W
070E:  SUBWF  57,W
070F:  BTFSS  03.0
0710:  GOTO   763
....................       { 
....................          glcd_pixel(x, y, color); 
0711:  MOVF   53,W
0712:  BSF    03.5
0713:  MOVWF  12
0714:  BCF    03.5
0715:  MOVF   54,W
0716:  BSF    03.5
0717:  MOVWF  13
0718:  BCF    03.5
0719:  MOVF   52,W
071A:  BSF    03.5
071B:  MOVWF  14
071C:  BCF    03.5
071D:  BCF    03.6
071E:  CALL   3C8
....................  
....................          if(P < 0) 
071F:  BSF    03.6
0720:  BTFSS  5A.7
0721:  GOTO   73A
....................          { 
....................             P += 2*dy; 
0722:  MOVLW  02
0723:  BSF    03.5
0724:  MOVWF  12
0725:  BCF    03.5
0726:  MOVF   58,W
0727:  BSF    03.5
0728:  MOVWF  13
0729:  BCF    03.5
072A:  BCF    03.6
072B:  CALL   21C
072C:  MOVF   78,W
072D:  CLRF   7A
072E:  MOVWF  77
072F:  BTFSC  77.7
0730:  DECF   7A,F
0731:  BSF    03.6
0732:  ADDWF  59,F
0733:  MOVF   7A,W
0734:  BTFSC  03.0
0735:  INCFSZ 7A,W
0736:  ADDWF  5A,F
....................             x += addx; 
0737:  MOVF   55,W
0738:  ADDWF  53,F
....................          } 
0739:  GOTO   761
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
073A:  MOVLW  02
073B:  BSF    03.5
073C:  MOVWF  12
073D:  BCF    03.5
073E:  MOVF   58,W
073F:  BSF    03.5
0740:  MOVWF  13
0741:  BCF    03.5
0742:  BCF    03.6
0743:  CALL   21C
0744:  MOVF   78,W
0745:  BSF    03.6
0746:  MOVWF  5C
0747:  MOVLW  02
0748:  BSF    03.5
0749:  MOVWF  12
074A:  BCF    03.5
074B:  MOVF   57,W
074C:  BSF    03.5
074D:  MOVWF  13
074E:  BCF    03.5
074F:  BCF    03.6
0750:  CALL   21C
0751:  MOVF   78,W
0752:  BSF    03.6
0753:  SUBWF  5C,W
0754:  CLRF   7A
0755:  MOVWF  77
0756:  BTFSC  77.7
0757:  DECF   7A,F
0758:  ADDWF  59,F
0759:  MOVF   7A,W
075A:  BTFSC  03.0
075B:  INCFSZ 7A,W
075C:  ADDWF  5A,F
....................             x += addx; 
075D:  MOVF   55,W
075E:  ADDWF  53,F
....................             y += addy; 
075F:  MOVF   56,W
0760:  ADDWF  54,F
....................          } 
0761:  INCF   5B,F
0762:  GOTO   70B
....................       } 
....................    } 
0763:  GOTO   7D1
....................    else 
....................    { 
....................       P = 2*dx - dy; 
0764:  MOVLW  02
0765:  BSF    03.5
0766:  MOVWF  12
0767:  BCF    03.5
0768:  MOVF   57,W
0769:  BSF    03.5
076A:  MOVWF  13
076B:  BCF    03.5
076C:  BCF    03.6
076D:  CALL   21C
076E:  BSF    03.6
076F:  MOVF   58,W
0770:  SUBWF  78,W
0771:  CLRF   7A
0772:  MOVWF  77
0773:  BTFSC  77.7
0774:  DECF   7A,F
0775:  MOVWF  59
0776:  MOVF   7A,W
0777:  MOVWF  5A
....................  
....................       for(i=0; i<=dy; ++i) 
0778:  CLRF   5B
0779:  BTFSC  58.7
077A:  GOTO   7D1
077B:  MOVF   5B,W
077C:  SUBWF  58,W
077D:  BTFSS  03.0
077E:  GOTO   7D1
....................       { 
....................          glcd_pixel(x, y, color); 
077F:  MOVF   53,W
0780:  BSF    03.5
0781:  MOVWF  12
0782:  BCF    03.5
0783:  MOVF   54,W
0784:  BSF    03.5
0785:  MOVWF  13
0786:  BCF    03.5
0787:  MOVF   52,W
0788:  BSF    03.5
0789:  MOVWF  14
078A:  BCF    03.5
078B:  BCF    03.6
078C:  CALL   3C8
....................  
....................          if(P < 0) 
078D:  BSF    03.6
078E:  BTFSS  5A.7
078F:  GOTO   7A8
....................          { 
....................             P += 2*dx; 
0790:  MOVLW  02
0791:  BSF    03.5
0792:  MOVWF  12
0793:  BCF    03.5
0794:  MOVF   57,W
0795:  BSF    03.5
0796:  MOVWF  13
0797:  BCF    03.5
0798:  BCF    03.6
0799:  CALL   21C
079A:  MOVF   78,W
079B:  CLRF   7A
079C:  MOVWF  77
079D:  BTFSC  77.7
079E:  DECF   7A,F
079F:  BSF    03.6
07A0:  ADDWF  59,F
07A1:  MOVF   7A,W
07A2:  BTFSC  03.0
07A3:  INCFSZ 7A,W
07A4:  ADDWF  5A,F
....................             y += addy; 
07A5:  MOVF   56,W
07A6:  ADDWF  54,F
....................          } 
07A7:  GOTO   7CF
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
07A8:  MOVLW  02
07A9:  BSF    03.5
07AA:  MOVWF  12
07AB:  BCF    03.5
07AC:  MOVF   57,W
07AD:  BSF    03.5
07AE:  MOVWF  13
07AF:  BCF    03.5
07B0:  BCF    03.6
07B1:  CALL   21C
07B2:  MOVF   78,W
07B3:  BSF    03.6
07B4:  MOVWF  5C
07B5:  MOVLW  02
07B6:  BSF    03.5
07B7:  MOVWF  12
07B8:  BCF    03.5
07B9:  MOVF   58,W
07BA:  BSF    03.5
07BB:  MOVWF  13
07BC:  BCF    03.5
07BD:  BCF    03.6
07BE:  CALL   21C
07BF:  MOVF   78,W
07C0:  BSF    03.6
07C1:  SUBWF  5C,W
07C2:  CLRF   7A
07C3:  MOVWF  77
07C4:  BTFSC  77.7
07C5:  DECF   7A,F
07C6:  ADDWF  59,F
07C7:  MOVF   7A,W
07C8:  BTFSC  03.0
07C9:  INCFSZ 7A,W
07CA:  ADDWF  5A,F
....................             x += addx; 
07CB:  MOVF   55,W
07CC:  ADDWF  53,F
....................             y += addy; 
07CD:  MOVF   56,W
07CE:  ADDWF  54,F
....................          } 
07CF:  INCF   5B,F
07D0:  GOTO   779
....................       } 
....................    } 
07D1:  BCF    03.6
07D2:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
*
0485:  BSF    03.6
0486:  CLRF   65
0487:  MOVF   65,W
0488:  ADDWF  61,W
0489:  MOVWF  04
048A:  BCF    03.7
048B:  BTFSC  62.0
048C:  BSF    03.7
048D:  MOVF   00,F
048E:  BTFSC  03.2
048F:  GOTO   57C
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
0490:  MOVF   65,W
0491:  ADDWF  61,W
0492:  MOVWF  04
0493:  BCF    03.7
0494:  BTFSC  62.0
0495:  BSF    03.7
0496:  MOVF   00,W
0497:  SUBLW  52
0498:  BTFSS  03.0
0499:  GOTO   4C3
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
049A:  MOVF   65,W
049B:  ADDWF  61,W
049C:  MOVWF  04
049D:  BCF    03.7
049E:  BTFSC  62.0
049F:  BSF    03.7
04A0:  MOVLW  20
04A1:  SUBWF  00,W
04A2:  BSF    03.5
04A3:  MOVWF  11
04A4:  MOVWF  12
04A5:  MOVLW  05
04A6:  MOVWF  13
04A7:  BCF    03.5
04A8:  BCF    03.6
04A9:  CALL   21C
04AA:  MOVF   78,W
04AB:  BSF    03.5
04AC:  BSF    03.6
04AD:  MOVWF  10
04AE:  MOVWF  78
04AF:  MOVLW  05
04B0:  MOVWF  77
04B1:  MOVLW  6A
04B2:  MOVWF  04
04B3:  BSF    03.7
04B4:  MOVF   78,W
04B5:  BCF    03.5
04B6:  BCF    03.6
04B7:  CALL   004
04B8:  MOVWF  00
04B9:  INCF   78,F
04BA:  INCF   04,F
04BB:  DECFSZ 77,F
04BC:  GOTO   4BE
04BD:  GOTO   4C1
04BE:  BSF    03.5
04BF:  BSF    03.6
04C0:  GOTO   4B4
04C1:  GOTO   4FC
04C2:  BSF    03.6
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
04C3:  MOVF   65,W
04C4:  ADDWF  61,W
04C5:  MOVWF  04
04C6:  BCF    03.7
04C7:  BTFSC  62.0
04C8:  BSF    03.7
04C9:  MOVF   00,W
04CA:  SUBLW  7E
04CB:  BTFSS  03.0
04CC:  GOTO   4F6
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
04CD:  MOVF   65,W
04CE:  ADDWF  61,W
04CF:  MOVWF  04
04D0:  BCF    03.7
04D1:  BTFSC  62.0
04D2:  BSF    03.7
04D3:  MOVLW  53
04D4:  SUBWF  00,W
04D5:  BSF    03.5
04D6:  MOVWF  11
04D7:  MOVWF  12
04D8:  MOVLW  05
04D9:  MOVWF  13
04DA:  BCF    03.5
04DB:  BCF    03.6
04DC:  CALL   21C
04DD:  MOVF   78,W
04DE:  BSF    03.5
04DF:  BSF    03.6
04E0:  MOVWF  10
04E1:  MOVWF  78
04E2:  MOVLW  05
04E3:  MOVWF  77
04E4:  MOVLW  6A
04E5:  MOVWF  04
04E6:  BSF    03.7
04E7:  MOVF   78,W
04E8:  BCF    03.5
04E9:  BCF    03.6
04EA:  CALL   10A
04EB:  MOVWF  00
04EC:  INCF   78,F
04ED:  INCF   04,F
04EE:  DECFSZ 77,F
04EF:  GOTO   4F1
04F0:  GOTO   4F4
04F1:  BSF    03.5
04F2:  BSF    03.6
04F3:  GOTO   4E7
04F4:  GOTO   4FC
04F5:  BSF    03.6
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
04F6:  CLRF   6A
04F7:  CLRF   6B
04F8:  CLRF   6C
04F9:  CLRF   6D
04FA:  CLRF   6E
04FB:  BCF    03.6
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
04FC:  MOVLW  05
04FD:  BSF    03.5
04FE:  BSF    03.6
04FF:  MOVWF  12
0500:  BCF    03.5
0501:  MOVF   63,W
0502:  BSF    03.5
0503:  MOVWF  13
0504:  BCF    03.5
0505:  BCF    03.6
0506:  CALL   21C
0507:  MOVF   78,W
0508:  BSF    03.6
0509:  ADDWF  5F,W
050A:  SUBLW  7F
050B:  BTFSC  03.0
050C:  GOTO   51C
....................       { 
....................          x = 0;                           // Set x at far left position 
050D:  CLRF   5F
....................          y += 7*size + 1;                 // Set y at next position down 
050E:  MOVLW  07
050F:  BSF    03.5
0510:  MOVWF  12
0511:  BCF    03.5
0512:  MOVF   63,W
0513:  BSF    03.5
0514:  MOVWF  13
0515:  BCF    03.5
0516:  BCF    03.6
0517:  CALL   21C
0518:  MOVLW  01
0519:  ADDWF  78,W
051A:  BSF    03.6
051B:  ADDWF  60,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
051C:  CLRF   66
051D:  MOVF   66,W
051E:  SUBLW  04
051F:  BTFSS  03.0
0520:  GOTO   579
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
0521:  CLRF   67
0522:  MOVLW  07
0523:  BSF    03.5
0524:  MOVWF  12
0525:  BCF    03.5
0526:  MOVF   63,W
0527:  BSF    03.5
0528:  MOVWF  13
0529:  BCF    03.5
052A:  BCF    03.6
052B:  CALL   21C
052C:  MOVF   78,W
052D:  BSF    03.6
052E:  SUBWF  67,W
052F:  BTFSC  03.0
0530:  GOTO   575
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
0531:  MOVLW  6A
0532:  ADDWF  66,W
0533:  MOVWF  04
0534:  BSF    03.7
0535:  MOVF   00,W
0536:  BSF    03.5
0537:  MOVWF  10
0538:  MOVWF  77
0539:  BCF    03.5
053A:  MOVF   67,W
053B:  MOVWF  78
053C:  BTFSC  03.2
053D:  GOTO   542
053E:  BCF    03.0
053F:  RRF    77,F
0540:  DECFSZ 78,F
0541:  GOTO   53E
0542:  BTFSS  77.0
0543:  GOTO   573
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
0544:  CLRF   68
0545:  MOVF   63,W
0546:  SUBWF  68,W
0547:  BTFSC  03.0
0548:  GOTO   573
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
0549:  CLRF   69
054A:  MOVF   63,W
054B:  SUBWF  69,W
054C:  BTFSC  03.0
054D:  GOTO   571
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
054E:  MOVF   69,W
054F:  ADDWF  5F,W
0550:  BSF    03.5
0551:  MOVWF  10
0552:  BCF    03.5
0553:  MOVF   67,W
0554:  BSF    03.5
0555:  MOVWF  12
0556:  BCF    03.5
0557:  MOVF   63,W
0558:  BSF    03.5
0559:  MOVWF  13
055A:  BCF    03.5
055B:  BCF    03.6
055C:  CALL   21C
055D:  MOVF   78,W
055E:  BSF    03.6
055F:  ADDWF  60,W
0560:  ADDWF  68,W
0561:  BSF    03.5
0562:  MOVWF  11
0563:  MOVF   10,W
0564:  MOVWF  12
0565:  MOVF   11,W
0566:  MOVWF  13
0567:  BCF    03.5
0568:  MOVF   64,W
0569:  BSF    03.5
056A:  MOVWF  14
056B:  BCF    03.5
056C:  BCF    03.6
056D:  CALL   3C8
056E:  BSF    03.6
056F:  INCF   69,F
0570:  GOTO   54A
....................                   } 
0571:  INCF   68,F
0572:  GOTO   545
....................                } 
....................             } 
0573:  INCF   67,F
0574:  GOTO   522
....................          } 
0575:  INCF   66,F
0576:  MOVF   63,W
0577:  ADDWF  5F,F
0578:  GOTO   51D
....................       } 
0579:  INCF   65,F
057A:  INCF   5F,F
057B:  GOTO   487
....................    } 
057C:  BCF    03.6
057D:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0245:  BSF    03.6
0246:  CLRF   5D
0247:  MOVF   5D,W
0248:  SUBLW  07
0249:  BTFSS  03.0
024A:  GOTO   2BC
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
024B:  BSF    03.5
024C:  BCF    03.6
024D:  BCF    06.2
024E:  BCF    03.5
024F:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0250:  MOVLW  30
0251:  BSF    03.5
0252:  BSF    03.6
0253:  MOVWF  18
0254:  MOVLW  40
0255:  MOVWF  19
0256:  BCF    03.5
0257:  BCF    03.6
0258:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
0259:  MOVLW  31
025A:  BSF    03.5
025B:  BSF    03.6
025C:  MOVWF  18
025D:  MOVLW  40
025E:  MOVWF  19
025F:  BCF    03.5
0260:  BCF    03.6
0261:  CALL   1EA
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
0262:  BSF    03.6
0263:  MOVF   5D,W
0264:  IORLW  B8
0265:  MOVWF  5F
0266:  MOVLW  30
0267:  BSF    03.5
0268:  MOVWF  18
0269:  BCF    03.5
026A:  MOVF   5F,W
026B:  BSF    03.5
026C:  MOVWF  19
026D:  BCF    03.5
026E:  BCF    03.6
026F:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
0270:  BSF    03.6
0271:  MOVF   5D,W
0272:  IORLW  B8
0273:  MOVWF  5F
0274:  MOVLW  31
0275:  BSF    03.5
0276:  MOVWF  18
0277:  BCF    03.5
0278:  MOVF   5F,W
0279:  BSF    03.5
027A:  MOVWF  19
027B:  BCF    03.5
027C:  BCF    03.6
027D:  CALL   1EA
....................       output_high(GLCD_DI);                     // Set for data 
027E:  BSF    03.5
027F:  BCF    06.2
0280:  BCF    03.5
0281:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
0282:  BSF    03.6
0283:  CLRF   5E
0284:  MOVF   5E,W
0285:  SUBLW  3F
0286:  BTFSS  03.0
0287:  GOTO   2BA
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0288:  MOVLW  FF
0289:  BSF    03.5
028A:  MOVWF  12
028B:  BCF    03.5
028C:  MOVF   5C,W
028D:  BSF    03.5
028E:  MOVWF  13
028F:  BCF    03.5
0290:  BCF    03.6
0291:  CALL   21C
0292:  MOVF   78,W
0293:  BSF    03.6
0294:  MOVWF  5F
0295:  MOVLW  30
0296:  BSF    03.5
0297:  MOVWF  18
0298:  BCF    03.5
0299:  MOVF   5F,W
029A:  BSF    03.5
029B:  MOVWF  19
029C:  BCF    03.5
029D:  BCF    03.6
029E:  CALL   1EA
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
029F:  MOVLW  FF
02A0:  BSF    03.5
02A1:  BSF    03.6
02A2:  MOVWF  12
02A3:  BCF    03.5
02A4:  MOVF   5C,W
02A5:  BSF    03.5
02A6:  MOVWF  13
02A7:  BCF    03.5
02A8:  BCF    03.6
02A9:  CALL   21C
02AA:  MOVF   78,W
02AB:  BSF    03.6
02AC:  MOVWF  5F
02AD:  MOVLW  31
02AE:  BSF    03.5
02AF:  MOVWF  18
02B0:  BCF    03.5
02B1:  MOVF   5F,W
02B2:  BSF    03.5
02B3:  MOVWF  19
02B4:  BCF    03.5
02B5:  BCF    03.6
02B6:  CALL   1EA
02B7:  BSF    03.6
02B8:  INCF   5E,F
02B9:  GOTO   284
....................       } 
02BA:  INCF   5D,F
02BB:  GOTO   247
....................    } 
02BC:  BCF    03.6
02BD:  RETURN
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
01EA:  BSF    03.5
01EB:  BSF    03.6
01EC:  MOVF   18,W
01ED:  SUBLW  30
01EE:  BTFSS  03.2
01EF:  GOTO   1F7
....................       output_high(GLCD_CS1); 
01F0:  BCF    03.6
01F1:  BCF    06.0
01F2:  BCF    03.5
01F3:  BSF    06.0
01F4:  GOTO   1FB
01F5:  BSF    03.5
01F6:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS2); 
01F7:  BCF    03.6
01F8:  BCF    06.1
01F9:  BCF    03.5
01FA:  BSF    06.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
01FB:  BSF    03.5
01FC:  BCF    06.4
01FD:  BCF    03.5
01FE:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
01FF:  BSF    03.5
0200:  CLRF   08
0201:  BSF    03.6
0202:  MOVF   19,W
0203:  BCF    03.5
0204:  BCF    03.6
0205:  MOVWF  08
....................    output_high(GLCD_E);       // Pulse the enable pin 
0206:  BSF    03.5
0207:  BCF    06.5
0208:  BCF    03.5
0209:  BSF    06.5
....................    delay_us(2); 
020A:  MOVLW  02
020B:  MOVWF  77
020C:  DECFSZ 77,F
020D:  GOTO   20C
020E:  NOP
....................    output_low(GLCD_E); 
020F:  BSF    03.5
0210:  BCF    06.5
0211:  BCF    03.5
0212:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0213:  BSF    03.5
0214:  BCF    06.0
0215:  BCF    03.5
0216:  BCF    06.0
....................    output_low(GLCD_CS2); 
0217:  BSF    03.5
0218:  BCF    06.1
0219:  BCF    03.5
021A:  BCF    06.1
021B:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
03FE:  MOVF   17,W
03FF:  SUBLW  30
0400:  BTFSS  03.2
0401:  GOTO   409
....................       output_high(GLCD_CS1); 
0402:  BCF    03.6
0403:  BCF    06.0
0404:  BCF    03.5
0405:  BSF    06.0
0406:  GOTO   40D
0407:  BSF    03.5
0408:  BSF    03.6
....................    else 
....................       output_high(GLCD_CS2); 
0409:  BCF    03.6
040A:  BCF    06.1
040B:  BCF    03.5
040C:  BSF    06.1
....................  
....................    input_d();                 // Set port d to input 
040D:  MOVLW  FF
040E:  BSF    03.5
040F:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
0410:  BCF    06.4
0411:  BCF    03.5
0412:  BSF    06.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
0413:  BSF    03.5
0414:  BCF    06.5
0415:  BCF    03.5
0416:  BSF    06.5
....................    delay_us(2); 
0417:  MOVLW  02
0418:  MOVWF  77
0419:  DECFSZ 77,F
041A:  GOTO   419
041B:  NOP
....................    output_low(GLCD_E); 
041C:  BSF    03.5
041D:  BCF    06.5
041E:  BCF    03.5
041F:  BCF    06.5
....................    delay_us(2); 
0420:  MOVLW  02
0421:  MOVWF  77
0422:  DECFSZ 77,F
0423:  GOTO   422
0424:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
0425:  BSF    03.5
0426:  BCF    06.5
0427:  BCF    03.5
0428:  BSF    06.5
....................    delay_us(2); 
0429:  MOVLW  02
042A:  MOVWF  77
042B:  DECFSZ 77,F
042C:  GOTO   42B
042D:  NOP
....................    data = input_d();          // Get the data from the display's output register 
042E:  MOVLW  FF
042F:  BSF    03.5
0430:  MOVWF  08
0431:  BCF    03.5
0432:  MOVF   08,W
0433:  BSF    03.5
0434:  BSF    03.6
0435:  MOVWF  18
....................    output_low(GLCD_E); 
0436:  BCF    03.6
0437:  BCF    06.5
0438:  BCF    03.5
0439:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
043A:  BSF    03.5
043B:  BCF    06.0
043C:  BCF    03.5
043D:  BCF    06.0
....................    output_low(GLCD_CS2); 
043E:  BSF    03.5
043F:  BCF    06.1
0440:  BCF    03.5
0441:  BCF    06.1
....................    return data;               // Return the read data 
0442:  BSF    03.5
0443:  BSF    03.6
0444:  MOVF   18,W
0445:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define uchar unsigned char 
....................  
.................... #define GRID_SIZE     6 
.................... #define GRID_COLS     10 
.................... #define GRID_ROWS     10 
.................... #define GRID_ORIGIN_X 0 
.................... #define GRID_ORIGIN_Y 0 
.................... #define BUZZER_PIN PIN_B3 
....................  
.................... // buzzer part 
.................... void buzzer_beep(int duration_ms) { 
*
038B:  BSF    03.6
038C:  CLRF   60
038D:  MOVF   5C,W
038E:  MOVWF  5F
038F:  MOVLW  03
0390:  MOVWF  62
0391:  MOVLW  E8
0392:  MOVWF  61
0393:  BCF    03.6
0394:  CALL   34D
0395:  MOVF   79,W
0396:  BSF    03.6
0397:  MOVWF  60
0398:  MOVF   78,W
0399:  MOVWF  5F
039A:  MOVF   60,W
039B:  MOVWF  62
039C:  MOVF   5F,W
039D:  MOVWF  61
039E:  MOVLW  07
039F:  MOVWF  64
03A0:  MOVLW  D0
03A1:  MOVWF  63
03A2:  BCF    03.6
03A3:  CALL   364
03A4:  MOVF   78,W
03A5:  BSF    03.6
03A6:  MOVWF  5D
....................    int cycles = duration_ms * 1000L / 2000;  // 500Hz dalga 
....................    for (int i = 0; i < cycles; i++) { 
03A7:  CLRF   5E
03A8:  MOVF   5D,W
03A9:  SUBWF  5E,W
03AA:  BTFSC  03.0
03AB:  GOTO   3C2
....................       output_low(BUZZER_PIN);    // aktif LOW  ses 
03AC:  BSF    03.5
03AD:  BCF    03.6
03AE:  BCF    06.3
03AF:  BCF    03.5
03B0:  BCF    06.3
....................       delay_us(1000); 
03B1:  MOVLW  01
03B2:  BSF    03.6
03B3:  MOVWF  5F
03B4:  BCF    03.6
03B5:  CALL   338
....................       output_high(BUZZER_PIN);   // sessiz 
03B6:  BSF    03.5
03B7:  BCF    06.3
03B8:  BCF    03.5
03B9:  BSF    06.3
....................       delay_us(1000); 
03BA:  MOVLW  01
03BB:  BSF    03.6
03BC:  MOVWF  5F
03BD:  BCF    03.6
03BE:  CALL   338
03BF:  BSF    03.6
03C0:  INCF   5E,F
03C1:  GOTO   3A8
....................    } 
....................    output_high(BUZZER_PIN);  // sessiz brak 
03C2:  BSF    03.5
03C3:  BCF    03.6
03C4:  BCF    06.3
03C5:  BCF    03.5
03C6:  BSF    06.3
03C7:  RETURN
.................... } 
....................  
.................... void short_beep() { 
....................    buzzer_beep(100); 
*
0616:  MOVLW  64
0617:  BSF    03.6
0618:  MOVWF  5C
0619:  BCF    03.6
061A:  CALL   38B
061B:  RETURN
.................... } 
....................  
.................... void error_beep() { 
....................       buzzer_beep(1000); 
*
09CB:  MOVLW  E8
09CC:  BSF    03.6
09CD:  MOVWF  5C
09CE:  BCF    0A.3
09CF:  BCF    03.6
09D0:  CALL   38B
09D1:  BSF    0A.3
....................       delay_ms(200);  
09D2:  MOVLW  C8
09D3:  BSF    03.6
09D4:  MOVWF  5F
09D5:  BCF    0A.3
09D6:  BCF    03.6
09D7:  CALL   338
09D8:  BSF    0A.3
....................       buzzer_beep(1000); 
09D9:  MOVLW  E8
09DA:  BSF    03.6
09DB:  MOVWF  5C
09DC:  BCF    0A.3
09DD:  BCF    03.6
09DE:  CALL   38B
09DF:  BSF    0A.3
....................       delay_ms(200);  
09E0:  MOVLW  C8
09E1:  BSF    03.6
09E2:  MOVWF  5F
09E3:  BCF    0A.3
09E4:  BCF    03.6
09E5:  CALL   338
09E6:  BSF    0A.3
....................       buzzer_beep(700); 
09E7:  MOVLW  BC
09E8:  BSF    03.6
09E9:  MOVWF  5C
09EA:  BCF    0A.3
09EB:  BCF    03.6
09EC:  CALL   38B
09ED:  BSF    0A.3
....................       delay_ms(200);       
09EE:  MOVLW  C8
09EF:  BSF    03.6
09F0:  MOVWF  5F
09F1:  BCF    0A.3
09F2:  BCF    03.6
09F3:  CALL   338
09F4:  BSF    0A.3
.................... } 
....................  
.................... void win_melody() { 
....................    int notes[] = {200, 100, 100, 400, 200, 150, 600, 300}; 
*
0A30:  MOVLW  C8
0A31:  BSF    03.6
0A32:  MOVWF  4A
0A33:  MOVLW  64
0A34:  MOVWF  4B
0A35:  MOVWF  4C
0A36:  MOVLW  90
0A37:  MOVWF  4D
0A38:  MOVLW  C8
0A39:  MOVWF  4E
0A3A:  MOVLW  96
0A3B:  MOVWF  4F
0A3C:  MOVLW  58
0A3D:  MOVWF  50
0A3E:  MOVLW  2C
0A3F:  MOVWF  51
....................    int gaps[]  = {50, 50, 100, 150, 100, 100, 150, 0}; // Aralklar 
0A40:  MOVLW  32
0A41:  MOVWF  52
0A42:  MOVWF  53
0A43:  MOVLW  64
0A44:  MOVWF  54
0A45:  MOVLW  96
0A46:  MOVWF  55
0A47:  MOVLW  64
0A48:  MOVWF  56
0A49:  MOVWF  57
0A4A:  MOVLW  96
0A4B:  MOVWF  58
0A4C:  CLRF   59
....................  
....................    for (int i = 0; i < 8; i++) { 
0A4D:  CLRF   5A
0A4E:  MOVF   5A,W
0A4F:  SUBLW  07
0A50:  BTFSS  03.0
0A51:  GOTO   26C
....................       buzzer_beep(notes[i]); 
0A52:  MOVLW  4A
0A53:  ADDWF  5A,W
0A54:  MOVWF  04
0A55:  BSF    03.7
0A56:  MOVF   00,W
0A57:  MOVWF  5B
0A58:  MOVWF  5C
0A59:  BCF    0A.3
0A5A:  BCF    03.6
0A5B:  CALL   38B
0A5C:  BSF    0A.3
....................       delay_ms(gaps[i]); 
0A5D:  MOVLW  52
0A5E:  BSF    03.6
0A5F:  ADDWF  5A,W
0A60:  MOVWF  04
0A61:  BSF    03.7
0A62:  MOVF   00,W
0A63:  MOVWF  5B
0A64:  MOVWF  5F
0A65:  BCF    0A.3
0A66:  BCF    03.6
0A67:  CALL   338
0A68:  BSF    0A.3
0A69:  BSF    03.6
0A6A:  INCF   5A,F
0A6B:  GOTO   24E
....................    } 
.................... } 
....................  
....................  
.................... uchar snakeX[32]; 
.................... uchar snakeY[32]; 
.................... uchar snakeX2[32]; 
.................... uchar snakeY2[32]; 
....................  
.................... #define getX(i) ((i < 32) ? snakeX[i] : snakeX2[(i)-32]) 
.................... #define getY(i) ((i < 32) ? snakeY[i] : snakeY2[(i)-32]) 
.................... #define setX(i,val) ((i < 32) ? (snakeX[i]=(val)) : (snakeX2[(i)-32]=(val))) 
.................... #define setY(i,val) ((i < 32) ? (snakeY[i]=(val)) : (snakeY2[(i)-32]=(val))) 
....................  
.................... uchar dir = 2; 
.................... uchar food[2], LENGTH_SNAKE = 5; 
.................... uchar posX = 0, posY = 2; 
.................... uchar score = 0; 
.................... uchar best_score = 0; 
.................... char score_txt[11] = "Score: 00"; 
*
0AC2:  MOVLW  53
0AC3:  BSF    03.5
0AC4:  MOVWF  60
0AC5:  MOVLW  63
0AC6:  MOVWF  61
0AC7:  MOVLW  6F
0AC8:  MOVWF  62
0AC9:  MOVLW  72
0ACA:  MOVWF  63
0ACB:  MOVLW  65
0ACC:  MOVWF  64
0ACD:  MOVLW  3A
0ACE:  MOVWF  65
0ACF:  MOVLW  20
0AD0:  MOVWF  66
0AD1:  MOVLW  30
0AD2:  MOVWF  67
0AD3:  MOVWF  68
0AD4:  CLRF   69
.................... char best_score_txt[10] = "Best: 00"; 
0AD5:  MOVLW  42
0AD6:  BCF    03.5
0AD7:  BSF    03.6
0AD8:  MOVWF  10
0AD9:  MOVLW  65
0ADA:  MOVWF  11
0ADB:  MOVLW  73
0ADC:  MOVWF  12
0ADD:  MOVLW  74
0ADE:  MOVWF  13
0ADF:  MOVLW  3A
0AE0:  MOVWF  14
0AE1:  MOVLW  20
0AE2:  MOVWF  15
0AE3:  MOVLW  30
0AE4:  MOVWF  16
0AE5:  MOVWF  17
0AE6:  CLRF   18
.................... char gameover_msg[14] = "GAMEOVER !!!"; 
0AE7:  MOVLW  47
0AE8:  MOVWF  1A
0AE9:  MOVLW  41
0AEA:  MOVWF  1B
0AEB:  MOVLW  4D
0AEC:  MOVWF  1C
0AED:  MOVLW  45
0AEE:  MOVWF  1D
0AEF:  MOVLW  4F
0AF0:  MOVWF  1E
0AF1:  MOVLW  56
0AF2:  MOVWF  1F
0AF3:  MOVLW  45
0AF4:  MOVWF  20
0AF5:  MOVLW  52
0AF6:  MOVWF  21
0AF7:  MOVLW  20
0AF8:  MOVWF  22
0AF9:  MOVLW  21
0AFA:  MOVWF  23
0AFB:  MOVWF  24
0AFC:  MOVWF  25
0AFD:  CLRF   26
.................... char win_msg[] = "YOU WON!"; 
0AFE:  MOVLW  59
0AFF:  MOVWF  28
0B00:  MOVLW  4F
0B01:  MOVWF  29
0B02:  MOVLW  55
0B03:  MOVWF  2A
0B04:  MOVLW  20
0B05:  MOVWF  2B
0B06:  MOVLW  57
0B07:  MOVWF  2C
0B08:  MOVLW  4F
0B09:  MOVWF  2D
0B0A:  MOVLW  4E
0B0B:  MOVWF  2E
0B0C:  MOVLW  21
0B0D:  MOVWF  2F
0B0E:  CLRF   30
.................... char splash_text[] = "SNAKE GAME"; 
0B0F:  MOVLW  53
0B10:  MOVWF  31
0B11:  MOVLW  4E
0B12:  MOVWF  32
0B13:  MOVLW  41
0B14:  MOVWF  33
0B15:  MOVLW  4B
0B16:  MOVWF  34
0B17:  MOVLW  45
0B18:  MOVWF  35
0B19:  MOVLW  20
0B1A:  MOVWF  36
0B1B:  MOVLW  47
0B1C:  MOVWF  37
0B1D:  MOVLW  41
0B1E:  MOVWF  38
0B1F:  MOVLW  4D
0B20:  MOVWF  39
0B21:  MOVLW  45
0B22:  MOVWF  3A
0B23:  CLRF   3B
.................... uchar i; 
....................  
.................... int1 isFirstStart = 1; 
.................... uchar difficulty_index = 0; 
....................  
.................... struct { 
....................    unsigned delay_time : 2; 
.................... } gameSettings; 
....................  
.................... char easy[]   = "EASY"; 
0B24:  BSF    03.5
0B25:  BCF    03.6
0B26:  MOVWF  6B
0B27:  MOVLW  41
0B28:  MOVWF  6C
0B29:  MOVLW  53
0B2A:  MOVWF  6D
0B2B:  MOVLW  59
0B2C:  MOVWF  6E
0B2D:  CLRF   6F
.................... char medium[] = "MEDIUM"; 
0B2E:  MOVLW  4D
0B2F:  BCF    03.5
0B30:  BSF    03.6
0B31:  MOVWF  3C
0B32:  MOVLW  45
0B33:  MOVWF  3D
0B34:  MOVLW  44
0B35:  MOVWF  3E
0B36:  MOVLW  49
0B37:  MOVWF  3F
0B38:  MOVLW  55
0B39:  MOVWF  40
0B3A:  MOVLW  4D
0B3B:  MOVWF  41
0B3C:  CLRF   42
.................... char hard[]   = "HARD"; 
0B3D:  MOVLW  48
0B3E:  MOVWF  43
0B3F:  MOVLW  41
0B40:  MOVWF  44
0B41:  MOVLW  52
0B42:  MOVWF  45
0B43:  MOVLW  44
0B44:  MOVWF  46
0B45:  CLRF   47
....................  
.................... // -------------------- GLCD -------------------- 
.................... void fillCell(signed int gx, signed int gy, int1 color) { 
....................    if (gx < 0 || gx >= GRID_COLS || gy < 0 || gy >= GRID_ROWS) return; 
*
0903:  BSF    03.6
0904:  BTFSC  4C.7
0905:  GOTO   113
0906:  BTFSC  4C.7
0907:  GOTO   10C
0908:  MOVF   4C,W
0909:  SUBLW  09
090A:  BTFSS  03.0
090B:  GOTO   113
090C:  BTFSC  4D.7
090D:  GOTO   113
090E:  BTFSC  4D.7
090F:  GOTO   114
0910:  MOVF   4D,W
0911:  SUBLW  09
0912:  BTFSS  03.0
0913:  GOTO   155
....................    uchar px = GRID_ORIGIN_X + gx * GRID_SIZE + 1; 
....................    uchar py = GRID_ORIGIN_Y + gy * GRID_SIZE + 1; 
0914:  MOVF   4C,W
0915:  BSF    03.5
0916:  MOVWF  12
0917:  MOVLW  06
0918:  MOVWF  13
0919:  BCF    0A.3
091A:  BCF    03.5
091B:  BCF    03.6
091C:  CALL   21C
091D:  BSF    0A.3
091E:  MOVLW  01
091F:  ADDWF  78,W
0920:  BSF    03.6
0921:  MOVWF  4F
0922:  MOVF   4D,W
0923:  BSF    03.5
0924:  MOVWF  12
0925:  MOVLW  06
0926:  MOVWF  13
0927:  BCF    0A.3
0928:  BCF    03.5
0929:  BCF    03.6
092A:  CALL   21C
092B:  BSF    0A.3
092C:  MOVLW  01
092D:  ADDWF  78,W
092E:  BSF    03.6
092F:  MOVWF  50
....................    for (uchar dx = 0; dx < GRID_SIZE - 1; dx++) 
0930:  CLRF   51
0931:  MOVF   51,W
0932:  SUBLW  04
0933:  BTFSS  03.0
0934:  GOTO   155
....................       for (uchar dy = 0; dy < GRID_SIZE - 1; dy++) 
0935:  CLRF   52
0936:  MOVF   52,W
0937:  SUBLW  04
0938:  BTFSS  03.0
0939:  GOTO   153
....................          glcd_pixel(px + dx, py + dy, color); 
093A:  MOVF   51,W
093B:  ADDWF  4F,W
093C:  MOVWF  53
093D:  MOVF   52,W
093E:  ADDWF  50,W
093F:  MOVWF  54
0940:  MOVF   53,W
0941:  BSF    03.5
0942:  MOVWF  12
0943:  BCF    03.5
0944:  MOVF   54,W
0945:  BSF    03.5
0946:  MOVWF  13
0947:  BCF    03.5
0948:  MOVF   4E,W
0949:  BSF    03.5
094A:  MOVWF  14
094B:  BCF    0A.3
094C:  BCF    03.5
094D:  BCF    03.6
094E:  CALL   3C8
094F:  BSF    0A.3
0950:  BSF    03.6
0951:  INCF   52,F
0952:  GOTO   136
0953:  INCF   51,F
0954:  GOTO   131
0955:  BCF    03.6
0956:  RETURN
.................... } 
....................  
.................... void screenWipeDown() { 
....................    for (uchar y = 0; y < 64; y++) { 
*
059E:  BSF    03.6
059F:  CLRF   4A
05A0:  MOVF   4A,W
05A1:  SUBLW  3F
05A2:  BTFSS  03.0
05A3:  GOTO   5BF
....................       for (uchar x = 0; x < 128; x++) { 
05A4:  CLRF   4B
05A5:  MOVF   4B,W
05A6:  SUBLW  7F
05A7:  BTFSS  03.0
05A8:  GOTO   5B8
....................          glcd_pixel(x, y, 1); 
05A9:  MOVF   4B,W
05AA:  BSF    03.5
05AB:  MOVWF  12
05AC:  BCF    03.5
05AD:  MOVF   4A,W
05AE:  BSF    03.5
05AF:  MOVWF  13
05B0:  MOVLW  01
05B1:  MOVWF  14
05B2:  BCF    03.5
05B3:  BCF    03.6
05B4:  CALL   3C8
05B5:  BSF    03.6
05B6:  INCF   4B,F
05B7:  GOTO   5A5
....................       } 
....................       delay_ms(5); 
05B8:  MOVLW  05
05B9:  MOVWF  5F
05BA:  BCF    03.6
05BB:  CALL   338
05BC:  BSF    03.6
05BD:  INCF   4A,F
05BE:  GOTO   5A0
....................    } 
05BF:  BCF    03.6
05C0:  RETURN
.................... } 
....................  
.................... void drawGrid() { 
....................    for (uchar c = 0; c <= GRID_COLS; c++) { 
*
0800:  BSF    03.6
0801:  CLRF   4A
0802:  MOVF   4A,W
0803:  SUBLW  0A
0804:  BTFSS  03.0
0805:  GOTO   023
....................       uchar x = GRID_ORIGIN_X + c * GRID_SIZE; 
0806:  MOVF   4A,W
0807:  BSF    03.5
0808:  MOVWF  12
0809:  MOVLW  06
080A:  MOVWF  13
080B:  BCF    0A.3
080C:  BCF    03.5
080D:  BCF    03.6
080E:  CALL   21C
080F:  BSF    0A.3
0810:  MOVF   78,W
0811:  BSF    03.6
0812:  MOVWF  4B
....................       glcd_line(x, GRID_ORIGIN_Y, x, GRID_ORIGIN_Y + GRID_ROWS * GRID_SIZE, 1); 
0813:  MOVF   4B,W
0814:  MOVWF  4E
0815:  CLRF   4F
0816:  MOVF   4B,W
0817:  MOVWF  50
0818:  MOVLW  3C
0819:  MOVWF  51
081A:  MOVLW  01
081B:  MOVWF  52
081C:  BCF    0A.3
081D:  BCF    03.6
081E:  CALL   6C3
081F:  BSF    0A.3
0820:  BSF    03.6
0821:  INCF   4A,F
0822:  GOTO   002
....................    } 
....................    for (uchar r = 0; r <= GRID_ROWS; r++) { 
0823:  CLRF   4C
0824:  MOVF   4C,W
0825:  SUBLW  0A
0826:  BTFSS  03.0
0827:  GOTO   045
....................       uchar y = GRID_ORIGIN_Y + r * GRID_SIZE; 
0828:  MOVF   4C,W
0829:  BSF    03.5
082A:  MOVWF  12
082B:  MOVLW  06
082C:  MOVWF  13
082D:  BCF    0A.3
082E:  BCF    03.5
082F:  BCF    03.6
0830:  CALL   21C
0831:  BSF    0A.3
0832:  MOVF   78,W
0833:  BSF    03.6
0834:  MOVWF  4D
....................       glcd_line(GRID_ORIGIN_X, y, GRID_ORIGIN_X + GRID_COLS * GRID_SIZE, y, 1); 
0835:  CLRF   4E
0836:  MOVF   4D,W
0837:  MOVWF  4F
0838:  MOVLW  3C
0839:  MOVWF  50
083A:  MOVF   4D,W
083B:  MOVWF  51
083C:  MOVLW  01
083D:  MOVWF  52
083E:  BCF    0A.3
083F:  BCF    03.6
0840:  CALL   6C3
0841:  BSF    0A.3
0842:  BSF    03.6
0843:  INCF   4C,F
0844:  GOTO   024
....................    } 
0845:  BCF    03.6
0846:  RETURN
.................... } 
....................  
.................... void clearScoreArea() { 
....................    for (uchar x = 65; x < 125; x++) { 
0847:  MOVLW  41
0848:  BSF    03.6
0849:  MOVWF  4A
084A:  MOVF   4A,W
084B:  SUBLW  7C
084C:  BTFSS  03.0
084D:  GOTO   065
....................       for (uchar y = 0; y < 20; y++) { 
084E:  CLRF   4B
084F:  MOVF   4B,W
0850:  SUBLW  13
0851:  BTFSS  03.0
0852:  GOTO   063
....................          glcd_pixel(x, y, 0); 
0853:  MOVF   4A,W
0854:  BSF    03.5
0855:  MOVWF  12
0856:  BCF    03.5
0857:  MOVF   4B,W
0858:  BSF    03.5
0859:  MOVWF  13
085A:  CLRF   14
085B:  BCF    0A.3
085C:  BCF    03.5
085D:  BCF    03.6
085E:  CALL   3C8
085F:  BSF    0A.3
0860:  BSF    03.6
0861:  INCF   4B,F
0862:  GOTO   04F
....................       } 
0863:  INCF   4A,F
0864:  GOTO   04A
....................    } 
.................... } 
....................  
.................... void writeScore() { 
....................    clearScoreArea(); 
....................    glcd_text57(65, 0, score_txt, 1, 1); 
0865:  MOVLW  41
0866:  MOVWF  5F
0867:  CLRF   60
0868:  CLRF   62
0869:  MOVLW  E0
086A:  MOVWF  61
086B:  MOVLW  01
086C:  MOVWF  63
086D:  MOVWF  64
086E:  BCF    0A.3
086F:  BCF    03.6
0870:  CALL   485
0871:  BSF    0A.3
....................    glcd_text57(65, 10, best_score_txt, 1, 1); 
0872:  MOVLW  41
0873:  BSF    03.6
0874:  MOVWF  5F
0875:  MOVLW  0A
0876:  MOVWF  60
0877:  MOVLW  01
0878:  MOVWF  62
0879:  MOVLW  10
087A:  MOVWF  61
087B:  MOVLW  01
087C:  MOVWF  63
087D:  MOVWF  64
087E:  BCF    0A.3
087F:  BCF    03.6
0880:  CALL   485
0881:  BSF    0A.3
0882:  RETURN
.................... } 
....................  
.................... void criar_comida() { 
*
0957:  BSF    03.6
0958:  CLRF   4A
....................    uchar valid = 0; 
....................    while (!valid) { 
0959:  MOVF   4A,F
095A:  BTFSS  03.2
095B:  GOTO   1BE
....................       food[0] = rand() % GRID_COLS; 
095C:  BCF    03.6
095D:  CALL   083
095E:  MOVF   79,W
095F:  BSF    03.6
0960:  MOVWF  4D
0961:  MOVF   78,W
0962:  MOVWF  4C
0963:  MOVF   4D,W
0964:  MOVWF  62
0965:  MOVF   4C,W
0966:  MOVWF  61
0967:  CLRF   64
0968:  MOVLW  0A
0969:  MOVWF  63
096A:  BCF    0A.3
096B:  BCF    03.6
096C:  CALL   364
096D:  BSF    0A.3
096E:  MOVF   77,W
096F:  MOVWF  68
....................       food[1] = rand() % GRID_ROWS; 
0970:  CALL   083
0971:  MOVF   79,W
0972:  BSF    03.6
0973:  MOVWF  4D
0974:  MOVF   78,W
0975:  MOVWF  4C
0976:  MOVF   4D,W
0977:  MOVWF  62
0978:  MOVF   4C,W
0979:  MOVWF  61
097A:  CLRF   64
097B:  MOVLW  0A
097C:  MOVWF  63
097D:  BCF    0A.3
097E:  BCF    03.6
097F:  CALL   364
0980:  BSF    0A.3
0981:  MOVF   77,W
0982:  MOVWF  69
....................       valid = 1; 
0983:  MOVLW  01
0984:  BSF    03.6
0985:  MOVWF  4A
....................       for (uchar j = 0; j < LENGTH_SNAKE; j++) { 
0986:  CLRF   4B
0987:  BCF    03.6
0988:  MOVF   6A,W
0989:  BSF    03.6
098A:  SUBWF  4B,W
098B:  BTFSC  03.0
098C:  GOTO   1BD
....................          if (getX(j) == food[0] && getY(j) == food[1]) { 
098D:  MOVF   4B,W
098E:  SUBLW  1F
098F:  BTFSS  03.0
0990:  GOTO   197
0991:  MOVLW  27
0992:  ADDWF  4B,W
0993:  MOVWF  04
0994:  BCF    03.7
0995:  MOVF   00,W
0996:  GOTO   19D
0997:  MOVLW  20
0998:  SUBWF  4B,W
0999:  ADDLW  A0
099A:  MOVWF  04
099B:  BCF    03.7
099C:  MOVF   00,W
099D:  BCF    03.6
099E:  SUBWF  68,W
099F:  BTFSS  03.2
09A0:  GOTO   1BA
09A1:  BSF    03.6
09A2:  MOVF   4B,W
09A3:  SUBLW  1F
09A4:  BTFSS  03.0
09A5:  GOTO   1AC
09A6:  MOVLW  47
09A7:  ADDWF  4B,W
09A8:  MOVWF  04
09A9:  BCF    03.7
09AA:  MOVF   00,W
09AB:  GOTO   1B2
09AC:  MOVLW  20
09AD:  SUBWF  4B,W
09AE:  ADDLW  C0
09AF:  MOVWF  04
09B0:  BCF    03.7
09B1:  MOVF   00,W
09B2:  BCF    03.6
09B3:  SUBWF  69,W
09B4:  BTFSS  03.2
09B5:  GOTO   1BA
....................             valid = 0; 
09B6:  BSF    03.6
09B7:  CLRF   4A
....................             break; 
09B8:  GOTO   1BD
09B9:  BCF    03.6
....................          } 
09BA:  BSF    03.6
09BB:  INCF   4B,F
09BC:  GOTO   187
....................       } 
09BD:  GOTO   159
....................    } 
....................    fillCell(food[0], food[1], 1); 
09BE:  BCF    03.6
09BF:  MOVF   68,W
09C0:  BSF    03.6
09C1:  MOVWF  4C
09C2:  BCF    03.6
09C3:  MOVF   69,W
09C4:  BSF    03.6
09C5:  MOVWF  4D
09C6:  MOVLW  01
09C7:  MOVWF  4E
09C8:  BCF    03.6
09C9:  CALL   103
09CA:  RETURN
.................... } 
....................  
.................... void gameover() { 
....................    error_beep(); 
....................    LENGTH_SNAKE = 5; 
*
09F5:  MOVLW  05
09F6:  MOVWF  6A
....................    posX = 0; 
09F7:  CLRF   6B
....................    posY = 2; 
09F8:  MOVLW  02
09F9:  MOVWF  6C
....................    score = 0; 
09FA:  CLRF   6D
....................    score_txt[7] = '0'; 
09FB:  MOVLW  30
09FC:  BSF    03.5
09FD:  MOVWF  67
....................    score_txt[8] = '0'; 
09FE:  MOVWF  68
....................    dir = 2; 
09FF:  MOVLW  02
0A00:  BCF    03.5
0A01:  MOVWF  67
....................  
....................    glcd_fillScreen(0); 
0A02:  BSF    03.6
0A03:  CLRF   5C
0A04:  BCF    0A.3
0A05:  BCF    03.6
0A06:  CALL   245
0A07:  BSF    0A.3
....................    glcd_text57(25, 30, gameover_msg, 1, 1); 
0A08:  MOVLW  19
0A09:  BSF    03.6
0A0A:  MOVWF  5F
0A0B:  MOVLW  1E
0A0C:  MOVWF  60
0A0D:  MOVLW  01
0A0E:  MOVWF  62
0A0F:  MOVLW  1A
0A10:  MOVWF  61
0A11:  MOVLW  01
0A12:  MOVWF  63
0A13:  MOVWF  64
0A14:  BCF    0A.3
0A15:  BCF    03.6
0A16:  CALL   485
0A17:  BSF    0A.3
....................    delay_ms(1500); 
0A18:  MOVLW  06
0A19:  BSF    03.6
0A1A:  MOVWF  4A
0A1B:  MOVLW  FA
0A1C:  MOVWF  5F
0A1D:  BCF    0A.3
0A1E:  BCF    03.6
0A1F:  CALL   338
0A20:  BSF    0A.3
0A21:  BSF    03.6
0A22:  DECFSZ 4A,F
0A23:  GOTO   21B
....................    screenWipeDown(); 
0A24:  BCF    0A.3
0A25:  BCF    03.6
0A26:  CALL   59E
0A27:  BSF    0A.3
....................    glcd_fillScreen(0); 
0A28:  BSF    03.6
0A29:  CLRF   5C
0A2A:  BCF    0A.3
0A2B:  BCF    03.6
0A2C:  CALL   245
0A2D:  BSF    0A.3
....................    drawGrid(); 
0A2E:  CALL   000
0A2F:  RETURN
.................... } 
....................  
.................... void winScreen() { 
....................    win_melody(); 
....................    glcd_fillScreen(0); 
*
0A6C:  CLRF   5C
0A6D:  BCF    0A.3
0A6E:  BCF    03.6
0A6F:  CALL   245
0A70:  BSF    0A.3
....................    glcd_text57(35, 35, win_msg, 1, 1); 
0A71:  MOVLW  23
0A72:  BSF    03.6
0A73:  MOVWF  5F
0A74:  MOVWF  60
0A75:  MOVLW  01
0A76:  MOVWF  62
0A77:  MOVLW  28
0A78:  MOVWF  61
0A79:  MOVLW  01
0A7A:  MOVWF  63
0A7B:  MOVWF  64
0A7C:  BCF    0A.3
0A7D:  BCF    03.6
0A7E:  CALL   485
0A7F:  BSF    0A.3
....................    delay_ms(2500); 
0A80:  MOVLW  0A
0A81:  BSF    03.6
0A82:  MOVWF  4A
0A83:  MOVLW  FA
0A84:  MOVWF  5F
0A85:  BCF    0A.3
0A86:  BCF    03.6
0A87:  CALL   338
0A88:  BSF    0A.3
0A89:  BSF    03.6
0A8A:  DECFSZ 4A,F
0A8B:  GOTO   283
....................    screenWipeDown(); 
0A8C:  BCF    0A.3
0A8D:  BCF    03.6
0A8E:  CALL   59E
0A8F:  BSF    0A.3
....................    glcd_fillScreen(0); 
0A90:  BSF    03.6
0A91:  CLRF   5C
0A92:  BCF    0A.3
0A93:  BCF    03.6
0A94:  CALL   245
0A95:  BSF    0A.3
....................    drawGrid(); 
0A96:  CALL   000
....................    LENGTH_SNAKE = 5; 
0A97:  MOVLW  05
0A98:  MOVWF  6A
....................    posX = 0; 
0A99:  CLRF   6B
....................    posY = 2; 
0A9A:  MOVLW  02
0A9B:  MOVWF  6C
....................    score = 0; 
0A9C:  CLRF   6D
....................    score_txt[7] = '0'; 
0A9D:  MOVLW  30
0A9E:  BSF    03.5
0A9F:  MOVWF  67
....................    score_txt[8] = '0'; 
0AA0:  MOVWF  68
....................    dir = 2; 
0AA1:  MOVLW  02
0AA2:  BCF    03.5
0AA3:  MOVWF  67
0AA4:  BSF    0A.3
0AA5:  BCF    0A.4
0AA6:  GOTO   593 (RETURN)
.................... } 
....................  
.................... void showSplashScreen() { 
....................    glcd_fillScreen(0); 
*
057E:  BSF    03.6
057F:  CLRF   5C
0580:  BCF    03.6
0581:  CALL   245
....................    glcd_text57(20, 25, splash_text, 1, 1); 
0582:  MOVLW  14
0583:  BSF    03.6
0584:  MOVWF  5F
0585:  MOVLW  19
0586:  MOVWF  60
0587:  MOVLW  01
0588:  MOVWF  62
0589:  MOVLW  31
058A:  MOVWF  61
058B:  MOVLW  01
058C:  MOVWF  63
058D:  MOVWF  64
058E:  BCF    03.6
058F:  CALL   485
....................    delay_ms(2000); 
0590:  MOVLW  08
0591:  BSF    03.6
0592:  MOVWF  4A
0593:  MOVLW  FA
0594:  MOVWF  5F
0595:  BCF    03.6
0596:  CALL   338
0597:  BSF    03.6
0598:  DECFSZ 4A,F
0599:  GOTO   593
059A:  BCF    03.6
059B:  BSF    0A.3
059C:  BCF    0A.4
059D:  GOTO   370 (RETURN)
.................... } 
....................  
.................... void displayDifficulty(uchar index) { 
....................    for (uchar x = 40; x < 88; x++) { 
*
05C1:  MOVLW  28
05C2:  BSF    03.6
05C3:  MOVWF  5D
05C4:  MOVF   5D,W
05C5:  SUBLW  57
05C6:  BTFSS  03.0
05C7:  GOTO   5DE
....................       for (uchar y = 30; y < 38; y++) { 
05C8:  MOVLW  1E
05C9:  MOVWF  5E
05CA:  MOVF   5E,W
05CB:  SUBLW  25
05CC:  BTFSS  03.0
05CD:  GOTO   5DC
....................          glcd_pixel(x, y, 0); 
05CE:  MOVF   5D,W
05CF:  BSF    03.5
05D0:  MOVWF  12
05D1:  BCF    03.5
05D2:  MOVF   5E,W
05D3:  BSF    03.5
05D4:  MOVWF  13
05D5:  CLRF   14
05D6:  BCF    03.5
05D7:  BCF    03.6
05D8:  CALL   3C8
05D9:  BSF    03.6
05DA:  INCF   5E,F
05DB:  GOTO   5CA
....................       } 
05DC:  INCF   5D,F
05DD:  GOTO   5C4
....................    } 
....................    switch(index) { 
05DE:  MOVF   5C,W
05DF:  XORLW  00
05E0:  BCF    03.6
05E1:  BTFSC  03.2
05E2:  GOTO   5EA
05E3:  XORLW  01
05E4:  BTFSC  03.2
05E5:  GOTO   5F8
05E6:  XORLW  03
05E7:  BTFSC  03.2
05E8:  GOTO   607
05E9:  GOTO   615
....................       case 0: glcd_text57(40, 30, easy, 1, 1); break; 
05EA:  MOVLW  28
05EB:  BSF    03.6
05EC:  MOVWF  5F
05ED:  MOVLW  1E
05EE:  MOVWF  60
05EF:  CLRF   62
05F0:  MOVLW  EB
05F1:  MOVWF  61
05F2:  MOVLW  01
05F3:  MOVWF  63
05F4:  MOVWF  64
05F5:  BCF    03.6
05F6:  CALL   485
05F7:  GOTO   615
....................       case 1: glcd_text57(40, 30, medium, 1, 1); break; 
05F8:  MOVLW  28
05F9:  BSF    03.6
05FA:  MOVWF  5F
05FB:  MOVLW  1E
05FC:  MOVWF  60
05FD:  MOVLW  01
05FE:  MOVWF  62
05FF:  MOVLW  3C
0600:  MOVWF  61
0601:  MOVLW  01
0602:  MOVWF  63
0603:  MOVWF  64
0604:  BCF    03.6
0605:  CALL   485
0606:  GOTO   615
....................       case 2: glcd_text57(40, 30, hard, 1, 1); break; 
0607:  MOVLW  28
0608:  BSF    03.6
0609:  MOVWF  5F
060A:  MOVLW  1E
060B:  MOVWF  60
060C:  MOVLW  01
060D:  MOVWF  62
060E:  MOVLW  43
060F:  MOVWF  61
0610:  MOVLW  01
0611:  MOVWF  63
0612:  MOVWF  64
0613:  BCF    03.6
0614:  CALL   485
....................    } 
0615:  RETURN
.................... } 
....................  
.................... void selectDifficulty() { 
....................    char title[] = "SELECT DIFFICULTY"; 
*
061C:  MOVLW  53
061D:  BSF    03.6
061E:  MOVWF  4A
061F:  MOVLW  45
0620:  MOVWF  4B
0621:  MOVLW  4C
0622:  MOVWF  4C
0623:  MOVLW  45
0624:  MOVWF  4D
0625:  MOVLW  43
0626:  MOVWF  4E
0627:  MOVLW  54
0628:  MOVWF  4F
0629:  MOVLW  20
062A:  MOVWF  50
062B:  MOVLW  44
062C:  MOVWF  51
062D:  MOVLW  49
062E:  MOVWF  52
062F:  MOVLW  46
0630:  MOVWF  53
0631:  MOVWF  54
0632:  MOVLW  49
0633:  MOVWF  55
0634:  MOVLW  43
0635:  MOVWF  56
0636:  MOVLW  55
0637:  MOVWF  57
0638:  MOVLW  4C
0639:  MOVWF  58
063A:  MOVLW  54
063B:  MOVWF  59
063C:  MOVLW  59
063D:  MOVWF  5A
063E:  CLRF   5B
....................    glcd_fillScreen(0); 
063F:  CLRF   5C
0640:  BCF    03.6
0641:  CALL   245
....................    glcd_text57(10, 10, title, 1, 1); 
0642:  MOVLW  0A
0643:  BSF    03.6
0644:  MOVWF  5F
0645:  MOVWF  60
0646:  MOVLW  01
0647:  MOVWF  62
0648:  MOVLW  4A
0649:  MOVWF  61
064A:  MOVLW  01
064B:  MOVWF  63
064C:  MOVWF  64
064D:  BCF    03.6
064E:  CALL   485
....................    displayDifficulty(difficulty_index); 
064F:  MOVF   71,W
0650:  BSF    03.6
0651:  MOVWF  5C
0652:  BCF    03.6
0653:  CALL   5C1
....................  
....................    while(TRUE) { 
....................       if (input(PIN_C3)) { 
0654:  BSF    26.3
0655:  MOVF   26,W
0656:  BSF    03.5
0657:  MOVWF  07
0658:  BCF    03.5
0659:  BTFSS  07.3
065A:  GOTO   671
....................          if (difficulty_index < 2) { 
065B:  MOVF   71,W
065C:  SUBLW  01
065D:  BTFSS  03.0
065E:  GOTO   666
....................             difficulty_index++; 
065F:  INCF   71,F
....................             displayDifficulty(difficulty_index); 
0660:  MOVF   71,W
0661:  BSF    03.6
0662:  MOVWF  5C
0663:  BCF    03.6
0664:  CALL   5C1
....................             short_beep(); 
0665:  CALL   616
....................          } 
....................          delay_ms(300); 
0666:  MOVLW  02
0667:  BSF    03.6
0668:  MOVWF  5C
0669:  MOVLW  96
066A:  MOVWF  5F
066B:  BCF    03.6
066C:  CALL   338
066D:  BSF    03.6
066E:  DECFSZ 5C,F
066F:  GOTO   669
0670:  BCF    03.6
....................       } 
....................  
....................       if (input(PIN_C4)) { 
0671:  BSF    26.4
0672:  MOVF   26,W
0673:  BSF    03.5
0674:  MOVWF  07
0675:  BCF    03.5
0676:  BTFSS  07.4
0677:  GOTO   68D
....................          if (difficulty_index > 0) { 
0678:  MOVF   71,F
0679:  BTFSC  03.2
067A:  GOTO   682
....................             difficulty_index--; 
067B:  DECF   71,F
....................             displayDifficulty(difficulty_index); 
067C:  MOVF   71,W
067D:  BSF    03.6
067E:  MOVWF  5C
067F:  BCF    03.6
0680:  CALL   5C1
....................             short_beep(); 
0681:  CALL   616
....................          } 
....................          delay_ms(300); 
0682:  MOVLW  02
0683:  BSF    03.6
0684:  MOVWF  5C
0685:  MOVLW  96
0686:  MOVWF  5F
0687:  BCF    03.6
0688:  CALL   338
0689:  BSF    03.6
068A:  DECFSZ 5C,F
068B:  GOTO   685
068C:  BCF    03.6
....................       } 
....................  
....................       if (input(PIN_C5)) { 
068D:  BSF    26.5
068E:  MOVF   26,W
068F:  BSF    03.5
0690:  MOVWF  07
0691:  BCF    03.5
0692:  BTFSS  07.5
0693:  GOTO   6BD
....................          switch (difficulty_index) { 
0694:  MOVF   71,W
0695:  BTFSC  03.2
0696:  GOTO   69E
0697:  XORLW  01
0698:  BTFSC  03.2
0699:  GOTO   6A3
069A:  XORLW  03
069B:  BTFSC  03.2
069C:  GOTO   6A8
069D:  GOTO   6AC
....................             case 0: gameSettings.delay_time = 3; break; 
069E:  MOVLW  FC
069F:  ANDWF  72,W
06A0:  IORLW  03
06A1:  MOVWF  72
06A2:  GOTO   6AC
....................             case 1: gameSettings.delay_time = 2; break; 
06A3:  MOVLW  FC
06A4:  ANDWF  72,W
06A5:  IORLW  02
06A6:  MOVWF  72
06A7:  GOTO   6AC
....................             case 2: gameSettings.delay_time = 1; break; 
06A8:  MOVLW  FC
06A9:  ANDWF  72,W
06AA:  IORLW  01
06AB:  MOVWF  72
....................          } 
....................          buzzer_beep(100);  // Seim onay sesi 
06AC:  MOVLW  64
06AD:  BSF    03.6
06AE:  MOVWF  5C
06AF:  BCF    03.6
06B0:  CALL   38B
....................          delay_ms(300); 
06B1:  MOVLW  02
06B2:  BSF    03.6
06B3:  MOVWF  5C
06B4:  MOVLW  96
06B5:  MOVWF  5F
06B6:  BCF    03.6
06B7:  CALL   338
06B8:  BSF    03.6
06B9:  DECFSZ 5C,F
06BA:  GOTO   6B4
....................          return; 
06BB:  GOTO   6BF
06BC:  BCF    03.6
....................       } 
06BD:  GOTO   654
06BE:  BSF    03.6
....................    } 
06BF:  BCF    03.6
06C0:  BSF    0A.3
06C1:  BCF    0A.4
06C2:  GOTO   376 (RETURN)
.................... } 
....................  
.................... void main() { 
*
0AA7:  MOVF   03,W
0AA8:  ANDLW  1F
0AA9:  MOVWF  03
0AAA:  MOVLW  FF
0AAB:  MOVWF  26
0AAC:  MOVLW  02
0AAD:  MOVWF  67
0AAE:  MOVLW  05
0AAF:  MOVWF  6A
0AB0:  CLRF   6B
0AB1:  MOVLW  02
0AB2:  MOVWF  6C
0AB3:  CLRF   6D
0AB4:  CLRF   6E
0AB5:  BSF    70.0
0AB6:  CLRF   71
0AB7:  BSF    03.5
0AB8:  BSF    1F.0
0AB9:  BSF    1F.1
0ABA:  BSF    1F.2
0ABB:  BCF    1F.3
0ABC:  MOVLW  07
0ABD:  MOVWF  1C
0ABE:  BCF    03.7
....................    set_tris_b(0b00000111); // RB0-1-2 giri, RB3 k 
*
0B46:  MOVLW  07
0B47:  BSF    03.5
0B48:  BCF    03.6
0B49:  MOVWF  06
....................    output_high(BUZZER_PIN); // Bata sessiz (aktif-LOW) 
0B4A:  BCF    06.3
0B4B:  BCF    03.5
0B4C:  BSF    06.3
....................  
....................    glcd_init(ON); 
0B4D:  MOVLW  01
0B4E:  BSF    03.6
0B4F:  MOVWF  4A
0B50:  BCF    0A.3
0B51:  BCF    03.6
0B52:  GOTO   2BE
0B53:  BSF    0A.3
....................    glcd_fillScreen(0); 
0B54:  BSF    03.6
0B55:  CLRF   5C
0B56:  BCF    0A.3
0B57:  BCF    03.6
0B58:  CALL   245
0B59:  BSF    0A.3
....................    delay_ms(500); 
0B5A:  MOVLW  02
0B5B:  BSF    03.6
0B5C:  MOVWF  4A
0B5D:  MOVLW  FA
0B5E:  MOVWF  5F
0B5F:  BCF    0A.3
0B60:  BCF    03.6
0B61:  CALL   338
0B62:  BSF    0A.3
0B63:  BSF    03.6
0B64:  DECFSZ 4A,F
0B65:  GOTO   35D
....................  
.................... Start: 
....................    if (isFirstStart) { 
0B66:  BTFSS  70.0
0B67:  GOTO   379
....................       buzzer_beep(100); 
0B68:  MOVLW  64
0B69:  MOVWF  5C
0B6A:  BCF    0A.3
0B6B:  BCF    03.6
0B6C:  CALL   38B
0B6D:  BSF    0A.3
....................       showSplashScreen(); 
0B6E:  BCF    0A.3
0B6F:  GOTO   57E
0B70:  BSF    0A.3
....................       screenWipeDown(); 
0B71:  BCF    0A.3
0B72:  CALL   59E
0B73:  BSF    0A.3
....................       selectDifficulty(); 
0B74:  BCF    0A.3
0B75:  GOTO   61C
0B76:  BSF    0A.3
....................       isFirstStart = 0; 
0B77:  BCF    70.0
0B78:  BSF    03.6
....................    } 
....................  
....................    glcd_fillScreen(0); 
0B79:  CLRF   5C
0B7A:  BCF    0A.3
0B7B:  BCF    03.6
0B7C:  CALL   245
0B7D:  BSF    0A.3
....................    drawGrid(); 
0B7E:  CALL   000
....................    writeScore(); 
0B7F:  CALL   047
....................    criar_comida(); 
0B80:  CALL   157
....................  
....................    for (i = 0; i < LENGTH_SNAKE; i++) { 
0B81:  CLRF   6F
0B82:  MOVF   6A,W
0B83:  SUBWF  6F,W
0B84:  BTFSC  03.0
0B85:  GOTO   3DC
....................       setX(i, posX - i); 
0B86:  MOVF   6F,W
0B87:  SUBLW  1F
0B88:  BTFSS  03.0
0B89:  GOTO   392
0B8A:  MOVLW  27
0B8B:  ADDWF  6F,W
0B8C:  MOVWF  04
0B8D:  BCF    03.7
0B8E:  MOVF   6F,W
0B8F:  SUBWF  6B,W
0B90:  MOVWF  00
0B91:  GOTO   39A
0B92:  MOVLW  20
0B93:  SUBWF  6F,W
0B94:  ADDLW  A0
0B95:  MOVWF  04
0B96:  BCF    03.7
0B97:  MOVF   6F,W
0B98:  SUBWF  6B,W
0B99:  MOVWF  00
....................       setY(i, posY); 
0B9A:  MOVF   6F,W
0B9B:  SUBLW  1F
0B9C:  BTFSS  03.0
0B9D:  GOTO   3A6
0B9E:  MOVLW  47
0B9F:  ADDWF  6F,W
0BA0:  MOVWF  04
0BA1:  BCF    03.7
0BA2:  MOVF   6C,W
0BA3:  MOVWF  00
0BA4:  MOVF   6C,W
0BA5:  GOTO   3AD
0BA6:  MOVLW  20
0BA7:  SUBWF  6F,W
0BA8:  ADDLW  C0
0BA9:  MOVWF  04
0BAA:  BCF    03.7
0BAB:  MOVF   6C,W
0BAC:  MOVWF  00
....................       fillCell(getX(i), getY(i), 1); 
0BAD:  MOVF   6F,W
0BAE:  SUBLW  1F
0BAF:  BTFSS  03.0
0BB0:  GOTO   3B7
0BB1:  MOVLW  27
0BB2:  ADDWF  6F,W
0BB3:  MOVWF  04
0BB4:  BCF    03.7
0BB5:  MOVF   00,W
0BB6:  GOTO   3BD
0BB7:  MOVLW  20
0BB8:  SUBWF  6F,W
0BB9:  ADDLW  A0
0BBA:  MOVWF  04
0BBB:  BCF    03.7
0BBC:  MOVF   00,W
0BBD:  BSF    03.6
0BBE:  MOVWF  4A
0BBF:  BCF    03.6
0BC0:  MOVF   6F,W
0BC1:  SUBLW  1F
0BC2:  BTFSS  03.0
0BC3:  GOTO   3CA
0BC4:  MOVLW  47
0BC5:  ADDWF  6F,W
0BC6:  MOVWF  04
0BC7:  BCF    03.7
0BC8:  MOVF   00,W
0BC9:  GOTO   3D0
0BCA:  MOVLW  20
0BCB:  SUBWF  6F,W
0BCC:  ADDLW  C0
0BCD:  MOVWF  04
0BCE:  BCF    03.7
0BCF:  MOVF   00,W
0BD0:  BSF    03.6
0BD1:  MOVWF  4B
0BD2:  MOVF   4A,W
0BD3:  MOVWF  4C
0BD4:  MOVF   4B,W
0BD5:  MOVWF  4D
0BD6:  MOVLW  01
0BD7:  MOVWF  4E
0BD8:  BCF    03.6
0BD9:  CALL   103
0BDA:  INCF   6F,F
0BDB:  GOTO   382
....................    } 
....................  
....................    while (TRUE) { 
....................       if (input(PIN_C3) && dir != 0) { dir = 3; short_beep(); } 
0BDC:  BSF    26.3
0BDD:  MOVF   26,W
0BDE:  BSF    03.5
0BDF:  MOVWF  07
0BE0:  BCF    03.5
0BE1:  BTFSS  07.3
0BE2:  GOTO   3EB
0BE3:  MOVF   67,F
0BE4:  BTFSC  03.2
0BE5:  GOTO   3EB
0BE6:  MOVLW  03
0BE7:  MOVWF  67
0BE8:  BCF    0A.3
0BE9:  CALL   616
0BEA:  BSF    0A.3
....................       if (input(PIN_C2) && dir != 1) { dir = 2; short_beep(); } 
0BEB:  BSF    26.2
0BEC:  MOVF   26,W
0BED:  BSF    03.5
0BEE:  MOVWF  07
0BEF:  BCF    03.5
0BF0:  BTFSS  07.2
0BF1:  GOTO   3FA
0BF2:  DECFSZ 67,W
0BF3:  GOTO   3F5
0BF4:  GOTO   3FA
0BF5:  MOVLW  02
0BF6:  MOVWF  67
0BF7:  BCF    0A.3
0BF8:  CALL   616
0BF9:  BSF    0A.3
....................       if (input(PIN_C1) && dir != 2) { dir = 1; short_beep(); } 
0BFA:  BSF    26.1
0BFB:  MOVF   26,W
0BFC:  BSF    03.5
0BFD:  MOVWF  07
0BFE:  BCF    03.5
0BFF:  BTFSS  07.1
0C00:  GOTO   40A
0C01:  MOVF   67,W
0C02:  SUBLW  02
0C03:  BTFSC  03.2
0C04:  GOTO   40A
0C05:  MOVLW  01
0C06:  MOVWF  67
0C07:  BCF    0A.3
0C08:  CALL   616
0C09:  BSF    0A.3
....................       if (input(PIN_C4) && dir != 3) { dir = 0; short_beep(); } 
0C0A:  BSF    26.4
0C0B:  MOVF   26,W
0C0C:  BSF    03.5
0C0D:  MOVWF  07
0C0E:  BCF    03.5
0C0F:  BTFSS  07.4
0C10:  GOTO   419
0C11:  MOVF   67,W
0C12:  SUBLW  03
0C13:  BTFSC  03.2
0C14:  GOTO   419
0C15:  CLRF   67
0C16:  BCF    0A.3
0C17:  CALL   616
0C18:  BSF    0A.3
....................       if (input(PIN_C5)) { gameover(); goto Start; } 
0C19:  BSF    26.5
0C1A:  MOVF   26,W
0C1B:  BSF    03.5
0C1C:  MOVWF  07
0C1D:  BCF    03.5
0C1E:  BTFSS  07.5
0C1F:  GOTO   424
0C20:  CALL   1CB
0C21:  BSF    03.6
0C22:  GOTO   366
0C23:  BCF    03.6
....................  
....................       switch(dir) { 
0C24:  MOVF   67,W
0C25:  ADDLW  FC
0C26:  BTFSC  03.0
0C27:  GOTO   45B
0C28:  ADDLW  04
0C29:  GOTO   601
....................          case 0: if (posX == 0) { gameover(); goto Start; } else posX--; break; 
0C2A:  MOVF   6B,F
0C2B:  BTFSS  03.2
0C2C:  GOTO   432
0C2D:  CALL   1CB
0C2E:  BSF    03.6
0C2F:  GOTO   366
0C30:  GOTO   434
0C31:  BCF    03.6
0C32:  DECF   6B,F
0C33:  BSF    03.6
0C34:  BCF    03.6
0C35:  GOTO   45B
....................          case 1: if (posY == 0) { gameover(); goto Start; } else posY--; break; 
0C36:  MOVF   6C,F
0C37:  BTFSS  03.2
0C38:  GOTO   43E
0C39:  CALL   1CB
0C3A:  BSF    03.6
0C3B:  GOTO   366
0C3C:  GOTO   440
0C3D:  BCF    03.6
0C3E:  DECF   6C,F
0C3F:  BSF    03.6
0C40:  BCF    03.6
0C41:  GOTO   45B
....................          case 2: if (posY == GRID_ROWS - 1) { gameover(); goto Start; } else posY++; break; 
0C42:  MOVF   6C,W
0C43:  SUBLW  09
0C44:  BTFSS  03.2
0C45:  GOTO   44B
0C46:  CALL   1CB
0C47:  BSF    03.6
0C48:  GOTO   366
0C49:  GOTO   44D
0C4A:  BCF    03.6
0C4B:  INCF   6C,F
0C4C:  BSF    03.6
0C4D:  BCF    03.6
0C4E:  GOTO   45B
....................          case 3: if (posX == GRID_COLS - 1) { gameover(); goto Start; } else posX++; break; 
0C4F:  MOVF   6B,W
0C50:  SUBLW  09
0C51:  BTFSS  03.2
0C52:  GOTO   458
0C53:  CALL   1CB
0C54:  BSF    03.6
0C55:  GOTO   366
0C56:  GOTO   45A
0C57:  BCF    03.6
0C58:  INCF   6B,F
0C59:  BSF    03.6
0C5A:  BCF    03.6
....................       } 
....................  
....................       uchar tailX = getX(0), tailY = getY(0); 
0C5B:  MOVF   27,W
0C5C:  BSF    03.6
0C5D:  MOVWF  48
0C5E:  BCF    03.6
0C5F:  MOVF   47,W
0C60:  BSF    03.6
0C61:  MOVWF  49
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
0C62:  BCF    03.6
0C63:  CLRF   6F
0C64:  MOVLW  01
0C65:  SUBWF  6A,W
0C66:  SUBWF  6F,W
0C67:  BTFSC  03.0
0C68:  GOTO   50D
....................          setX(i, getX(i + 1)); 
0C69:  MOVF   6F,W
0C6A:  SUBLW  1F
0C6B:  BTFSS  03.0
0C6C:  GOTO   494
0C6D:  MOVLW  27
0C6E:  ADDWF  6F,W
0C6F:  BSF    03.6
0C70:  MOVWF  4A
0C71:  CLRF   4B
0C72:  BTFSC  03.0
0C73:  INCF   4B,F
0C74:  MOVLW  01
0C75:  BCF    03.6
0C76:  ADDWF  6F,W
0C77:  SUBLW  1F
0C78:  BTFSS  03.0
0C79:  GOTO   481
0C7A:  MOVLW  01
0C7B:  ADDWF  6F,W
0C7C:  ADDLW  27
0C7D:  MOVWF  04
0C7E:  BCF    03.7
0C7F:  MOVF   00,W
0C80:  GOTO   488
0C81:  MOVLW  01
0C82:  ADDWF  6F,W
0C83:  ADDLW  E0
0C84:  ADDLW  A0
0C85:  MOVWF  04
0C86:  BCF    03.7
0C87:  MOVF   00,W
0C88:  BSF    03.6
0C89:  MOVWF  4C
0C8A:  MOVF   4A,W
0C8B:  MOVWF  04
0C8C:  BCF    03.7
0C8D:  BTFSC  4B.0
0C8E:  BSF    03.7
0C8F:  MOVF   4C,W
0C90:  MOVWF  00
0C91:  MOVF   4C,W
0C92:  GOTO   4B9
0C93:  BCF    03.6
0C94:  MOVLW  20
0C95:  SUBWF  6F,W
0C96:  ADDLW  A0
0C97:  BSF    03.6
0C98:  MOVWF  4C
0C99:  CLRF   4D
0C9A:  BTFSC  03.0
0C9B:  INCF   4D,F
0C9C:  MOVLW  01
0C9D:  BCF    03.6
0C9E:  ADDWF  6F,W
0C9F:  SUBLW  1F
0CA0:  BTFSS  03.0
0CA1:  GOTO   4A9
0CA2:  MOVLW  01
0CA3:  ADDWF  6F,W
0CA4:  ADDLW  27
0CA5:  MOVWF  04
0CA6:  BCF    03.7
0CA7:  MOVF   00,W
0CA8:  GOTO   4B0
0CA9:  MOVLW  01
0CAA:  ADDWF  6F,W
0CAB:  ADDLW  E0
0CAC:  ADDLW  A0
0CAD:  MOVWF  04
0CAE:  BCF    03.7
0CAF:  MOVF   00,W
0CB0:  BSF    03.6
0CB1:  MOVWF  4A
0CB2:  MOVF   4C,W
0CB3:  MOVWF  04
0CB4:  BCF    03.7
0CB5:  BTFSC  4D.0
0CB6:  BSF    03.7
0CB7:  MOVF   4A,W
0CB8:  MOVWF  00
....................          setY(i, getY(i + 1)); 
0CB9:  BCF    03.6
0CBA:  MOVF   6F,W
0CBB:  SUBLW  1F
0CBC:  BTFSS  03.0
0CBD:  GOTO   4E5
0CBE:  MOVLW  47
0CBF:  ADDWF  6F,W
0CC0:  BSF    03.6
0CC1:  MOVWF  4A
0CC2:  CLRF   4B
0CC3:  BTFSC  03.0
0CC4:  INCF   4B,F
0CC5:  MOVLW  01
0CC6:  BCF    03.6
0CC7:  ADDWF  6F,W
0CC8:  SUBLW  1F
0CC9:  BTFSS  03.0
0CCA:  GOTO   4D2
0CCB:  MOVLW  01
0CCC:  ADDWF  6F,W
0CCD:  ADDLW  47
0CCE:  MOVWF  04
0CCF:  BCF    03.7
0CD0:  MOVF   00,W
0CD1:  GOTO   4D9
0CD2:  MOVLW  01
0CD3:  ADDWF  6F,W
0CD4:  ADDLW  E0
0CD5:  ADDLW  C0
0CD6:  MOVWF  04
0CD7:  BCF    03.7
0CD8:  MOVF   00,W
0CD9:  BSF    03.6
0CDA:  MOVWF  4C
0CDB:  MOVF   4A,W
0CDC:  MOVWF  04
0CDD:  BCF    03.7
0CDE:  BTFSC  4B.0
0CDF:  BSF    03.7
0CE0:  MOVF   4C,W
0CE1:  MOVWF  00
0CE2:  MOVF   4C,W
0CE3:  GOTO   50A
0CE4:  BCF    03.6
0CE5:  MOVLW  20
0CE6:  SUBWF  6F,W
0CE7:  ADDLW  C0
0CE8:  BSF    03.6
0CE9:  MOVWF  4C
0CEA:  CLRF   4D
0CEB:  BTFSC  03.0
0CEC:  INCF   4D,F
0CED:  MOVLW  01
0CEE:  BCF    03.6
0CEF:  ADDWF  6F,W
0CF0:  SUBLW  1F
0CF1:  BTFSS  03.0
0CF2:  GOTO   4FA
0CF3:  MOVLW  01
0CF4:  ADDWF  6F,W
0CF5:  ADDLW  47
0CF6:  MOVWF  04
0CF7:  BCF    03.7
0CF8:  MOVF   00,W
0CF9:  GOTO   501
0CFA:  MOVLW  01
0CFB:  ADDWF  6F,W
0CFC:  ADDLW  E0
0CFD:  ADDLW  C0
0CFE:  MOVWF  04
0CFF:  BCF    03.7
0D00:  MOVF   00,W
0D01:  BSF    03.6
0D02:  MOVWF  4A
0D03:  MOVF   4C,W
0D04:  MOVWF  04
0D05:  BCF    03.7
0D06:  BTFSC  4D.0
0D07:  BSF    03.7
0D08:  MOVF   4A,W
0D09:  MOVWF  00
0D0A:  BCF    03.6
0D0B:  INCF   6F,F
0D0C:  GOTO   464
....................       } 
....................       setX(LENGTH_SNAKE - 1, posX); 
0D0D:  MOVLW  01
0D0E:  SUBWF  6A,W
0D0F:  SUBLW  1F
0D10:  BTFSS  03.0
0D11:  GOTO   51B
0D12:  MOVLW  01
0D13:  SUBWF  6A,W
0D14:  ADDLW  27
0D15:  MOVWF  04
0D16:  BCF    03.7
0D17:  MOVF   6B,W
0D18:  MOVWF  00
0D19:  MOVF   6B,W
0D1A:  GOTO   523
0D1B:  MOVLW  01
0D1C:  SUBWF  6A,W
0D1D:  ADDLW  E0
0D1E:  ADDLW  A0
0D1F:  MOVWF  04
0D20:  BCF    03.7
0D21:  MOVF   6B,W
0D22:  MOVWF  00
....................       setY(LENGTH_SNAKE - 1, posY); 
0D23:  MOVLW  01
0D24:  SUBWF  6A,W
0D25:  SUBLW  1F
0D26:  BTFSS  03.0
0D27:  GOTO   531
0D28:  MOVLW  01
0D29:  SUBWF  6A,W
0D2A:  ADDLW  47
0D2B:  MOVWF  04
0D2C:  BCF    03.7
0D2D:  MOVF   6C,W
0D2E:  MOVWF  00
0D2F:  MOVF   6C,W
0D30:  GOTO   539
0D31:  MOVLW  01
0D32:  SUBWF  6A,W
0D33:  ADDLW  E0
0D34:  ADDLW  C0
0D35:  MOVWF  04
0D36:  BCF    03.7
0D37:  MOVF   6C,W
0D38:  MOVWF  00
....................  
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
0D39:  CLRF   6F
0D3A:  MOVLW  01
0D3B:  SUBWF  6A,W
0D3C:  SUBWF  6F,W
0D3D:  BTFSC  03.0
0D3E:  GOTO   56B
....................          if (getX(i) == posX && getY(i) == posY) { 
0D3F:  MOVF   6F,W
0D40:  SUBLW  1F
0D41:  BTFSS  03.0
0D42:  GOTO   549
0D43:  MOVLW  27
0D44:  ADDWF  6F,W
0D45:  MOVWF  04
0D46:  BCF    03.7
0D47:  MOVF   00,W
0D48:  GOTO   54F
0D49:  MOVLW  20
0D4A:  SUBWF  6F,W
0D4B:  ADDLW  A0
0D4C:  MOVWF  04
0D4D:  BCF    03.7
0D4E:  MOVF   00,W
0D4F:  SUBWF  6B,W
0D50:  BTFSS  03.2
0D51:  GOTO   569
0D52:  MOVF   6F,W
0D53:  SUBLW  1F
0D54:  BTFSS  03.0
0D55:  GOTO   55C
0D56:  MOVLW  47
0D57:  ADDWF  6F,W
0D58:  MOVWF  04
0D59:  BCF    03.7
0D5A:  MOVF   00,W
0D5B:  GOTO   562
0D5C:  MOVLW  20
0D5D:  SUBWF  6F,W
0D5E:  ADDLW  C0
0D5F:  MOVWF  04
0D60:  BCF    03.7
0D61:  MOVF   00,W
0D62:  SUBWF  6C,W
0D63:  BTFSS  03.2
0D64:  GOTO   569
....................             gameover(); goto Start; 
0D65:  CALL   1CB
0D66:  BSF    03.6
0D67:  GOTO   366
0D68:  BCF    03.6
....................          } 
0D69:  INCF   6F,F
0D6A:  GOTO   53A
....................       } 
....................  
....................       fillCell(posX, posY, 1); 
0D6B:  MOVF   6B,W
0D6C:  BSF    03.6
0D6D:  MOVWF  4C
0D6E:  BCF    03.6
0D6F:  MOVF   6C,W
0D70:  BSF    03.6
0D71:  MOVWF  4D
0D72:  MOVLW  01
0D73:  MOVWF  4E
0D74:  BCF    03.6
0D75:  CALL   103
....................       fillCell(tailX, tailY, 0); 
0D76:  BSF    03.6
0D77:  MOVF   48,W
0D78:  MOVWF  4C
0D79:  MOVF   49,W
0D7A:  MOVWF  4D
0D7B:  CLRF   4E
0D7C:  BCF    03.6
0D7D:  CALL   103
....................  
....................       if (posX == food[0] && posY == food[1]) { 
0D7E:  MOVF   68,W
0D7F:  SUBWF  6B,W
0D80:  BTFSS  03.2
0D81:  GOTO   5D7
0D82:  MOVF   69,W
0D83:  SUBWF  6C,W
0D84:  BTFSS  03.2
0D85:  GOTO   5D7
....................          buzzer_beep(50); 
0D86:  MOVLW  32
0D87:  BSF    03.6
0D88:  MOVWF  5C
0D89:  BCF    0A.3
0D8A:  BCF    03.6
0D8B:  CALL   38B
0D8C:  BSF    0A.3
....................          LENGTH_SNAKE++; 
0D8D:  INCF   6A,F
....................          if (LENGTH_SNAKE >= 64) { 
0D8E:  MOVF   6A,W
0D8F:  SUBLW  3F
0D90:  BTFSC  03.0
0D91:  GOTO   596
....................             winScreen(); goto Start; 
0D92:  GOTO   230
0D93:  BSF    03.6
0D94:  GOTO   366
0D95:  BCF    03.6
....................          } 
....................          criar_comida(); 
0D96:  CALL   157
....................          score++; 
0D97:  INCF   6D,F
....................          score_txt[7] = '0' + (score / 10); 
0D98:  MOVF   6D,W
0D99:  BSF    03.6
0D9A:  MOVWF  4A
0D9B:  MOVLW  0A
0D9C:  MOVWF  4B
0D9D:  BCF    0A.3
0D9E:  BCF    03.6
0D9F:  CALL   7D3
0DA0:  BSF    0A.3
0DA1:  MOVF   78,W
0DA2:  ADDLW  30
0DA3:  BSF    03.5
0DA4:  MOVWF  67
....................          score_txt[8] = '0' + (score % 10); 
0DA5:  BCF    03.5
0DA6:  MOVF   6D,W
0DA7:  BSF    03.6
0DA8:  MOVWF  4A
0DA9:  MOVLW  0A
0DAA:  MOVWF  4B
0DAB:  BCF    0A.3
0DAC:  BCF    03.6
0DAD:  CALL   7D3
0DAE:  BSF    0A.3
0DAF:  MOVF   77,W
0DB0:  ADDLW  30
0DB1:  BSF    03.5
0DB2:  MOVWF  68
....................  
....................          if (score > best_score) { 
0DB3:  BCF    03.5
0DB4:  MOVF   6D,W
0DB5:  SUBWF  6E,W
0DB6:  BTFSC  03.0
0DB7:  GOTO   5D6
....................             best_score = score; 
0DB8:  MOVF   6D,W
0DB9:  MOVWF  6E
....................             best_score_txt[7] = '0' + (best_score / 10); 
0DBA:  MOVF   6E,W
0DBB:  BSF    03.6
0DBC:  MOVWF  4A
0DBD:  MOVLW  0A
0DBE:  MOVWF  4B
0DBF:  BCF    0A.3
0DC0:  BCF    03.6
0DC1:  CALL   7D3
0DC2:  BSF    0A.3
0DC3:  MOVF   78,W
0DC4:  ADDLW  30
0DC5:  BSF    03.6
0DC6:  MOVWF  17
....................             best_score_txt[8] = '0' + (best_score % 10); 
0DC7:  BCF    03.6
0DC8:  MOVF   6E,W
0DC9:  BSF    03.6
0DCA:  MOVWF  4A
0DCB:  MOVLW  0A
0DCC:  MOVWF  4B
0DCD:  BCF    0A.3
0DCE:  BCF    03.6
0DCF:  CALL   7D3
0DD0:  BSF    0A.3
0DD1:  MOVF   77,W
0DD2:  ADDLW  30
0DD3:  BSF    03.6
0DD4:  MOVWF  18
0DD5:  BCF    03.6
....................          } 
....................  
....................          writeScore(); 
0DD6:  CALL   047
....................       } 
....................  
....................       delay_ms(gameSettings.delay_time * 300); 
0DD7:  MOVF   72,W
0DD8:  ANDLW  03
0DD9:  BSF    03.6
0DDA:  MOVWF  4B
0DDB:  CLRF   60
0DDC:  MOVF   4B,W
0DDD:  MOVWF  5F
0DDE:  MOVLW  01
0DDF:  MOVWF  62
0DE0:  MOVLW  2C
0DE1:  MOVWF  61
0DE2:  BCF    0A.3
0DE3:  BCF    03.6
0DE4:  CALL   34D
0DE5:  BSF    0A.3
0DE6:  MOVF   79,W
0DE7:  BSF    03.6
0DE8:  MOVWF  4B
0DE9:  MOVF   78,W
0DEA:  MOVWF  4A
0DEB:  MOVF   4B,W
0DEC:  MOVWF  4C
0DED:  INCF   4C,F
0DEE:  DECF   4C,F
0DEF:  BTFSC  03.2
0DF0:  GOTO   5F9
0DF1:  MOVLW  FF
0DF2:  MOVWF  5F
0DF3:  BCF    0A.3
0DF4:  BCF    03.6
0DF5:  CALL   338
0DF6:  BSF    0A.3
0DF7:  BSF    03.6
0DF8:  GOTO   5EE
0DF9:  MOVF   4A,W
0DFA:  MOVWF  5F
0DFB:  BCF    0A.3
0DFC:  BCF    03.6
0DFD:  CALL   338
0DFE:  BSF    0A.3
0DFF:  GOTO   3DC
....................    } 
.................... } 
....................  
0E00:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
