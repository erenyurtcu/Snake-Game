CCS PCM C Compiler, Version 5.025, 5967               27-May-25 13:33

               Filename:   C:\Users\Eren\Documents\CCS C Projects\snake_project\main.lst

               ROM used:   2427 words (30%)
                           Largest free fragment is 2048
               RAM used:   139 (38%) at main() level
                           164 (45%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDLW  0B
0008:  BTFSC  03.0
0009:  INCF   0A,F
000A:  MOVWF  02
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  00
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  5F
0013:  RETLW  00
0014:  RETLW  00
0015:  RETLW  00
0016:  RETLW  03
0017:  RETLW  00
0018:  RETLW  03
0019:  RETLW  00
001A:  RETLW  14
001B:  RETLW  3E
001C:  RETLW  14
001D:  RETLW  3E
001E:  RETLW  14
001F:  RETLW  24
0020:  RETLW  2A
0021:  RETLW  7F
0022:  RETLW  2A
0023:  RETLW  12
0024:  RETLW  43
0025:  RETLW  33
0026:  RETLW  08
0027:  RETLW  66
0028:  RETLW  61
0029:  RETLW  36
002A:  RETLW  49
002B:  RETLW  55
002C:  RETLW  22
002D:  RETLW  50
002E:  RETLW  00
002F:  RETLW  05
0030:  RETLW  03
0031:  RETLW  00
0032:  RETLW  00
0033:  RETLW  00
0034:  RETLW  1C
0035:  RETLW  22
0036:  RETLW  41
0037:  RETLW  00
0038:  RETLW  00
0039:  RETLW  41
003A:  RETLW  22
003B:  RETLW  1C
003C:  RETLW  00
003D:  RETLW  14
003E:  RETLW  08
003F:  RETLW  3E
0040:  RETLW  08
0041:  RETLW  14
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  3E
0045:  RETLW  08
0046:  RETLW  08
0047:  RETLW  00
0048:  RETLW  50
0049:  RETLW  30
004A:  RETLW  00
004B:  RETLW  00
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  08
004F:  RETLW  08
0050:  RETLW  08
0051:  RETLW  00
0052:  RETLW  60
0053:  RETLW  60
0054:  RETLW  00
0055:  RETLW  00
0056:  RETLW  20
0057:  RETLW  10
0058:  RETLW  08
0059:  RETLW  04
005A:  RETLW  02
005B:  RETLW  3E
005C:  RETLW  51
005D:  RETLW  49
005E:  RETLW  45
005F:  RETLW  3E
0060:  RETLW  04
0061:  RETLW  02
0062:  RETLW  7F
0063:  RETLW  00
0064:  RETLW  00
0065:  RETLW  42
0066:  RETLW  61
0067:  RETLW  51
0068:  RETLW  49
0069:  RETLW  46
006A:  RETLW  22
006B:  RETLW  41
006C:  RETLW  49
006D:  RETLW  49
006E:  RETLW  36
006F:  RETLW  18
0070:  RETLW  14
0071:  RETLW  12
0072:  RETLW  7F
0073:  RETLW  10
0074:  RETLW  27
0075:  RETLW  45
0076:  RETLW  45
0077:  RETLW  45
0078:  RETLW  39
0079:  RETLW  3E
007A:  RETLW  49
007B:  RETLW  49
007C:  RETLW  49
007D:  RETLW  32
007E:  RETLW  01
007F:  RETLW  01
0080:  RETLW  71
0081:  RETLW  09
0082:  RETLW  07
0083:  RETLW  36
0084:  RETLW  49
0085:  RETLW  49
0086:  RETLW  49
0087:  RETLW  36
0088:  RETLW  26
0089:  RETLW  49
008A:  RETLW  49
008B:  RETLW  49
008C:  RETLW  3E
008D:  RETLW  00
008E:  RETLW  36
008F:  RETLW  36
0090:  RETLW  00
0091:  RETLW  00
0092:  RETLW  00
0093:  RETLW  56
0094:  RETLW  36
0095:  RETLW  00
0096:  RETLW  00
0097:  RETLW  08
0098:  RETLW  14
0099:  RETLW  22
009A:  RETLW  41
009B:  RETLW  00
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  14
009F:  RETLW  14
00A0:  RETLW  14
00A1:  RETLW  00
00A2:  RETLW  41
00A3:  RETLW  22
00A4:  RETLW  14
00A5:  RETLW  08
00A6:  RETLW  02
00A7:  RETLW  01
00A8:  RETLW  51
00A9:  RETLW  09
00AA:  RETLW  06
00AB:  RETLW  3E
00AC:  RETLW  41
00AD:  RETLW  59
00AE:  RETLW  55
00AF:  RETLW  5E
00B0:  RETLW  7E
00B1:  RETLW  09
00B2:  RETLW  09
00B3:  RETLW  09
00B4:  RETLW  7E
00B5:  RETLW  7F
00B6:  RETLW  49
00B7:  RETLW  49
00B8:  RETLW  49
00B9:  RETLW  36
00BA:  RETLW  3E
00BB:  RETLW  41
00BC:  RETLW  41
00BD:  RETLW  41
00BE:  RETLW  22
00BF:  RETLW  7F
00C0:  RETLW  41
00C1:  RETLW  41
00C2:  RETLW  41
00C3:  RETLW  3E
00C4:  RETLW  7F
00C5:  RETLW  49
00C6:  RETLW  49
00C7:  RETLW  49
00C8:  RETLW  41
00C9:  RETLW  7F
00CA:  RETLW  09
00CB:  RETLW  09
00CC:  RETLW  09
00CD:  RETLW  01
00CE:  RETLW  3E
00CF:  RETLW  41
00D0:  RETLW  41
00D1:  RETLW  49
00D2:  RETLW  3A
00D3:  RETLW  7F
00D4:  RETLW  08
00D5:  RETLW  08
00D6:  RETLW  08
00D7:  RETLW  7F
00D8:  RETLW  00
00D9:  RETLW  41
00DA:  RETLW  7F
00DB:  RETLW  41
00DC:  RETLW  00
00DD:  RETLW  30
00DE:  RETLW  40
00DF:  RETLW  40
00E0:  RETLW  40
00E1:  RETLW  3F
00E2:  RETLW  7F
00E3:  RETLW  08
00E4:  RETLW  14
00E5:  RETLW  22
00E6:  RETLW  41
00E7:  RETLW  7F
00E8:  RETLW  40
00E9:  RETLW  40
00EA:  RETLW  40
00EB:  RETLW  40
00EC:  RETLW  7F
00ED:  RETLW  02
00EE:  RETLW  0C
00EF:  RETLW  02
00F0:  RETLW  7F
00F1:  RETLW  7F
00F2:  RETLW  02
00F3:  RETLW  04
00F4:  RETLW  08
00F5:  RETLW  7F
00F6:  RETLW  3E
00F7:  RETLW  41
00F8:  RETLW  41
00F9:  RETLW  41
00FA:  RETLW  3E
00FB:  RETLW  7F
00FC:  RETLW  09
00FD:  RETLW  09
00FE:  RETLW  09
00FF:  RETLW  06
0100:  RETLW  1E
0101:  RETLW  21
0102:  RETLW  21
0103:  RETLW  21
0104:  RETLW  5E
0105:  RETLW  7F
0106:  RETLW  09
0107:  RETLW  09
0108:  RETLW  09
0109:  RETLW  76
010A:  BSF    0A.0
010B:  BCF    0A.1
010C:  BCF    0A.2
010D:  ADDWF  02,F
010E:  RETLW  26
010F:  RETLW  49
0110:  RETLW  49
0111:  RETLW  49
0112:  RETLW  32
0113:  RETLW  01
0114:  RETLW  01
0115:  RETLW  7F
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  3F
0119:  RETLW  40
011A:  RETLW  40
011B:  RETLW  40
011C:  RETLW  3F
011D:  RETLW  1F
011E:  RETLW  20
011F:  RETLW  40
0120:  RETLW  20
0121:  RETLW  1F
0122:  RETLW  7F
0123:  RETLW  20
0124:  RETLW  10
0125:  RETLW  20
0126:  RETLW  7F
0127:  RETLW  41
0128:  RETLW  22
0129:  RETLW  1C
012A:  RETLW  22
012B:  RETLW  41
012C:  RETLW  07
012D:  RETLW  08
012E:  RETLW  70
012F:  RETLW  08
0130:  RETLW  07
0131:  RETLW  61
0132:  RETLW  51
0133:  RETLW  49
0134:  RETLW  45
0135:  RETLW  43
0136:  RETLW  00
0137:  RETLW  7F
0138:  RETLW  41
0139:  RETLW  00
013A:  RETLW  00
013B:  RETLW  02
013C:  RETLW  04
013D:  RETLW  08
013E:  RETLW  10
013F:  RETLW  20
0140:  RETLW  00
0141:  RETLW  00
0142:  RETLW  41
0143:  RETLW  7F
0144:  RETLW  00
0145:  RETLW  04
0146:  RETLW  02
0147:  RETLW  01
0148:  RETLW  02
0149:  RETLW  04
014A:  RETLW  40
014B:  RETLW  40
014C:  RETLW  40
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  00
0150:  RETLW  01
0151:  RETLW  02
0152:  RETLW  04
0153:  RETLW  00
0154:  RETLW  20
0155:  RETLW  54
0156:  RETLW  54
0157:  RETLW  54
0158:  RETLW  78
0159:  RETLW  7F
015A:  RETLW  44
015B:  RETLW  44
015C:  RETLW  44
015D:  RETLW  38
015E:  RETLW  38
015F:  RETLW  44
0160:  RETLW  44
0161:  RETLW  44
0162:  RETLW  44
0163:  RETLW  38
0164:  RETLW  44
0165:  RETLW  44
0166:  RETLW  44
0167:  RETLW  7F
0168:  RETLW  38
0169:  RETLW  54
016A:  RETLW  54
016B:  RETLW  54
016C:  RETLW  18
016D:  RETLW  04
016E:  RETLW  04
016F:  RETLW  7E
0170:  RETLW  05
0171:  RETLW  05
0172:  RETLW  08
0173:  RETLW  54
0174:  RETLW  54
0175:  RETLW  54
0176:  RETLW  3C
0177:  RETLW  7F
0178:  RETLW  08
0179:  RETLW  04
017A:  RETLW  04
017B:  RETLW  78
017C:  RETLW  00
017D:  RETLW  44
017E:  RETLW  7D
017F:  RETLW  40
0180:  RETLW  00
0181:  RETLW  20
0182:  RETLW  40
0183:  RETLW  44
0184:  RETLW  3D
0185:  RETLW  00
0186:  RETLW  7F
0187:  RETLW  10
0188:  RETLW  28
0189:  RETLW  44
018A:  RETLW  00
018B:  RETLW  00
018C:  RETLW  41
018D:  RETLW  7F
018E:  RETLW  40
018F:  RETLW  00
0190:  RETLW  7C
0191:  RETLW  04
0192:  RETLW  78
0193:  RETLW  04
0194:  RETLW  78
0195:  RETLW  7C
0196:  RETLW  08
0197:  RETLW  04
0198:  RETLW  04
0199:  RETLW  78
019A:  RETLW  38
019B:  RETLW  44
019C:  RETLW  44
019D:  RETLW  44
019E:  RETLW  38
019F:  RETLW  7C
01A0:  RETLW  14
01A1:  RETLW  14
01A2:  RETLW  14
01A3:  RETLW  08
01A4:  RETLW  08
01A5:  RETLW  14
01A6:  RETLW  14
01A7:  RETLW  14
01A8:  RETLW  7C
01A9:  RETLW  00
01AA:  RETLW  7C
01AB:  RETLW  08
01AC:  RETLW  04
01AD:  RETLW  04
01AE:  RETLW  48
01AF:  RETLW  54
01B0:  RETLW  54
01B1:  RETLW  54
01B2:  RETLW  20
01B3:  RETLW  04
01B4:  RETLW  04
01B5:  RETLW  3F
01B6:  RETLW  44
01B7:  RETLW  44
01B8:  RETLW  3C
01B9:  RETLW  40
01BA:  RETLW  40
01BB:  RETLW  20
01BC:  RETLW  7C
01BD:  RETLW  1C
01BE:  RETLW  20
01BF:  RETLW  40
01C0:  RETLW  20
01C1:  RETLW  1C
01C2:  RETLW  3C
01C3:  RETLW  40
01C4:  RETLW  30
01C5:  RETLW  40
01C6:  RETLW  3C
01C7:  RETLW  44
01C8:  RETLW  28
01C9:  RETLW  10
01CA:  RETLW  28
01CB:  RETLW  44
01CC:  RETLW  0C
01CD:  RETLW  50
01CE:  RETLW  50
01CF:  RETLW  50
01D0:  RETLW  3C
01D1:  RETLW  44
01D2:  RETLW  64
01D3:  RETLW  54
01D4:  RETLW  4C
01D5:  RETLW  44
01D6:  RETLW  00
01D7:  RETLW  08
01D8:  RETLW  36
01D9:  RETLW  41
01DA:  RETLW  41
01DB:  RETLW  00
01DC:  RETLW  00
01DD:  RETLW  7F
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  41
01E1:  RETLW  41
01E2:  RETLW  36
01E3:  RETLW  08
01E4:  RETLW  00
01E5:  RETLW  02
01E6:  RETLW  01
01E7:  RETLW  02
01E8:  RETLW  04
01E9:  RETLW  02
*
0216:  CLRF   77
0217:  CLRF   78
0218:  BSF    03.5
0219:  MOVF   5D,W
021A:  BCF    03.0
021B:  BTFSC  5E.0
021C:  ADDWF  77,F
021D:  RRF    77,F
021E:  RRF    78,F
021F:  BTFSC  5E.1
0220:  ADDWF  77,F
0221:  RRF    77,F
0222:  RRF    78,F
0223:  BTFSC  5E.2
0224:  ADDWF  77,F
0225:  RRF    77,F
0226:  RRF    78,F
0227:  BTFSC  5E.3
0228:  ADDWF  77,F
0229:  RRF    77,F
022A:  RRF    78,F
022B:  BTFSC  5E.4
022C:  ADDWF  77,F
022D:  RRF    77,F
022E:  RRF    78,F
022F:  BTFSC  5E.5
0230:  ADDWF  77,F
0231:  RRF    77,F
0232:  RRF    78,F
0233:  BTFSC  5E.6
0234:  ADDWF  77,F
0235:  RRF    77,F
0236:  RRF    78,F
0237:  BTFSC  5E.7
0238:  ADDWF  77,F
0239:  RRF    77,F
023A:  RRF    78,F
023B:  BCF    03.5
023C:  RETURN
*
05E5:  CLRF   78
05E6:  CLRF   79
05E7:  CLRF   77
05E8:  CLRF   7A
05E9:  BSF    03.5
05EA:  MOVF   52,W
05EB:  BTFSS  03.2
05EC:  GOTO   5F0
05ED:  MOVF   51,W
05EE:  BTFSC  03.2
05EF:  GOTO   60A
05F0:  MOVLW  10
05F1:  MOVWF  53
05F2:  BCF    03.0
05F3:  RLF    4F,F
05F4:  RLF    50,F
05F5:  RLF    77,F
05F6:  RLF    7A,F
05F7:  MOVF   52,W
05F8:  SUBWF  7A,W
05F9:  BTFSS  03.2
05FA:  GOTO   5FD
05FB:  MOVF   51,W
05FC:  SUBWF  77,W
05FD:  BTFSS  03.0
05FE:  GOTO   606
05FF:  MOVF   51,W
0600:  SUBWF  77,F
0601:  BTFSS  03.0
0602:  DECF   7A,F
0603:  MOVF   52,W
0604:  SUBWF  7A,F
0605:  BSF    03.0
0606:  RLF    78,F
0607:  RLF    79,F
0608:  DECFSZ 53,F
0609:  GOTO   5F2
060A:  BCF    03.5
060B:  RETURN
*
0623:  MOVLW  20
0624:  MOVWF  58
0625:  CLRF   54
0626:  CLRF   55
0627:  CLRF   56
0628:  CLRF   57
0629:  MOVF   4F,W
062A:  MOVWF  7A
062B:  MOVF   4E,W
062C:  MOVWF  79
062D:  MOVF   4D,W
062E:  MOVWF  78
062F:  MOVF   4C,W
0630:  MOVWF  77
0631:  BCF    03.0
0632:  BTFSS  77.0
0633:  GOTO   642
0634:  MOVF   50,W
0635:  ADDWF  54,F
0636:  MOVF   51,W
0637:  BTFSC  03.0
0638:  INCFSZ 51,W
0639:  ADDWF  55,F
063A:  MOVF   52,W
063B:  BTFSC  03.0
063C:  INCFSZ 52,W
063D:  ADDWF  56,F
063E:  MOVF   53,W
063F:  BTFSC  03.0
0640:  INCFSZ 53,W
0641:  ADDWF  57,F
0642:  RRF    57,F
0643:  RRF    56,F
0644:  RRF    55,F
0645:  RRF    54,F
0646:  RRF    7A,F
0647:  RRF    79,F
0648:  RRF    78,F
0649:  RRF    77,F
064A:  DECFSZ 58,F
064B:  GOTO   631
*
0739:  BSF    03.5
073A:  MOVF   4B,W
073B:  CLRF   78
073C:  SUBWF  4A,W
073D:  BTFSC  03.0
073E:  GOTO   742
073F:  MOVF   4A,W
0740:  MOVWF  77
0741:  GOTO   74E
0742:  CLRF   77
0743:  MOVLW  08
0744:  MOVWF  4C
0745:  RLF    4A,F
0746:  RLF    77,F
0747:  MOVF   4B,W
0748:  SUBWF  77,W
0749:  BTFSC  03.0
074A:  MOVWF  77
074B:  RLF    78,F
074C:  DECFSZ 4C,F
074D:  GOTO   745
074E:  BCF    03.5
074F:  RETURN
*
0A23:  BCF    0A.0
0A24:  BSF    0A.1
0A25:  BCF    0A.2
0A26:  ADDWF  02,F
0A27:  GOTO   0F9
0A28:  GOTO   107
0A29:  GOTO   115
0A2A:  GOTO   124
....................  
.................... #list 
....................  
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP 
.................... #use delay(clock=16000000) 
*
04C8:  MOVLW  CB
04C9:  MOVWF  04
04CA:  BCF    03.7
04CB:  MOVF   00,W
04CC:  BTFSC  03.2
04CD:  GOTO   4DC
04CE:  MOVLW  05
04CF:  MOVWF  78
04D0:  CLRF   77
04D1:  DECFSZ 77,F
04D2:  GOTO   4D1
04D3:  DECFSZ 78,F
04D4:  GOTO   4D0
04D5:  MOVLW  2E
04D6:  MOVWF  77
04D7:  DECFSZ 77,F
04D8:  GOTO   4D7
04D9:  GOTO   4DA
04DA:  DECFSZ 00,F
04DB:  GOTO   4CE
04DC:  RETURN
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0817:  BCF    03.5
0818:  CLRF   20
0819:  CLRF   21
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
060C:  MOVF   25,W
060D:  BSF    03.5
060E:  MOVWF  4F
060F:  BCF    03.5
0610:  MOVF   24,W
0611:  BSF    03.5
0612:  MOVWF  4E
0613:  BCF    03.5
0614:  MOVF   23,W
0615:  BSF    03.5
0616:  MOVWF  4D
0617:  BCF    03.5
0618:  MOVF   22,W
0619:  BSF    03.5
061A:  MOVWF  4C
061B:  MOVLW  41
061C:  MOVWF  53
061D:  MOVLW  C6
061E:  MOVWF  52
061F:  MOVLW  4E
0620:  MOVWF  51
0621:  MOVLW  6D
0622:  MOVWF  50
*
064C:  MOVF   7A,W
064D:  MOVWF  4F
064E:  MOVF   79,W
064F:  MOVWF  4E
0650:  MOVF   78,W
0651:  MOVWF  4D
0652:  MOVF   77,W
0653:  MOVWF  4C
0654:  MOVLW  39
0655:  ADDWF  4C,W
0656:  BCF    03.5
0657:  MOVWF  22
0658:  BSF    03.5
0659:  MOVF   4D,W
065A:  BCF    03.5
065B:  MOVWF  23
065C:  MOVLW  30
065D:  BTFSC  03.0
065E:  MOVLW  31
065F:  ADDWF  23,F
0660:  BSF    03.5
0661:  MOVF   4E,W
0662:  BCF    03.5
0663:  MOVWF  24
0664:  MOVLW  00
0665:  BTFSC  03.0
0666:  MOVLW  01
0667:  ADDWF  24,F
0668:  BSF    03.5
0669:  MOVF   4F,W
066A:  BCF    03.5
066B:  MOVWF  25
066C:  MOVLW  00
066D:  BTFSC  03.0
066E:  MOVLW  01
066F:  ADDWF  25,F
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0670:  MOVF   24,W
0671:  MOVWF  77
0672:  MOVF   25,W
0673:  MOVWF  78
0674:  CLRF   79
0675:  CLRF   7A
0676:  MOVF   25,W
0677:  BSF    03.5
0678:  MOVWF  4E
0679:  MOVF   77,W
067A:  MOVWF  4D
067B:  MOVF   4E,W
067C:  MOVWF  50
067D:  MOVF   4D,W
067E:  MOVWF  4F
067F:  MOVLW  7F
0680:  MOVWF  52
0681:  MOVLW  FF
0682:  MOVWF  51
0683:  BCF    03.5
0684:  CALL   5E5
0685:  MOVF   77,W
0686:  MOVWF  78
0687:  MOVF   7A,W
0688:  MOVWF  79
0689:  RETURN
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <glcd.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
0298:  BCF    26.0
0299:  MOVF   26,W
029A:  BSF    03.5
029B:  MOVWF  07
029C:  BCF    03.5
029D:  BSF    07.0
....................    output_low(GLCD_E); 
029E:  BSF    03.5
029F:  BCF    06.5
02A0:  BCF    03.5
02A1:  BCF    06.5
....................    output_low(GLCD_CS1); 
02A2:  BSF    03.5
02A3:  BCF    06.0
02A4:  BCF    03.5
02A5:  BCF    06.0
....................    output_low(GLCD_CS2); 
02A6:  BSF    03.5
02A7:  BCF    06.1
02A8:  BCF    03.5
02A9:  BCF    06.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
02AA:  BSF    03.5
02AB:  BCF    06.2
02AC:  BCF    03.5
02AD:  BCF    06.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
02AE:  MOVLW  30
02AF:  BSF    03.5
02B0:  MOVWF  62
02B1:  MOVLW  C0
02B2:  MOVWF  63
02B3:  BCF    03.5
02B4:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
02B5:  MOVLW  31
02B6:  BSF    03.5
02B7:  MOVWF  62
02B8:  MOVLW  C0
02B9:  MOVWF  63
02BA:  BCF    03.5
02BB:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
02BC:  MOVLW  30
02BD:  BSF    03.5
02BE:  MOVWF  62
02BF:  MOVLW  40
02C0:  MOVWF  63
02C1:  BCF    03.5
02C2:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0x40); 
02C3:  MOVLW  31
02C4:  BSF    03.5
02C5:  MOVWF  62
02C6:  MOVLW  40
02C7:  MOVWF  63
02C8:  BCF    03.5
02C9:  CALL   1EA
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
02CA:  MOVLW  30
02CB:  BSF    03.5
02CC:  MOVWF  62
02CD:  MOVLW  B8
02CE:  MOVWF  63
02CF:  BCF    03.5
02D0:  CALL   1EA
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
02D1:  MOVLW  31
02D2:  BSF    03.5
02D3:  MOVWF  62
02D4:  MOVLW  B8
02D5:  MOVWF  63
02D6:  BCF    03.5
02D7:  CALL   1EA
....................    if(mode == ON) 
02D8:  BSF    03.5
02D9:  DECFSZ 4A,W
02DA:  GOTO   2EA
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
02DB:  MOVLW  30
02DC:  MOVWF  62
02DD:  MOVLW  3F
02DE:  MOVWF  63
02DF:  BCF    03.5
02E0:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
02E1:  MOVLW  31
02E2:  BSF    03.5
02E3:  MOVWF  62
02E4:  MOVLW  3F
02E5:  MOVWF  63
02E6:  BCF    03.5
02E7:  CALL   1EA
....................    } 
02E8:  GOTO   2F7
02E9:  BSF    03.5
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
02EA:  MOVLW  30
02EB:  MOVWF  62
02EC:  MOVLW  3E
02ED:  MOVWF  63
02EE:  BCF    03.5
02EF:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
02F0:  MOVLW  31
02F1:  BSF    03.5
02F2:  MOVWF  62
02F3:  MOVLW  3E
02F4:  MOVWF  63
02F5:  BCF    03.5
02F6:  CALL   1EA
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
02F7:  BSF    03.5
02F8:  CLRF   4B
02F9:  BCF    03.5
02FA:  CALL   23D
02FB:  BSF    0A.3
02FC:  BCF    0A.4
02FD:  GOTO   05B (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
02FE:  MOVLW  30
02FF:  BSF    03.5
0300:  MOVWF  60
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
0301:  MOVF   5C,W
0302:  SUBLW  3F
0303:  BTFSC  03.0
0304:  GOTO   309
....................    { 
....................       x -= 64; 
0305:  MOVLW  40
0306:  SUBWF  5C,F
....................       chip = GLCD_CS2; 
0307:  MOVLW  31
0308:  MOVWF  60
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
0309:  BCF    06.2
030A:  BCF    03.5
030B:  BCF    06.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
030C:  BSF    03.5
030D:  BCF    5C.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
030E:  BSF    5C.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
030F:  MOVF   60,W
0310:  MOVWF  62
0311:  MOVF   5C,W
0312:  MOVWF  63
0313:  BCF    03.5
0314:  CALL   1EA
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
0315:  BSF    03.5
0316:  RRF    5D,W
0317:  MOVWF  77
0318:  RRF    77,F
0319:  RRF    77,F
031A:  MOVLW  1F
031B:  ANDWF  77,F
031C:  MOVF   77,W
031D:  ANDLW  BF
031E:  IORLW  B8
031F:  MOVWF  61
0320:  MOVF   60,W
0321:  MOVWF  62
0322:  MOVF   61,W
0323:  MOVWF  63
0324:  BCF    03.5
0325:  CALL   1EA
....................    output_high(GLCD_DI);                                    // Set for data 
0326:  BSF    03.5
0327:  BCF    06.2
0328:  BCF    03.5
0329:  BSF    06.2
....................    data = glcd_readByte(chip); 
032A:  BSF    03.5
032B:  MOVF   60,W
032C:  MOVWF  61
*
036F:  MOVF   78,W
0370:  MOVWF  5F
....................  
....................    if(color == ON) 
0371:  DECFSZ 5E,W
0372:  GOTO   383
....................       bit_set(data, y%8);        // Turn the pixel on 
0373:  MOVF   5D,W
0374:  ANDLW  07
0375:  MOVWF  61
0376:  MOVLW  01
0377:  MOVWF  77
0378:  MOVF   61,W
0379:  MOVWF  78
037A:  BTFSC  03.2
037B:  GOTO   380
037C:  BCF    03.0
037D:  RLF    77,F
037E:  DECFSZ 78,F
037F:  GOTO   37C
0380:  MOVF   77,W
0381:  IORWF  5F,F
0382:  GOTO   393
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
0383:  MOVF   5D,W
0384:  ANDLW  07
0385:  MOVWF  61
0386:  MOVLW  01
0387:  MOVWF  77
0388:  MOVF   61,W
0389:  MOVWF  78
038A:  BTFSC  03.2
038B:  GOTO   390
038C:  BCF    03.0
038D:  RLF    77,F
038E:  DECFSZ 78,F
038F:  GOTO   38C
0390:  MOVF   77,W
0391:  XORLW  FF
0392:  ANDWF  5F,F
....................    output_low(GLCD_DI);          // Set for instruction 
0393:  BCF    06.2
0394:  BCF    03.5
0395:  BCF    06.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
0396:  BSF    03.5
0397:  MOVF   60,W
0398:  MOVWF  62
0399:  MOVF   5C,W
039A:  MOVWF  63
039B:  BCF    03.5
039C:  CALL   1EA
....................    output_high(GLCD_DI);         // Set for data 
039D:  BSF    03.5
039E:  BCF    06.2
039F:  BCF    03.5
03A0:  BSF    06.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
03A1:  BSF    03.5
03A2:  MOVF   60,W
03A3:  MOVWF  62
03A4:  MOVF   5F,W
03A5:  MOVWF  63
03A6:  BCF    03.5
03A7:  CALL   1EA
03A8:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
03A9:  BSF    03.5
03AA:  MOVF   4E,W
03AB:  SUBWF  50,W
03AC:  MOVWF  5C
03AD:  MOVF   5C,W
03AE:  BTFSS  5C.7
03AF:  GOTO   3B2
03B0:  MOVF   5C,W
03B1:  SUBLW  00
03B2:  MOVWF  57
....................    dy = abs((signed int)(y2 - y1)); 
03B3:  MOVF   4F,W
03B4:  SUBWF  51,W
03B5:  MOVWF  5C
03B6:  MOVF   5C,W
03B7:  BTFSS  5C.7
03B8:  GOTO   3BB
03B9:  MOVF   5C,W
03BA:  SUBLW  00
03BB:  MOVWF  58
....................    x = x1; 
03BC:  MOVF   4E,W
03BD:  MOVWF  53
....................    y = y1; 
03BE:  MOVF   4F,W
03BF:  MOVWF  54
....................  
....................    if(x1 > x2) 
03C0:  MOVF   4E,W
03C1:  SUBWF  50,W
03C2:  BTFSC  03.0
03C3:  GOTO   3C7
....................       addx = -1; 
03C4:  MOVLW  FF
03C5:  MOVWF  55
03C6:  GOTO   3C9
....................    else 
....................       addx = 1; 
03C7:  MOVLW  01
03C8:  MOVWF  55
....................    if(y1 > y2) 
03C9:  MOVF   4F,W
03CA:  SUBWF  51,W
03CB:  BTFSC  03.0
03CC:  GOTO   3D0
....................       addy = -1; 
03CD:  MOVLW  FF
03CE:  MOVWF  56
03CF:  GOTO   3D2
....................    else 
....................       addy = 1; 
03D0:  MOVLW  01
03D1:  MOVWF  56
....................  
....................    if(dx >= dy) 
03D2:  MOVF   58,W
03D3:  XORLW  80
03D4:  MOVWF  77
03D5:  MOVF   57,W
03D6:  XORLW  80
03D7:  SUBWF  77,W
03D8:  BTFSC  03.2
03D9:  GOTO   3DC
03DA:  BTFSC  03.0
03DB:  GOTO   434
....................    { 
....................       P = 2*dy - dx; 
03DC:  MOVLW  02
03DD:  MOVWF  5D
03DE:  MOVF   58,W
03DF:  MOVWF  5E
03E0:  BCF    03.5
03E1:  CALL   216
03E2:  BSF    03.5
03E3:  MOVF   57,W
03E4:  SUBWF  78,W
03E5:  CLRF   7A
03E6:  MOVWF  77
03E7:  BTFSC  77.7
03E8:  DECF   7A,F
03E9:  MOVWF  59
03EA:  MOVF   7A,W
03EB:  MOVWF  5A
....................  
....................       for(i=0; i<=dx; ++i) 
03EC:  CLRF   5B
03ED:  BTFSC  57.7
03EE:  GOTO   433
03EF:  MOVF   5B,W
03F0:  SUBWF  57,W
03F1:  BTFSS  03.0
03F2:  GOTO   433
....................       { 
....................          glcd_pixel(x, y, color); 
03F3:  MOVF   53,W
03F4:  MOVWF  5C
03F5:  MOVF   54,W
03F6:  MOVWF  5D
03F7:  MOVF   52,W
03F8:  MOVWF  5E
03F9:  BCF    03.5
03FA:  CALL   2FE
....................  
....................          if(P < 0) 
03FB:  BSF    03.5
03FC:  BTFSS  5A.7
03FD:  GOTO   412
....................          { 
....................             P += 2*dy; 
03FE:  MOVLW  02
03FF:  MOVWF  5D
0400:  MOVF   58,W
0401:  MOVWF  5E
0402:  BCF    03.5
0403:  CALL   216
0404:  MOVF   78,W
0405:  CLRF   7A
0406:  MOVWF  77
0407:  BTFSC  77.7
0408:  DECF   7A,F
0409:  BSF    03.5
040A:  ADDWF  59,F
040B:  MOVF   7A,W
040C:  BTFSC  03.0
040D:  INCFSZ 7A,W
040E:  ADDWF  5A,F
....................             x += addx; 
040F:  MOVF   55,W
0410:  ADDWF  53,F
....................          } 
0411:  GOTO   431
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
0412:  MOVLW  02
0413:  MOVWF  5D
0414:  MOVF   58,W
0415:  MOVWF  5E
0416:  BCF    03.5
0417:  CALL   216
0418:  MOVF   78,W
0419:  BSF    03.5
041A:  MOVWF  5C
041B:  MOVLW  02
041C:  MOVWF  5D
041D:  MOVF   57,W
041E:  MOVWF  5E
041F:  BCF    03.5
0420:  CALL   216
0421:  MOVF   78,W
0422:  BSF    03.5
0423:  SUBWF  5C,W
0424:  CLRF   7A
0425:  MOVWF  77
0426:  BTFSC  77.7
0427:  DECF   7A,F
0428:  ADDWF  59,F
0429:  MOVF   7A,W
042A:  BTFSC  03.0
042B:  INCFSZ 7A,W
042C:  ADDWF  5A,F
....................             x += addx; 
042D:  MOVF   55,W
042E:  ADDWF  53,F
....................             y += addy; 
042F:  MOVF   56,W
0430:  ADDWF  54,F
....................          } 
0431:  INCF   5B,F
0432:  GOTO   3ED
....................       } 
....................    } 
0433:  GOTO   48B
....................    else 
....................    { 
....................       P = 2*dx - dy; 
0434:  MOVLW  02
0435:  MOVWF  5D
0436:  MOVF   57,W
0437:  MOVWF  5E
0438:  BCF    03.5
0439:  CALL   216
043A:  BSF    03.5
043B:  MOVF   58,W
043C:  SUBWF  78,W
043D:  CLRF   7A
043E:  MOVWF  77
043F:  BTFSC  77.7
0440:  DECF   7A,F
0441:  MOVWF  59
0442:  MOVF   7A,W
0443:  MOVWF  5A
....................  
....................       for(i=0; i<=dy; ++i) 
0444:  CLRF   5B
0445:  BTFSC  58.7
0446:  GOTO   48B
0447:  MOVF   5B,W
0448:  SUBWF  58,W
0449:  BTFSS  03.0
044A:  GOTO   48B
....................       { 
....................          glcd_pixel(x, y, color); 
044B:  MOVF   53,W
044C:  MOVWF  5C
044D:  MOVF   54,W
044E:  MOVWF  5D
044F:  MOVF   52,W
0450:  MOVWF  5E
0451:  BCF    03.5
0452:  CALL   2FE
....................  
....................          if(P < 0) 
0453:  BSF    03.5
0454:  BTFSS  5A.7
0455:  GOTO   46A
....................          { 
....................             P += 2*dx; 
0456:  MOVLW  02
0457:  MOVWF  5D
0458:  MOVF   57,W
0459:  MOVWF  5E
045A:  BCF    03.5
045B:  CALL   216
045C:  MOVF   78,W
045D:  CLRF   7A
045E:  MOVWF  77
045F:  BTFSC  77.7
0460:  DECF   7A,F
0461:  BSF    03.5
0462:  ADDWF  59,F
0463:  MOVF   7A,W
0464:  BTFSC  03.0
0465:  INCFSZ 7A,W
0466:  ADDWF  5A,F
....................             y += addy; 
0467:  MOVF   56,W
0468:  ADDWF  54,F
....................          } 
0469:  GOTO   489
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
046A:  MOVLW  02
046B:  MOVWF  5D
046C:  MOVF   57,W
046D:  MOVWF  5E
046E:  BCF    03.5
046F:  CALL   216
0470:  MOVF   78,W
0471:  BSF    03.5
0472:  MOVWF  5C
0473:  MOVLW  02
0474:  MOVWF  5D
0475:  MOVF   58,W
0476:  MOVWF  5E
0477:  BCF    03.5
0478:  CALL   216
0479:  MOVF   78,W
047A:  BSF    03.5
047B:  SUBWF  5C,W
047C:  CLRF   7A
047D:  MOVWF  77
047E:  BTFSC  77.7
047F:  DECF   7A,F
0480:  ADDWF  59,F
0481:  MOVF   7A,W
0482:  BTFSC  03.0
0483:  INCFSZ 7A,W
0484:  ADDWF  5A,F
....................             x += addx; 
0485:  MOVF   55,W
0486:  ADDWF  53,F
....................             y += addy; 
0487:  MOVF   56,W
0488:  ADDWF  54,F
....................          } 
0489:  INCF   5B,F
048A:  GOTO   445
....................       } 
....................    } 
048B:  BCF    03.5
048C:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
*
04DD:  BSF    03.5
04DE:  CLRF   50
04DF:  MOVF   50,W
04E0:  ADDWF  4C,W
04E1:  MOVWF  04
04E2:  BCF    03.7
04E3:  BTFSC  4D.0
04E4:  BSF    03.7
04E5:  MOVF   00,F
04E6:  BTFSC  03.2
04E7:  GOTO   5B2
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
04E8:  MOVF   50,W
04E9:  ADDWF  4C,W
04EA:  MOVWF  04
04EB:  BCF    03.7
04EC:  BTFSC  4D.0
04ED:  BSF    03.7
04EE:  MOVF   00,W
04EF:  SUBLW  52
04F0:  BTFSS  03.0
04F1:  GOTO   516
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
04F2:  MOVF   50,W
04F3:  ADDWF  4C,W
04F4:  MOVWF  04
04F5:  BCF    03.7
04F6:  BTFSC  4D.0
04F7:  BSF    03.7
04F8:  MOVLW  20
04F9:  SUBWF  00,W
04FA:  MOVWF  5B
04FB:  MOVWF  5D
04FC:  MOVLW  05
04FD:  MOVWF  5E
04FE:  BCF    03.5
04FF:  CALL   216
0500:  MOVF   78,W
0501:  BSF    03.5
0502:  MOVWF  5A
0503:  MOVWF  78
0504:  MOVLW  05
0505:  MOVWF  77
0506:  MOVLW  D5
0507:  MOVWF  04
0508:  BCF    03.7
0509:  MOVF   78,W
050A:  BCF    03.5
050B:  CALL   004
050C:  MOVWF  00
050D:  INCF   78,F
050E:  INCF   04,F
050F:  DECFSZ 77,F
0510:  GOTO   512
0511:  GOTO   514
0512:  BSF    03.5
0513:  GOTO   509
0514:  GOTO   54A
0515:  BSF    03.5
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
0516:  MOVF   50,W
0517:  ADDWF  4C,W
0518:  MOVWF  04
0519:  BCF    03.7
051A:  BTFSC  4D.0
051B:  BSF    03.7
051C:  MOVF   00,W
051D:  SUBLW  7E
051E:  BTFSS  03.0
051F:  GOTO   544
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
0520:  MOVF   50,W
0521:  ADDWF  4C,W
0522:  MOVWF  04
0523:  BCF    03.7
0524:  BTFSC  4D.0
0525:  BSF    03.7
0526:  MOVLW  53
0527:  SUBWF  00,W
0528:  MOVWF  5B
0529:  MOVWF  5D
052A:  MOVLW  05
052B:  MOVWF  5E
052C:  BCF    03.5
052D:  CALL   216
052E:  MOVF   78,W
052F:  BSF    03.5
0530:  MOVWF  5A
0531:  MOVWF  78
0532:  MOVLW  05
0533:  MOVWF  77
0534:  MOVLW  D5
0535:  MOVWF  04
0536:  BCF    03.7
0537:  MOVF   78,W
0538:  BCF    03.5
0539:  CALL   10A
053A:  MOVWF  00
053B:  INCF   78,F
053C:  INCF   04,F
053D:  DECFSZ 77,F
053E:  GOTO   540
053F:  GOTO   542
0540:  BSF    03.5
0541:  GOTO   537
0542:  GOTO   54A
0543:  BSF    03.5
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
0544:  CLRF   55
0545:  CLRF   56
0546:  CLRF   57
0547:  CLRF   58
0548:  CLRF   59
0549:  BCF    03.5
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
054A:  MOVLW  05
054B:  BSF    03.5
054C:  MOVWF  5D
054D:  MOVF   4E,W
054E:  MOVWF  5E
054F:  BCF    03.5
0550:  CALL   216
0551:  MOVF   78,W
0552:  BSF    03.5
0553:  ADDWF  4A,W
0554:  SUBLW  7F
0555:  BTFSC  03.0
0556:  GOTO   562
....................       { 
....................          x = 0;                           // Set x at far left position 
0557:  CLRF   4A
....................          y += 7*size + 1;                 // Set y at next position down 
0558:  MOVLW  07
0559:  MOVWF  5D
055A:  MOVF   4E,W
055B:  MOVWF  5E
055C:  BCF    03.5
055D:  CALL   216
055E:  MOVLW  01
055F:  ADDWF  78,W
0560:  BSF    03.5
0561:  ADDWF  4B,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0562:  CLRF   51
0563:  MOVF   51,W
0564:  SUBLW  04
0565:  BTFSS  03.0
0566:  GOTO   5AF
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
0567:  CLRF   52
0568:  MOVLW  07
0569:  MOVWF  5D
056A:  MOVF   4E,W
056B:  MOVWF  5E
056C:  BCF    03.5
056D:  CALL   216
056E:  MOVF   78,W
056F:  BSF    03.5
0570:  SUBWF  52,W
0571:  BTFSC  03.0
0572:  GOTO   5AB
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
0573:  MOVLW  D5
0574:  ADDWF  51,W
0575:  MOVWF  04
0576:  BCF    03.7
0577:  MOVF   00,W
0578:  MOVWF  5A
0579:  MOVWF  77
057A:  MOVF   52,W
057B:  MOVWF  78
057C:  BTFSC  03.2
057D:  GOTO   582
057E:  BCF    03.0
057F:  RRF    77,F
0580:  DECFSZ 78,F
0581:  GOTO   57E
0582:  BTFSS  77.0
0583:  GOTO   5A9
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
0584:  CLRF   53
0585:  MOVF   4E,W
0586:  SUBWF  53,W
0587:  BTFSC  03.0
0588:  GOTO   5A9
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
0589:  CLRF   54
058A:  MOVF   4E,W
058B:  SUBWF  54,W
058C:  BTFSC  03.0
058D:  GOTO   5A7
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
058E:  MOVF   54,W
058F:  ADDWF  4A,W
0590:  MOVWF  5A
0591:  MOVF   52,W
0592:  MOVWF  5D
0593:  MOVF   4E,W
0594:  MOVWF  5E
0595:  BCF    03.5
0596:  CALL   216
0597:  MOVF   78,W
0598:  BSF    03.5
0599:  ADDWF  4B,W
059A:  ADDWF  53,W
059B:  MOVWF  5B
059C:  MOVF   5A,W
059D:  MOVWF  5C
059E:  MOVF   5B,W
059F:  MOVWF  5D
05A0:  MOVF   4F,W
05A1:  MOVWF  5E
05A2:  BCF    03.5
05A3:  CALL   2FE
05A4:  BSF    03.5
05A5:  INCF   54,F
05A6:  GOTO   58A
....................                   } 
05A7:  INCF   53,F
05A8:  GOTO   585
....................                } 
....................             } 
05A9:  INCF   52,F
05AA:  GOTO   568
....................          } 
05AB:  INCF   51,F
05AC:  MOVF   4E,W
05AD:  ADDWF  4A,F
05AE:  GOTO   563
....................       } 
05AF:  INCF   50,F
05B0:  INCF   4A,F
05B1:  GOTO   4DF
....................    } 
05B2:  BCF    03.5
05B3:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
023D:  BSF    03.5
023E:  CLRF   4C
023F:  MOVF   4C,W
0240:  SUBLW  07
0241:  BTFSS  03.0
0242:  GOTO   296
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
0243:  BCF    06.2
0244:  BCF    03.5
0245:  BCF    06.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0246:  MOVLW  30
0247:  BSF    03.5
0248:  MOVWF  62
0249:  MOVLW  40
024A:  MOVWF  63
024B:  BCF    03.5
024C:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
024D:  MOVLW  31
024E:  BSF    03.5
024F:  MOVWF  62
0250:  MOVLW  40
0251:  MOVWF  63
0252:  BCF    03.5
0253:  CALL   1EA
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
0254:  BSF    03.5
0255:  MOVF   4C,W
0256:  IORLW  B8
0257:  MOVWF  4E
0258:  MOVLW  30
0259:  MOVWF  62
025A:  MOVF   4E,W
025B:  MOVWF  63
025C:  BCF    03.5
025D:  CALL   1EA
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
025E:  BSF    03.5
025F:  MOVF   4C,W
0260:  IORLW  B8
0261:  MOVWF  4E
0262:  MOVLW  31
0263:  MOVWF  62
0264:  MOVF   4E,W
0265:  MOVWF  63
0266:  BCF    03.5
0267:  CALL   1EA
....................       output_high(GLCD_DI);                     // Set for data 
0268:  BSF    03.5
0269:  BCF    06.2
026A:  BCF    03.5
026B:  BSF    06.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
026C:  BSF    03.5
026D:  CLRF   4D
026E:  MOVF   4D,W
026F:  SUBLW  3F
0270:  BTFSS  03.0
0271:  GOTO   294
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0272:  MOVLW  FF
0273:  MOVWF  5D
0274:  MOVF   4B,W
0275:  MOVWF  5E
0276:  BCF    03.5
0277:  CALL   216
0278:  MOVF   78,W
0279:  BSF    03.5
027A:  MOVWF  4E
027B:  MOVLW  30
027C:  MOVWF  62
027D:  MOVF   4E,W
027E:  MOVWF  63
027F:  BCF    03.5
0280:  CALL   1EA
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
0281:  MOVLW  FF
0282:  BSF    03.5
0283:  MOVWF  5D
0284:  MOVF   4B,W
0285:  MOVWF  5E
0286:  BCF    03.5
0287:  CALL   216
0288:  MOVF   78,W
0289:  BSF    03.5
028A:  MOVWF  4E
028B:  MOVLW  31
028C:  MOVWF  62
028D:  MOVF   4E,W
028E:  MOVWF  63
028F:  BCF    03.5
0290:  CALL   1EA
0291:  BSF    03.5
0292:  INCF   4D,F
0293:  GOTO   26E
....................       } 
0294:  INCF   4C,F
0295:  GOTO   23F
....................    } 
0296:  BCF    03.5
0297:  RETURN
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
01EA:  BSF    03.5
01EB:  MOVF   62,W
01EC:  SUBLW  30
01ED:  BTFSS  03.2
01EE:  GOTO   1F4
....................       output_high(GLCD_CS1); 
01EF:  BCF    06.0
01F0:  BCF    03.5
01F1:  BSF    06.0
01F2:  GOTO   1F7
01F3:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS2); 
01F4:  BCF    06.1
01F5:  BCF    03.5
01F6:  BSF    06.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
01F7:  BSF    03.5
01F8:  BCF    06.4
01F9:  BCF    03.5
01FA:  BCF    06.4
....................    output_d(data);            // Put the data on the port 
01FB:  BSF    03.5
01FC:  CLRF   08
01FD:  MOVF   63,W
01FE:  BCF    03.5
01FF:  MOVWF  08
....................    output_high(GLCD_E);       // Pulse the enable pin 
0200:  BSF    03.5
0201:  BCF    06.5
0202:  BCF    03.5
0203:  BSF    06.5
....................    delay_us(2); 
0204:  MOVLW  02
0205:  MOVWF  77
0206:  DECFSZ 77,F
0207:  GOTO   206
0208:  NOP
....................    output_low(GLCD_E); 
0209:  BSF    03.5
020A:  BCF    06.5
020B:  BCF    03.5
020C:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
020D:  BSF    03.5
020E:  BCF    06.0
020F:  BCF    03.5
0210:  BCF    06.0
....................    output_low(GLCD_CS2); 
0211:  BSF    03.5
0212:  BCF    06.1
0213:  BCF    03.5
0214:  BCF    06.1
0215:  RETURN
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
032D:  MOVF   61,W
032E:  SUBLW  30
032F:  BTFSS  03.2
0330:  GOTO   336
....................       output_high(GLCD_CS1); 
0331:  BCF    06.0
0332:  BCF    03.5
0333:  BSF    06.0
0334:  GOTO   339
0335:  BSF    03.5
....................    else 
....................       output_high(GLCD_CS2); 
0336:  BCF    06.1
0337:  BCF    03.5
0338:  BSF    06.1
....................  
....................    input_d();                 // Set port d to input 
0339:  MOVLW  FF
033A:  BSF    03.5
033B:  MOVWF  08
....................    output_high(GLCD_RW);      // Set for reading 
033C:  BCF    06.4
033D:  BCF    03.5
033E:  BSF    06.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
033F:  BSF    03.5
0340:  BCF    06.5
0341:  BCF    03.5
0342:  BSF    06.5
....................    delay_us(2); 
0343:  MOVLW  02
0344:  MOVWF  77
0345:  DECFSZ 77,F
0346:  GOTO   345
0347:  NOP
....................    output_low(GLCD_E); 
0348:  BSF    03.5
0349:  BCF    06.5
034A:  BCF    03.5
034B:  BCF    06.5
....................    delay_us(2); 
034C:  MOVLW  02
034D:  MOVWF  77
034E:  DECFSZ 77,F
034F:  GOTO   34E
0350:  NOP
....................    output_high(GLCD_E);       // Pulse the enable pin 
0351:  BSF    03.5
0352:  BCF    06.5
0353:  BCF    03.5
0354:  BSF    06.5
....................    delay_us(2); 
0355:  MOVLW  02
0356:  MOVWF  77
0357:  DECFSZ 77,F
0358:  GOTO   357
0359:  NOP
....................    data = input_d();          // Get the data from the display's output register 
035A:  MOVLW  FF
035B:  BSF    03.5
035C:  MOVWF  08
035D:  BCF    03.5
035E:  MOVF   08,W
035F:  BSF    03.5
0360:  MOVWF  62
....................    output_low(GLCD_E); 
0361:  BCF    06.5
0362:  BCF    03.5
0363:  BCF    06.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0364:  BSF    03.5
0365:  BCF    06.0
0366:  BCF    03.5
0367:  BCF    06.0
....................    output_low(GLCD_CS2); 
0368:  BSF    03.5
0369:  BCF    06.1
036A:  BCF    03.5
036B:  BCF    06.1
....................    return data;               // Return the read data 
036C:  BSF    03.5
036D:  MOVF   62,W
036E:  MOVWF  78
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define uchar unsigned char 
....................  
.................... // Izgara parametreleri 
.................... #define GRID_SIZE     6 
.................... #define GRID_COLS     10 
.................... #define GRID_ROWS     10 
.................... #define GRID_ORIGIN_X 0 
.................... #define GRID_ORIGIN_Y 0 
....................  
.................... uchar SNAKE[40][2]; 
.................... uchar dir = 2; 
.................... uchar food[2], LENGTH_SNAKE = 3; 
.................... uchar posX = 1, posY = 2; 
.................... uchar score = 0; 
.................... uchar best_score = 0; 
.................... char score_txt[11] = "Score: 00"; 
*
081A:  MOVLW  53
081B:  BSF    03.5
081C:  MOVWF  24
081D:  MOVLW  63
081E:  MOVWF  25
081F:  MOVLW  6F
0820:  MOVWF  26
0821:  MOVLW  72
0822:  MOVWF  27
0823:  MOVLW  65
0824:  MOVWF  28
0825:  MOVLW  3A
0826:  MOVWF  29
0827:  MOVLW  20
0828:  MOVWF  2A
0829:  MOVLW  30
082A:  MOVWF  2B
082B:  MOVWF  2C
082C:  CLRF   2D
.................... char best_score_txt[10] = "Best: 00"; 
082D:  MOVLW  42
082E:  MOVWF  2F
082F:  MOVLW  65
0830:  MOVWF  30
0831:  MOVLW  73
0832:  MOVWF  31
0833:  MOVLW  74
0834:  MOVWF  32
0835:  MOVLW  3A
0836:  MOVWF  33
0837:  MOVLW  20
0838:  MOVWF  34
0839:  MOVLW  30
083A:  MOVWF  35
083B:  MOVWF  36
083C:  CLRF   37
.................... char gayover[14]= "GAME OVER !!!"; 
083D:  MOVLW  47
083E:  MOVWF  39
083F:  MOVLW  41
0840:  MOVWF  3A
0841:  MOVLW  4D
0842:  MOVWF  3B
0843:  MOVLW  45
0844:  MOVWF  3C
0845:  MOVLW  20
0846:  MOVWF  3D
0847:  MOVLW  4F
0848:  MOVWF  3E
0849:  MOVLW  56
084A:  MOVWF  3F
084B:  MOVLW  45
084C:  MOVWF  40
084D:  MOVLW  52
084E:  MOVWF  41
084F:  MOVLW  20
0850:  MOVWF  42
0851:  MOVLW  21
0852:  MOVWF  43
0853:  MOVWF  44
0854:  MOVWF  45
0855:  CLRF   46
.................... uchar i; 
....................  
.................... // Izgaray iz 
.................... void drawGrid() { 
....................    for (uchar c = 0; c <= GRID_COLS; c++) { 
*
048D:  BSF    03.5
048E:  CLRF   4A
048F:  MOVF   4A,W
0490:  SUBLW  0A
0491:  BTFSS  03.0
0492:  GOTO   4AA
....................       uchar x = GRID_ORIGIN_X + c * GRID_SIZE; 
0493:  MOVF   4A,W
0494:  MOVWF  5D
0495:  MOVLW  06
0496:  MOVWF  5E
0497:  BCF    03.5
0498:  CALL   216
0499:  MOVF   78,W
049A:  BSF    03.5
049B:  MOVWF  4B
....................       glcd_line(x, GRID_ORIGIN_Y, x, GRID_ORIGIN_Y + GRID_ROWS * GRID_SIZE, 1); 
049C:  MOVF   4B,W
049D:  MOVWF  4E
049E:  CLRF   4F
049F:  MOVF   4B,W
04A0:  MOVWF  50
04A1:  MOVLW  3C
04A2:  MOVWF  51
04A3:  MOVLW  01
04A4:  MOVWF  52
04A5:  BCF    03.5
04A6:  CALL   3A9
04A7:  BSF    03.5
04A8:  INCF   4A,F
04A9:  GOTO   48F
....................    } 
....................    for (uchar r = 0; r <= GRID_ROWS; r++) { 
04AA:  CLRF   4C
04AB:  MOVF   4C,W
04AC:  SUBLW  0A
04AD:  BTFSS  03.0
04AE:  GOTO   4C6
....................       uchar y = GRID_ORIGIN_Y + r * GRID_SIZE; 
04AF:  MOVF   4C,W
04B0:  MOVWF  5D
04B1:  MOVLW  06
04B2:  MOVWF  5E
04B3:  BCF    03.5
04B4:  CALL   216
04B5:  MOVF   78,W
04B6:  BSF    03.5
04B7:  MOVWF  4D
....................       glcd_line(GRID_ORIGIN_X, y, GRID_ORIGIN_X + GRID_COLS * GRID_SIZE, y, 1); 
04B8:  CLRF   4E
04B9:  MOVF   4D,W
04BA:  MOVWF  4F
04BB:  MOVLW  3C
04BC:  MOVWF  50
04BD:  MOVF   4D,W
04BE:  MOVWF  51
04BF:  MOVLW  01
04C0:  MOVWF  52
04C1:  BCF    03.5
04C2:  CALL   3A9
04C3:  BSF    03.5
04C4:  INCF   4C,F
04C5:  GOTO   4AB
....................    } 
04C6:  BCF    03.5
04C7:  RETURN
.................... } 
....................  
.................... // Hcreyi doldur/boalt 
.................... void fillCell(uchar gx, uchar gy, int1 color) { 
*
068A:  BSF    03.5
068B:  MOVF   4C,W
068C:  MOVWF  5D
068D:  MOVLW  06
068E:  MOVWF  5E
068F:  BCF    03.5
0690:  CALL   216
0691:  MOVLW  01
0692:  ADDWF  78,W
0693:  BSF    03.5
0694:  MOVWF  4F
0695:  MOVF   4D,W
0696:  MOVWF  5D
0697:  MOVLW  06
0698:  MOVWF  5E
0699:  BCF    03.5
069A:  CALL   216
069B:  MOVLW  01
069C:  ADDWF  78,W
069D:  BSF    03.5
069E:  MOVWF  50
....................    uchar px = GRID_ORIGIN_X + gx * GRID_SIZE + 1; 
....................    uchar py = GRID_ORIGIN_Y + gy * GRID_SIZE + 1; 
....................    for (uchar dx = 0; dx < GRID_SIZE - 1; dx++) 
069F:  CLRF   51
06A0:  MOVF   51,W
06A1:  SUBLW  04
06A2:  BTFSS  03.0
06A3:  GOTO   6BC
....................       for (uchar dy = 0; dy < GRID_SIZE - 1; dy++) 
06A4:  CLRF   52
06A5:  MOVF   52,W
06A6:  SUBLW  04
06A7:  BTFSS  03.0
06A8:  GOTO   6BA
....................          glcd_pixel(px + dx, py + dy, color); 
06A9:  MOVF   51,W
06AA:  ADDWF  4F,W
06AB:  MOVWF  53
06AC:  MOVF   52,W
06AD:  ADDWF  50,W
06AE:  MOVWF  54
06AF:  MOVF   53,W
06B0:  MOVWF  5C
06B1:  MOVF   54,W
06B2:  MOVWF  5D
06B3:  MOVF   4E,W
06B4:  MOVWF  5E
06B5:  BCF    03.5
06B6:  CALL   2FE
06B7:  BSF    03.5
06B8:  INCF   52,F
06B9:  GOTO   6A5
06BA:  INCF   51,F
06BB:  GOTO   6A0
06BC:  BCF    03.5
06BD:  RETURN
.................... } 
....................  
.................... // Skor alann temizle 
.................... void clearScoreArea() { 
....................    for (uchar x = 65; x < 125; x++) { 
*
05B4:  MOVLW  41
05B5:  BSF    03.5
05B6:  MOVWF  4A
05B7:  MOVF   4A,W
05B8:  SUBLW  7C
05B9:  BTFSS  03.0
05BA:  GOTO   5CC
....................       for (uchar y = 0; y < 20; y++) { 
05BB:  CLRF   4B
05BC:  MOVF   4B,W
05BD:  SUBLW  13
05BE:  BTFSS  03.0
05BF:  GOTO   5CA
....................          glcd_pixel(x, y, 0); 
05C0:  MOVF   4A,W
05C1:  MOVWF  5C
05C2:  MOVF   4B,W
05C3:  MOVWF  5D
05C4:  CLRF   5E
05C5:  BCF    03.5
05C6:  CALL   2FE
05C7:  BSF    03.5
05C8:  INCF   4B,F
05C9:  GOTO   5BC
....................       } 
05CA:  INCF   4A,F
05CB:  GOTO   5B7
....................    } 
.................... } 
....................  
.................... // Skoru yaz 
.................... void writeScore() { 
....................    clearScoreArea(); 
....................    glcd_text57(65, 0, score_txt, 1, 1); 
05CC:  MOVLW  41
05CD:  MOVWF  4A
05CE:  CLRF   4B
05CF:  CLRF   4D
05D0:  MOVLW  A4
05D1:  MOVWF  4C
05D2:  MOVLW  01
05D3:  MOVWF  4E
05D4:  MOVWF  4F
05D5:  BCF    03.5
05D6:  CALL   4DD
....................    glcd_text57(65, 10, best_score_txt, 1, 1); 
05D7:  MOVLW  41
05D8:  BSF    03.5
05D9:  MOVWF  4A
05DA:  MOVLW  0A
05DB:  MOVWF  4B
05DC:  CLRF   4D
05DD:  MOVLW  AF
05DE:  MOVWF  4C
05DF:  MOVLW  01
05E0:  MOVWF  4E
05E1:  MOVWF  4F
05E2:  BCF    03.5
05E3:  CALL   4DD
05E4:  RETURN
.................... } 
....................  
.................... // Yemi olutur 
.................... void criar_comida() { 
*
06BE:  BSF    03.5
06BF:  CLRF   4A
....................    uchar valid = 0; 
....................    while (!valid) { 
06C0:  MOVF   4A,F
06C1:  BTFSS  03.2
06C2:  GOTO   706
....................       food[0] = rand() % GRID_COLS; 
06C3:  BCF    03.5
06C4:  CALL   60C
06C5:  MOVF   79,W
06C6:  BSF    03.5
06C7:  MOVWF  4D
06C8:  MOVF   78,W
06C9:  MOVWF  4C
06CA:  MOVF   4D,W
06CB:  MOVWF  50
06CC:  MOVF   4C,W
06CD:  MOVWF  4F
06CE:  CLRF   52
06CF:  MOVLW  0A
06D0:  MOVWF  51
06D1:  BCF    03.5
06D2:  CALL   5E5
06D3:  MOVF   77,W
06D4:  MOVWF  7C
....................       food[1] = rand() % GRID_ROWS; 
06D5:  CALL   60C
06D6:  MOVF   79,W
06D7:  BSF    03.5
06D8:  MOVWF  4D
06D9:  MOVF   78,W
06DA:  MOVWF  4C
06DB:  MOVF   4D,W
06DC:  MOVWF  50
06DD:  MOVF   4C,W
06DE:  MOVWF  4F
06DF:  CLRF   52
06E0:  MOVLW  0A
06E1:  MOVWF  51
06E2:  BCF    03.5
06E3:  CALL   5E5
06E4:  MOVF   77,W
06E5:  MOVWF  7D
....................       valid = 1; 
06E6:  MOVLW  01
06E7:  BSF    03.5
06E8:  MOVWF  4A
....................       for (uchar j = 0; j < LENGTH_SNAKE; j++) { 
06E9:  CLRF   4B
06EA:  MOVF   7E,W
06EB:  SUBWF  4B,W
06EC:  BTFSC  03.0
06ED:  GOTO   705
....................          if (SNAKE[j][0] == food[0] && SNAKE[j][1] == food[1]) { 
06EE:  BCF    03.0
06EF:  RLF    4B,W
06F0:  ADDLW  27
06F1:  MOVWF  04
06F2:  BCF    03.7
06F3:  MOVF   7C,W
06F4:  SUBWF  00,W
06F5:  BTFSS  03.2
06F6:  GOTO   703
06F7:  BCF    03.0
06F8:  RLF    4B,W
06F9:  ADDLW  01
06FA:  ADDLW  27
06FB:  MOVWF  04
06FC:  BCF    03.7
06FD:  MOVF   7D,W
06FE:  SUBWF  00,W
06FF:  BTFSS  03.2
0700:  GOTO   703
....................             valid = 0; 
0701:  CLRF   4A
....................             break; 
0702:  GOTO   705
....................          } 
0703:  INCF   4B,F
0704:  GOTO   6EA
....................       } 
0705:  GOTO   6C0
....................    } 
....................    fillCell(food[0], food[1], 1); 
0706:  MOVF   7C,W
0707:  MOVWF  4C
0708:  MOVF   7D,W
0709:  MOVWF  4D
070A:  MOVLW  01
070B:  MOVWF  4E
070C:  BCF    03.5
070D:  CALL   68A
070E:  RETURN
.................... } 
....................  
.................... // Oyun sonu 
.................... void gameover() { 
....................    LENGTH_SNAKE = 3; 
070F:  MOVLW  03
0710:  MOVWF  7E
....................    posX = 1; 
0711:  MOVLW  01
0712:  BSF    03.5
0713:  MOVWF  20
....................    posY = 2; 
0714:  MOVLW  02
0715:  MOVWF  21
....................    score = 0; 
0716:  CLRF   22
....................    score_txt[7] = score_txt[8] = '0'; 
0717:  MOVLW  30
0718:  MOVWF  2C
0719:  MOVWF  2B
....................    dir = 2; 
071A:  MOVLW  02
071B:  MOVWF  7B
....................    glcd_fillScreen(0); 
071C:  CLRF   4B
071D:  BCF    03.5
071E:  CALL   23D
....................    drawGrid(); 
071F:  CALL   48D
....................    glcd_text57(25, 60, gayover, 1, 1); 
0720:  MOVLW  19
0721:  BSF    03.5
0722:  MOVWF  4A
0723:  MOVLW  3C
0724:  MOVWF  4B
0725:  CLRF   4D
0726:  MOVLW  B9
0727:  MOVWF  4C
0728:  MOVLW  01
0729:  MOVWF  4E
072A:  MOVWF  4F
072B:  BCF    03.5
072C:  CALL   4DD
....................    delay_ms(1000); 
072D:  MOVLW  04
072E:  BSF    03.5
072F:  MOVWF  4A
0730:  MOVLW  FA
0731:  MOVWF  4B
0732:  BCF    03.5
0733:  CALL   4C8
0734:  BSF    03.5
0735:  DECFSZ 4A,F
0736:  GOTO   730
0737:  BCF    03.5
0738:  RETURN
.................... } 
....................  
.................... void main() { 
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  FF
0804:  MOVWF  26
0805:  MOVLW  02
0806:  MOVWF  7B
0807:  MOVLW  03
0808:  MOVWF  7E
0809:  MOVLW  01
080A:  BSF    03.5
080B:  MOVWF  20
080C:  MOVLW  02
080D:  MOVWF  21
080E:  CLRF   22
080F:  CLRF   23
0810:  BSF    1F.0
0811:  BSF    1F.1
0812:  BSF    1F.2
0813:  BCF    1F.3
0814:  MOVLW  07
0815:  MOVWF  1C
0816:  BCF    03.7
....................    glcd_init(ON); 
*
0856:  MOVLW  01
0857:  MOVWF  4A
0858:  BCF    0A.3
0859:  BCF    03.5
085A:  GOTO   298
085B:  BSF    0A.3
....................    glcd_fillScreen(0); 
085C:  BSF    03.5
085D:  CLRF   4B
085E:  BCF    0A.3
085F:  BCF    03.5
0860:  CALL   23D
0861:  BSF    0A.3
....................    drawGrid(); 
0862:  BCF    0A.3
0863:  CALL   48D
0864:  BSF    0A.3
....................    delay_ms(500); 
0865:  MOVLW  02
0866:  BSF    03.5
0867:  MOVWF  4A
0868:  MOVLW  FA
0869:  MOVWF  4B
086A:  BCF    0A.3
086B:  BCF    03.5
086C:  CALL   4C8
086D:  BSF    0A.3
086E:  BSF    03.5
086F:  DECFSZ 4A,F
0870:  GOTO   068
....................  
.................... Start: 
....................    glcd_fillScreen(0); 
0871:  CLRF   4B
0872:  BCF    0A.3
0873:  BCF    03.5
0874:  CALL   23D
0875:  BSF    0A.3
....................    drawGrid(); 
0876:  BCF    0A.3
0877:  CALL   48D
0878:  BSF    0A.3
....................    writeScore(); 
0879:  BCF    0A.3
087A:  CALL   5B4
087B:  BSF    0A.3
....................    criar_comida(); 
087C:  BCF    0A.3
087D:  CALL   6BE
087E:  BSF    0A.3
....................  
....................    for (i = 0; i < LENGTH_SNAKE; i++) { 
087F:  BSF    03.5
0880:  CLRF   47
0881:  MOVF   7E,W
0882:  SUBWF  47,W
0883:  BTFSC  03.0
0884:  GOTO   0B5
....................       SNAKE[i][0] = posX - (LENGTH_SNAKE - 1 - i); 
0885:  BCF    03.0
0886:  RLF    47,W
0887:  ADDLW  27
0888:  MOVWF  04
0889:  BCF    03.7
088A:  MOVLW  01
088B:  SUBWF  7E,W
088C:  MOVWF  78
088D:  MOVF   47,W
088E:  SUBWF  78,W
088F:  SUBWF  20,W
0890:  MOVWF  00
....................       SNAKE[i][1] = posY; 
0891:  BCF    03.0
0892:  RLF    47,W
0893:  ADDLW  01
0894:  ADDLW  27
0895:  MOVWF  04
0896:  BCF    03.7
0897:  MOVF   21,W
0898:  MOVWF  00
....................       fillCell(SNAKE[i][0], SNAKE[i][1], 1); 
0899:  BCF    03.0
089A:  RLF    47,W
089B:  ADDLW  27
089C:  MOVWF  04
089D:  BCF    03.7
089E:  MOVF   00,W
089F:  MOVWF  4A
08A0:  BCF    03.0
08A1:  RLF    47,W
08A2:  ADDLW  01
08A3:  ADDLW  27
08A4:  MOVWF  04
08A5:  BCF    03.7
08A6:  MOVF   00,W
08A7:  MOVWF  4B
08A8:  MOVF   4A,W
08A9:  MOVWF  4C
08AA:  MOVF   4B,W
08AB:  MOVWF  4D
08AC:  MOVLW  01
08AD:  MOVWF  4E
08AE:  BCF    0A.3
08AF:  BCF    03.5
08B0:  CALL   68A
08B1:  BSF    0A.3
08B2:  BSF    03.5
08B3:  INCF   47,F
08B4:  GOTO   081
....................    } 
....................  
....................    while (TRUE) { 
....................       if (input(PIN_C3) && dir != 0) dir = 3; 
08B5:  BCF    03.5
08B6:  BSF    26.3
08B7:  MOVF   26,W
08B8:  BSF    03.5
08B9:  MOVWF  07
08BA:  BCF    03.5
08BB:  BTFSS  07.3
08BC:  GOTO   0C2
08BD:  MOVF   7B,F
08BE:  BTFSC  03.2
08BF:  GOTO   0C2
08C0:  MOVLW  03
08C1:  MOVWF  7B
....................       if (input(PIN_C2) && dir != 1) dir = 2; 
08C2:  BSF    26.2
08C3:  MOVF   26,W
08C4:  BSF    03.5
08C5:  MOVWF  07
08C6:  BCF    03.5
08C7:  BTFSS  07.2
08C8:  GOTO   0CE
08C9:  DECFSZ 7B,W
08CA:  GOTO   0CC
08CB:  GOTO   0CE
08CC:  MOVLW  02
08CD:  MOVWF  7B
....................       if (input(PIN_C1) && dir != 2) dir = 1; 
08CE:  BSF    26.1
08CF:  MOVF   26,W
08D0:  BSF    03.5
08D1:  MOVWF  07
08D2:  BCF    03.5
08D3:  BTFSS  07.1
08D4:  GOTO   0DB
08D5:  MOVF   7B,W
08D6:  SUBLW  02
08D7:  BTFSC  03.2
08D8:  GOTO   0DB
08D9:  MOVLW  01
08DA:  MOVWF  7B
....................       if (input(PIN_C4) && dir != 3) dir = 0; 
08DB:  BSF    26.4
08DC:  MOVF   26,W
08DD:  BSF    03.5
08DE:  MOVWF  07
08DF:  BCF    03.5
08E0:  BTFSS  07.4
08E1:  GOTO   0E6
08E2:  MOVF   7B,W
08E3:  SUBLW  03
08E4:  BTFSS  03.2
08E5:  CLRF   7B
....................       if (input(PIN_C5)) { gameover(); goto Start; } 
08E6:  BSF    26.5
08E7:  MOVF   26,W
08E8:  BSF    03.5
08E9:  MOVWF  07
08EA:  BCF    03.5
08EB:  BTFSS  07.5
08EC:  GOTO   0F3
08ED:  BCF    0A.3
08EE:  CALL   70F
08EF:  BSF    0A.3
08F0:  BSF    03.5
08F1:  GOTO   071
08F2:  BCF    03.5
....................  
....................       switch(dir) { 
08F3:  MOVF   7B,W
08F4:  ADDLW  FC
08F5:  BTFSC  03.0
08F6:  GOTO   132
08F7:  ADDLW  04
08F8:  GOTO   223
....................          case 0: if (posX == 0) { gameover(); goto Start; } else posX--; break; 
08F9:  BSF    03.5
08FA:  MOVF   20,F
08FB:  BTFSS  03.2
08FC:  GOTO   104
08FD:  BCF    0A.3
08FE:  BCF    03.5
08FF:  CALL   70F
0900:  BSF    0A.3
0901:  BSF    03.5
0902:  GOTO   071
0903:  GOTO   105
0904:  DECF   20,F
0905:  BCF    03.5
0906:  GOTO   132
....................          case 1: if (posY == 0) { gameover(); goto Start; } else posY--; break; 
0907:  BSF    03.5
0908:  MOVF   21,F
0909:  BTFSS  03.2
090A:  GOTO   112
090B:  BCF    0A.3
090C:  BCF    03.5
090D:  CALL   70F
090E:  BSF    0A.3
090F:  BSF    03.5
0910:  GOTO   071
0911:  GOTO   113
0912:  DECF   21,F
0913:  BCF    03.5
0914:  GOTO   132
....................          case 2: if (posY == GRID_ROWS - 1) { gameover(); goto Start; } else posY++; break; 
0915:  BSF    03.5
0916:  MOVF   21,W
0917:  SUBLW  09
0918:  BTFSS  03.2
0919:  GOTO   121
091A:  BCF    0A.3
091B:  BCF    03.5
091C:  CALL   70F
091D:  BSF    0A.3
091E:  BSF    03.5
091F:  GOTO   071
0920:  GOTO   122
0921:  INCF   21,F
0922:  BCF    03.5
0923:  GOTO   132
....................          case 3: if (posX == GRID_COLS - 1) { gameover(); goto Start; } else posX++; break; 
0924:  BSF    03.5
0925:  MOVF   20,W
0926:  SUBLW  09
0927:  BTFSS  03.2
0928:  GOTO   130
0929:  BCF    0A.3
092A:  BCF    03.5
092B:  CALL   70F
092C:  BSF    0A.3
092D:  BSF    03.5
092E:  GOTO   071
092F:  GOTO   131
0930:  INCF   20,F
0931:  BCF    03.5
....................       } 
....................  
....................       uchar tailX = SNAKE[0][0], tailY = SNAKE[0][1]; 
0932:  MOVF   27,W
0933:  BSF    03.5
0934:  MOVWF  48
0935:  BCF    03.5
0936:  MOVF   28,W
0937:  BSF    03.5
0938:  MOVWF  49
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
0939:  CLRF   47
093A:  MOVLW  01
093B:  SUBWF  7E,W
093C:  SUBWF  47,W
093D:  BTFSC  03.0
093E:  GOTO   175
....................          SNAKE[i][0] = SNAKE[i + 1][0]; 
093F:  BCF    03.0
0940:  RLF    47,W
0941:  ADDLW  27
0942:  MOVWF  4A
0943:  CLRF   4B
0944:  BTFSC  03.0
0945:  INCF   4B,F
0946:  MOVLW  01
0947:  ADDWF  47,W
0948:  MOVWF  77
0949:  BCF    03.0
094A:  RLF    77,F
094B:  MOVF   77,W
094C:  ADDLW  27
094D:  MOVWF  04
094E:  BCF    03.7
094F:  MOVF   00,W
0950:  MOVWF  4C
0951:  MOVF   4A,W
0952:  MOVWF  04
0953:  BCF    03.7
0954:  BTFSC  4B.0
0955:  BSF    03.7
0956:  MOVF   4C,W
0957:  MOVWF  00
....................          SNAKE[i][1] = SNAKE[i + 1][1]; 
0958:  BCF    03.0
0959:  RLF    47,W
095A:  ADDLW  01
095B:  ADDLW  27
095C:  MOVWF  4A
095D:  CLRF   4B
095E:  BTFSC  03.0
095F:  INCF   4B,F
0960:  MOVLW  01
0961:  ADDWF  47,W
0962:  MOVWF  77
0963:  BCF    03.0
0964:  RLF    77,F
0965:  MOVF   77,W
0966:  ADDLW  01
0967:  ADDLW  27
0968:  MOVWF  04
0969:  BCF    03.7
096A:  MOVF   00,W
096B:  MOVWF  4C
096C:  MOVF   4A,W
096D:  MOVWF  04
096E:  BCF    03.7
096F:  BTFSC  4B.0
0970:  BSF    03.7
0971:  MOVF   4C,W
0972:  MOVWF  00
0973:  INCF   47,F
0974:  GOTO   13A
....................       } 
....................       SNAKE[LENGTH_SNAKE - 1][0] = posX; 
0975:  MOVLW  01
0976:  SUBWF  7E,W
0977:  MOVWF  77
0978:  BCF    03.0
0979:  RLF    77,F
097A:  MOVF   77,W
097B:  ADDLW  27
097C:  MOVWF  04
097D:  BCF    03.7
097E:  MOVF   20,W
097F:  MOVWF  00
....................       SNAKE[LENGTH_SNAKE - 1][1] = posY; 
0980:  MOVLW  01
0981:  SUBWF  7E,W
0982:  MOVWF  77
0983:  BCF    03.0
0984:  RLF    77,F
0985:  MOVF   77,W
0986:  ADDLW  01
0987:  ADDLW  27
0988:  MOVWF  04
0989:  BCF    03.7
098A:  MOVF   21,W
098B:  MOVWF  00
....................  
....................       for (i = 0; i < LENGTH_SNAKE - 1; i++) { 
098C:  CLRF   47
098D:  MOVLW  01
098E:  SUBWF  7E,W
098F:  SUBWF  47,W
0990:  BTFSC  03.0
0991:  GOTO   1AD
....................          if (SNAKE[i][0] == posX && SNAKE[i][1] == posY) { 
0992:  BCF    03.0
0993:  RLF    47,W
0994:  ADDLW  27
0995:  MOVWF  04
0996:  BCF    03.7
0997:  MOVF   20,W
0998:  SUBWF  00,W
0999:  BTFSS  03.2
099A:  GOTO   1AB
099B:  BCF    03.0
099C:  RLF    47,W
099D:  ADDLW  01
099E:  ADDLW  27
099F:  MOVWF  04
09A0:  BCF    03.7
09A1:  MOVF   21,W
09A2:  SUBWF  00,W
09A3:  BTFSS  03.2
09A4:  GOTO   1AB
....................             gameover(); goto Start; 
09A5:  BCF    0A.3
09A6:  BCF    03.5
09A7:  CALL   70F
09A8:  BSF    0A.3
09A9:  BSF    03.5
09AA:  GOTO   071
....................          } 
09AB:  INCF   47,F
09AC:  GOTO   18D
....................       } 
....................  
....................       fillCell(posX, posY, 1); 
09AD:  MOVF   20,W
09AE:  MOVWF  4C
09AF:  MOVF   21,W
09B0:  MOVWF  4D
09B1:  MOVLW  01
09B2:  MOVWF  4E
09B3:  BCF    0A.3
09B4:  BCF    03.5
09B5:  CALL   68A
09B6:  BSF    0A.3
....................       fillCell(tailX, tailY, 0); 
09B7:  BSF    03.5
09B8:  MOVF   48,W
09B9:  MOVWF  4C
09BA:  MOVF   49,W
09BB:  MOVWF  4D
09BC:  CLRF   4E
09BD:  BCF    0A.3
09BE:  BCF    03.5
09BF:  CALL   68A
09C0:  BSF    0A.3
....................  
....................       if (posX == food[0] && posY == food[1]) { 
09C1:  MOVF   7C,W
09C2:  BSF    03.5
09C3:  SUBWF  20,W
09C4:  BTFSS  03.2
09C5:  GOTO   216
09C6:  MOVF   7D,W
09C7:  SUBWF  21,W
09C8:  BTFSS  03.2
09C9:  GOTO   216
....................          LENGTH_SNAKE++; 
09CA:  INCF   7E,F
....................          if (LENGTH_SNAKE >= GRID_COLS * GRID_ROWS - 2) { 
09CB:  MOVF   7E,W
09CC:  SUBLW  61
09CD:  BTFSC  03.0
09CE:  GOTO   1D5
....................             gameover(); goto Start; 
09CF:  BCF    0A.3
09D0:  BCF    03.5
09D1:  CALL   70F
09D2:  BSF    0A.3
09D3:  BSF    03.5
09D4:  GOTO   071
....................          } 
....................          criar_comida(); 
09D5:  BCF    0A.3
09D6:  BCF    03.5
09D7:  CALL   6BE
09D8:  BSF    0A.3
....................          score++; 
09D9:  BSF    03.5
09DA:  INCF   22,F
....................          score_txt[7] = '0' + (score / 10); 
09DB:  MOVF   22,W
09DC:  MOVWF  4A
09DD:  MOVLW  0A
09DE:  MOVWF  4B
09DF:  BCF    0A.3
09E0:  BCF    03.5
09E1:  CALL   739
09E2:  BSF    0A.3
09E3:  MOVF   78,W
09E4:  ADDLW  30
09E5:  BSF    03.5
09E6:  MOVWF  2B
....................          score_txt[8] = '0' + (score % 10); 
09E7:  MOVF   22,W
09E8:  MOVWF  4A
09E9:  MOVLW  0A
09EA:  MOVWF  4B
09EB:  BCF    0A.3
09EC:  BCF    03.5
09ED:  CALL   739
09EE:  BSF    0A.3
09EF:  MOVF   77,W
09F0:  ADDLW  30
09F1:  BSF    03.5
09F2:  MOVWF  2C
....................  
....................          if (score > best_score) { 
09F3:  MOVF   22,W
09F4:  SUBWF  23,W
09F5:  BTFSC  03.0
09F6:  GOTO   211
....................             best_score = score; 
09F7:  MOVF   22,W
09F8:  MOVWF  23
....................             best_score_txt[7] = '0' + (best_score / 10); 
09F9:  MOVF   23,W
09FA:  MOVWF  4A
09FB:  MOVLW  0A
09FC:  MOVWF  4B
09FD:  BCF    0A.3
09FE:  BCF    03.5
09FF:  CALL   739
0A00:  BSF    0A.3
0A01:  MOVF   78,W
0A02:  ADDLW  30
0A03:  BSF    03.5
0A04:  MOVWF  36
....................             best_score_txt[8] = '0' + (best_score % 10); 
0A05:  MOVF   23,W
0A06:  MOVWF  4A
0A07:  MOVLW  0A
0A08:  MOVWF  4B
0A09:  BCF    0A.3
0A0A:  BCF    03.5
0A0B:  CALL   739
0A0C:  BSF    0A.3
0A0D:  MOVF   77,W
0A0E:  ADDLW  30
0A0F:  BSF    03.5
0A10:  MOVWF  37
....................          } 
....................  
....................          writeScore(); 
0A11:  BCF    0A.3
0A12:  BCF    03.5
0A13:  CALL   5B4
0A14:  BSF    0A.3
0A15:  BSF    03.5
....................       } 
....................  
....................       delay_ms(600); 
0A16:  MOVLW  03
0A17:  MOVWF  4A
0A18:  MOVLW  C8
0A19:  MOVWF  4B
0A1A:  BCF    0A.3
0A1B:  BCF    03.5
0A1C:  CALL   4C8
0A1D:  BSF    0A.3
0A1E:  BSF    03.5
0A1F:  DECFSZ 4A,F
0A20:  GOTO   218
0A21:  GOTO   0B5
....................    } 
.................... } 
0A22:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
